//
// Prerequisites:
//
//   ruby 1.9.3+
//   asciidoctor     (use gem to install)
//   asciidoctor-pdf (use gem to install)
//
// Build the document:
// ===================
//
// HTML5 Asciidoctor:
//   # Embed images in XHTML
//   asciidoctor -b html5 index.adoc
//
// PDF Asciidoctor:
//   $ asciidoctor-pdf index.adoc
//
= {title}
:title:         gvNIX - Documentación de referencia
:Project:       gvNIX, un Add-On Suite de Spring Roo
:Author:        Dirección General de Tecnologías de la Información, Asociación gvSIG, DISID Corporation, S.L.
:version:       2.0.0.M1
:corpsite:      www.gvnix.org
:Copyright:     2010 (C) Dirección General de Tecnologías de la Información - Conselleria de Hacienda y Administración Pública - CC BY-NC-SA 3.0
:keywords:      gvNIX, Documentation
:doctype:       book
:toc:
:toc-placement: left
:toc-title:     Índice de contenidos
:toclevels:     5
:numbered:
:sectnumlevels:		5
:sectanchors:
:icons:         font
:imagesdir:     ./images
:source-highlighter:  coderay
ifdef::backend-pdf[]
:pdf-style:     asciidoctor
:pagenums:
endif::[]

_{version}_

_{project}_ | link:{corpsite}[{corpsite}]

[abstract]

_2010 (C) Dirección General de Tecnologías de la Información - Conselleria de Hacienda y
Administración Pública - Generalitat Valenciana._ Esta obra está bajo la licencia
http://creativecommons.org/licenses/by-sa/3.0/es/[Reconocimiento-Compartir bajo la misma licencia 3.0 España]
de Creative Commons. Puede copiarla, distribuirla y comunicarla públicamente
siempre que especifique sus autores y comparta cualquier obra derivada bajo la
misma licencia.

// Disable auto-numbering on Preface only in order to chapter one start at 1. Then on first chapter
// re-enable the auto-numbering.
:numbered!:
[preface]
= Prólogo

=== 1. Información General

gvNIX es un entorno de trabajo Java de código abierto para el desarrollo
rápido de aplicaciones web altamente productivo, flexible y que no
compromete la calidad de los proyectos.

gvNIX trabaja sobre la herramienta de desarrollo http://projects.spring.io/spring-roo[Spring Roo] 
ampliando sus funcionalidades básicas con componentes de alto nivel funcional.

gvNIX está patrocinado por la Dirección General de Tecnologías de la Información
(DGTI) de la Conselleria de Hacienda y Administración Pública de la
Generalitat Valenciana (Comunidad Valenciana, España), gestionado por la
Asociación gvSIG y dirigido por DISID. gvNIX se consolida como estándar para
desarrollo Java de la DGTI de la Generalitat Valenciana.

gvNIX está disponible dentro del proyecto de Migración a Software de
fuentes abiertas http://www.gvpontis.gva.es[gvPONTIS].

=== 2. Requisitos

Antes de empezar a trabajar con la herramienta de desarrollo gvNIX, es aconsejable conocer cómo 
funciona Spring Roo. Para ello, se recomienda leer la 
http://docs.spring.io/spring-roo/docs/2.0.0.M1/reference/html/[documentación de referencia].

gvNIX crea aplicaciones web basadas en 
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/[Spring Framework] 
y en el conjunto de tecnologías de http://spring.io/[Spring], 
por lo que es necesario tener conocimientos del framework Spring y tecnologías relacionadas 
como Spring MVC, Spring Data JPA, Spring Security, etc.

Para poder trabajar con la herramienta de desarrollo gvNIX en un entorno de desarrollo, es necesario disponer de 
los siguientes componentes:

* http://projects.spring.io/spring-roo/#running-from-shell[Spring Roo 2.0+] descargado y
descomprimido.
* Versión más actual de Java JDK 6 instalado en el sistema. Se 
recomienda utiliar *Java 7*, aunque se dispone de soporte para Java 8.
(http://www.oracle.com/technetwork/java/javase/downloads/index.html[Más
información]).
* Maven 3.0.5 o superior (http://maven.apache.org/).
* Conexión a Internet para poder instalar de forma correcta gvNIX en
la distribución de Spring Roo y descargar las dependencias de los
proyectos generados.
* En caso de utilizar un IDE durante el desarrollo, se recomienda utilizar https://spring.io/tools/sts/all[STS] 3.7+. 


[NOTE]
====
Solo es posible utilizar gvNIX 2.0+ sobre las versiones 2.0
de Spring Roo en adelante. Esto es debido a que la instalación de 
distribuciones es una característica de las últimas versiones 
de Spring Roo.
====

[NOTE]
====
Si se utiliza gvNIX sobre el IDE de desarrollo STS, será necesario utilizar la versión
3.7 o superior del mismo, ya que soporta las últimas funcionalidades de gvNIX 2.0
====

=== 3. Instalar gvNIX

Para instalar el gvNIX sobre una distribución de Spring Roo. es necesario que Roo conozca 
donde están alojados todos los componentes que forman parte de gvNIX.
Por ello, es necesario instalar en nuestra distribución de Spring Roo el repositorio donde se 
encuentran dichos componentes.

Sigue los siguientes pasos para instalar el repositorio de gvNIX en tu distribución de
Spring Roo 2.0+:

1. Ejecuta la consola de Spring Roo 2.0+:
+
--------------------------------------------
bash:~$ cd /tmp/new_project
bash:~$ ~/software/spring-roo-2.0/bin/roo.sh
--------------------------------------------

2. Accede al http://projects.spring.io/spring-roo/marketplace/["Roo Market Place"] y
copia la URL del repositorio de gvNIX (http://repository.gvnix.org/index.xml).

3. Ejecuta el siguiente comando en tu consola de Spring Roo 2.0+ para 
instalar el repositorio anterior:
+
----------------------------------------------------------------------
roo> addon repository add --url http://repository.gvnix.org/index.xml
----------------------------------------------------------------------

4. Valida que se ha instalado el repositorio de forma correcta listando los componentes
que están disponibles en dicho repositorio. Para ello, ejecuta el siguiente comando:
+
---------------------------------
roo> addon repository introspect
---------------------------------

5. Si todo ha salido bien, aparecerá un listado mostrando todos los componente que forman
parte de la distribución gvNIX.
+
----------------------------------------------------------------------------------------
Not Installed        gvNIX - Addon - Bootstrap3 support (2.0.0.M1)
Not Installed        gvNIX - Addon - Co-official languages of Spain (2.0.0.M1)
Not Installed        gvNIX - Addon - Dynamic Configuration (2.0.0.M1)
Not Installed        gvNIX - Addon - GEO Support (2.0.0.M1)
Not Installed        gvNIX - Addon - JPA layer services (2.0.0.M1)
Not Installed        gvNIX - Addon - Loupe Fields (2.0.0.M1)
Not Installed        gvNIX - Addon - Monitoring Support (2.0.0.M1)
Not Installed        gvNIX - Addon - Optimistic Concurrency Control (2.0.0.M1)
Not Installed        gvNIX - Addon - Services Management (2.0.0.M1)
Not Installed        gvNIX - Addon - Typical Security (2.0.0.M1)
Not Installed        gvNIX - Addon - Web Datatables Addon (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC (JSP) layer services (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Bindings (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Dialogs (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Menu (2.0.0.M1)
Not Installed        gvNIX - Addon - Web Report (2.0.0.M1)
Not Installed        gvNIX - Annotations - GEO Support (2.0.0.M1)
Not Installed        gvNIX - Annotations - JPA layer services (2.0.0.M1)
Not Installed        gvNIX - Annotations - Loupe Fields (2.0.0.M1)
Not Installed        gvNIX - Annotations - Optimistic Concurrency Control (2.0.0.M1)
Not Installed        gvNIX - Annotations - Services Management (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web Datatables Addon (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC (JSP) layer services (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC Bindings (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC Dialogs (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web Report (2.0.0.M1)
Not Installed        gvNIX - Roo Addon Suite (2.0.0.M1)
Not Installed        gvNIX - Support Module (2.0.0.M1)
----------------------------------------------------------------------------------------

6. Ahora que ya tienes instalado el repositorio que contiene los componentes de gvNIX, continuamos con
la instalación de los mismos. Para ello ejecuta el siguiente comando:
+
----------------------------------------------------------------------
roo> addon suite install name --symbolicName org.gvnix.roo.addon.suite
----------------------------------------------------------------------

7. Valida que se ha instalado el Roo Add-On Suite de gvNIX ejecutando el siguiente comando:
+
----------------------
roo> addon suite list
----------------------

8. Si todo ha salido bien, aparecerá un listado mostrando todos los Roo Add-On Suites que tienes
instalados en tu distribución de Spring Roo:
+
----------------------------------------------------------------
Getting all 'Roo Addon Suites' installed on Spring Roo Shell... 

   org.osgi.service.subsystem.root
   org.gvnix.roo.addon.suite
   
2 Roo Addon Suites were found at your Spring Roo installation
----------------------------------------------------------------

9. Para finalizar, valida que todos los componentes de gvNIX se han instalado correctamente 
en la distribución de Spring Roo ejecutando el siguiente comando:
+
----------------
roo> addon list
----------------

10. Si todo ha salido bien, al final del listado que aparecerá en la consola, podrás ver
todos los componentes de gvNIX instalados y activados del siguiente modo:
+
------------------------------------------------------------------------------------------
   86|Active     |    1|gvNIX - Annotations - GEO Support (2.0.0.M1)
   87|Active     |    1|gvNIX - Addon - Dynamic Configuration (2.0.0.M1)
   88|Active     |    1|gvNIX - Addon - Loupe Fields (2.0.0.M1)
   89|Active     |    1|gvNIX - Addon - Web MVC (JSP) layer services (2.0.0.M1)
   90|Active     |    1|gvNIX - Annotations - Web Datatables Addon (2.0.0.M1)
   91|Active     |    1|gvNIX - Addon - JPA layer services (2.0.0.M1)
   92|Active     |    1|gvNIX - Addon - Web Datatables Addon (2.0.0.M1)
   93|Active     |    1|gvNIX - Annotations - Web MVC (JSP) layer services (2.0.0.M1)
   94|Active     |    1|gvNIX - Addon - Services Management (2.0.0.M1)
   95|Active     |    1|gvNIX - Annotations - Web Report (2.0.0.M1)
   96|Active     |    1|gvNIX - Addon - Co-official languages of Spain (2.0.0.M1)
   97|Active     |    1|gvNIX - Annotations - Optimistic Concurrency Control (2.0.0.M1)
   98|Active     |    1|gvNIX - Addon - Web MVC Dialogs (2.0.0.M1)
   99|Active     |    1|gvNIX - Annotations - Services Management (2.0.0.M1)
  100|Active     |    1|gvNIX - Addon - Monitoring Support (2.0.0.M1)
  101|Active     |    1|gvNIX - Addon - Bootstrap3 support (2.0.0.M1)
  102|Active     |    1|gvNIX - Annotations - Web MVC Dialogs (2.0.0.M1)
  103|Active     |    1|gvNIX - Addon - GEO Support (2.0.0.M1)
  104|Active     |    1|gvNIX - Addon - Optimistic Concurrency Control (2.0.0.M1)
  105|Active     |    1|gvNIX - Support Module (2.0.0.M1)
  106|Active     |    1|gvNIX - Annotations - Loupe Fields (2.0.0.M1)
  107|Active     |    1|gvNIX - Annotations - JPA layer services (2.0.0.M1)
  108|Active     |    1|gvNIX - Addon - Web Report (2.0.0.M1)
  109|Active     |    1|gvNIX - Annotations - Web MVC Bindings (2.0.0.M1)
  110|Active     |    1|gvNIX - Addon - Typical Security (2.0.0.M1)
  111|Active     |    1|gvNIX - Addon - Web MVC Menu (2.0.0.M1)
  112|Active     |    1|gvNIX - Addon - Web MVC Bindings (2.0.0.M1)
------------------------------------------------------------------------------------------

Una vez hecho esto, ya se puede trabajar con el entorno gvNIX desde la
línea de comandos. Sin embargo, se recomienda utilizar un IDE de
desarrollo que permita integrar el entorno gvNIX como, por ejemplo STS o
Eclipse.

:numbered:
= I. Introducción

== Introducción

=== ¿Qué es gvNIX?

gvNIX es un entorno de trabajo Java de código abierto para el desarrollo
rápido de aplicaciones web sobre tecnología Spring. Sus funcionalidades hacen que sea 
un entorno altamente productivo, flexible y que no compromete la calidad de los proyectos.

Está compuesto por una serie de herramientas de código abierto distribuídas 
en forma de http://docs.spring.io/spring-roo/docs/2.0.0.M1/reference/html/#available-roo-addon-suites["Spring Roo Add-On Suite"]
a través de un repositorio OSGi R5.
Esto le proporciona un amplio apoyo por parte de importantes
organizaciones como http://spring.io/[Spring] y http://pivotal.io/[Pivotal]. 
Añade funcionalidades de alto nivel a las prestaciones que ya se obtienen con
http://projects.spring.io/spring-roo/[Spring Roo] para mejorar la
productividad.

gvNIX está patrocinado por la Dirección General de Tecnologías de la Información
(DGTI) de la Conselleria de Hacienda y Administración Pública de la
Generalitat Valenciana (Comunidad Valenciana, España), gestionado por la
Asociación gvSIG y dirigido por DISID.

gvNIX está disponible dentro del proyecto de Migración a Software de
fuentes abiertas http://www.gvpontis.gva.es[gvPONTIS].

* http://www.gvnix.org[Página del proyecto gvNIX]
* http://www.gvpontis.gva.es/cast/gvnix/[Página de gvNIX dentro del
proyecto gvPONTIS]
* http://projects.spring.io/spring-roo/[Página oficial de Spring Roo]

=== ¿Qué es Spring Roo?

Spring Roo es un entorno de trabajo Java que permite el desarrollo de
aplicaciones web de forma rápida y cómoda para el desarrollador. Sus
principales características son:

* Generación de código en Java (lenguaje estático).
* Eliminar el trabajo tedioso centrando el desarrollo en la lógica de
negocio.
* Convención sobre configuración.
* Desarrollo dirigido por el dominio (Domain-Driven Development):
** Diseño dirigido por el modelo de entidades.
** Lógica en las entidades (Real Object Oriented), eliminando capas
redundantes.
** Otras capas opcionales (servicios, DAOs, ...).
* Crea un proyecto en segundos.
* Realimentación: añade valor durante todo el ciclo de vida.
* No incorpora elementos adicionales al entorno de ejecución, por lo que
no penaliza la velocidad ni la memoria de la aplicación.
* Recibe instrucciones a través de una consola interactiva con
autocompletado y ayuda en línea.
* Extensible usando _bundles OSGi_.
* Aprovecha el conocimiento: no necesita más conocimiento que el
necesario para el desarrollo de aplicaciones JEE.

=== ¿Qué es un "Roo Add-On Suite"?

Los "Roo Add-On Suites" son la mejor manera de empaquetar y distribuir conjuntos de Add-Ons para que
puedan ser instalados en distribuciones de Spring Roo de forma rápida y sencilla.

Están basados en subsistemas de OSGi R5, los cuales permiten instalar un conjunto de componentes sobre 
la distribución de Spring Roo sin comprometer su modularidad.

Por todo lo anterior, decimos que *gvNIX es un "Spring Roo Add-On Suite"* que puede ser instalado en
distribuciones de Spring Roo para ampliar sus funcionalidades básicas.

=== ¿Qué ofrece gvNIX?

gvNIX aprovecha las características de Spring Roo y aporta su propia
filosofía, ofrecer al desarrollador componentes de alto valor funcional
para aplicaciones corporativas:

* Control de concurrencia a nivel de aplicación sin campos en base de
datos.
* Utilidades de generación de consultas.
* Utilidades de modificaciones múltiples de entidades.
* Gestión de temas visuales utilizando jQuery, Bootstrap, HTML5 y CSS3. 
* Gestión de la visualización de excepciones.
* Gestión de mensajes de usuario en ventana modal.
* Gestión de la estructura de páginas en el menú.
* Gestión de patrones de visualización de entidades y sus relaciones utilizando
el componente Datatables.
* Gestión de transformación de cadenas vacías a valores nulos.
* Gestión de servicios locales y servicios web (importación y
exposición).
* Control de acceso (autenticación y autorización).
* Gestión de configuraciones por entorno.
* Generación de documentos (reportes).
* Gestión de relaciones utilizando componente Lupa.
* Gestión de información geográfica.
* Generación de GeoPortales interactivos.

== Empezando con gvNIX: Tutorial (I)

En este capítulo generaremos una aplicación sencilla paso a paso de forma rápida para que 
puedas ver y entender cómo se trabaja con la herramienta de desarrollo gvNIX en un proyecto básico.

Los detalles sobre la generación del código y la explicación de cada uno de los comandos ejecutados, se
mostrarán en las siguientes secciones de este manual. 

=== ¿Qué aprenderás?

En este tutorial aprenderás como crear una aplicación desde cero utilizando la herramienta de 
desarrollo gvNIX sobre el IDE STS 3.7+.

Las principales características de gvNIX que veremos en este tutorial son las siguientes:

* Creación de un proyecto
* Configurarción de persistencia
* Generación del modelo de entidades
* Generación de métodos de búsqueda
* Generación de capa web
* Componente Datatables y Bootstrap
* Patrones de Pantalla
* Ejecución de una aplicación en un servidor Tomcat
* Edición de datos en linea
* Componente Lupa
* Instalación y gestión de menú
* Aplicar seguridad a nuestra aplicación
* Generación de informes utilizando Jasper Reports
* Tests funcionales y Tests de integración
* Generación de servicios web.


=== Detalles de la aplicación

La aplicación que se va a generar está basada en la aplicación de ejemplo Petclinic de Spring. Los usuarios de esta aplicación son empleados
de una clínica veterinaria, que a lo largo de su jornada laboral, necesitan gestionar información sobre veterinarios, clientes y sus mascotas.

Después de esta pequeña introducción sobre la aplicación que se va a desarrollar, hemos generado un diagrama de clases simple 
para el modelo de entidades de esta aplicación:

image::petclinic-uml.png[Petclinic UML,align=center]  

Para sacar el máximo partido a las funcionalidades de gvNIX y Spring Roo, es recomendable que las aplicaciones se generen 
siguiendo la filosofía del https://es.wikipedia.org/wiki/Dise%C3%B1o_guiado_por_el_dominio[diseño guiado por el dominio].

[NOTE]
====
Hay que tener en cuenta que la aplicación que se va a generar no será una aplicación real, ya que normalmente necesitaría
una serie de trabajos adicionales para personalizar la capa web, implementar lógica de negocio, etc..
====

=== Paso 1: Crear un proyecto

A continuación, vamos a crear un nuevo proyecto desde STS. Para ello accede a *"New > Project... > Spring > Spring Roo Project"* 
como se muestra en la imagen:

image::eclipse_new_roo_project.png[Nuevo proyecto,align=center] 

Una vez seleccionado el tipo de proyecto que queremos generar, configura el proyecto:

image::eclipse_new_roo_project_2.png[Configuración del Proyecto,align=center]

*Nombre del Proyecto:* petclinic

*Top level package:* com.springsource.petclinic

Al clicar sobre Next y Finish se generará el nuevo proyecto y seguidamente se 
iniciará la consola de Spring Roo.

image::eclipse_roo_shell.png[Consola de gvNIX,align=center] 

*IMPORTANTE* Antes de continuar con el tutorial es necesario que valides que ĺa distribución de 
Spring Roo que estás utilizando tiene instalados los componentes de gvNIX.

Para ello, ejecuta el siguiente comando:

-----------------------
roo> addon suite list
-----------------------

Debe mostrarse el siguiente contenido:

------------------------------------------------------------------
roo> addon suite list 
Getting all 'Roo Addon Suites' installed on Spring Roo Shell... 
 
   org.osgi.service.subsystem.root
   org.gvnix.roo.addon.suite
 
2 Roo Addon Suites were found at your Spring Roo installation
roo>
------------------------------------------------------------------ 

En caso de que solo aparezca el Roo Add-On Suite por defecto "org.osgi.service.subsystem.root", significará
que no has instalado de forma correcta gvNIX. 

Sigue los pasos de la link:#instalar-gvnix[sección anterior] para instalar los componentes de gvNIX
sobre la distribución de Spring Roo antes de continuar con el tutorial.

=== Paso 2: Configurar persistencia

¿Ya aparecen los componentes de gvNIX instalados en tu distribución de Roo? Si no es así, sigue los pasos de la 
link:#instalar-gvnix[sección anterior] para instalar los componentes de gvNIX sobre la distribución de Spring Roo 
antes de continuar con el tutorial.

Vamos a configurar la persistencia de nuestro proyecto. En este caso vamos a utilizar HIBERNATE como ORM y el tipo
 de base de datos HYPERSONIC_PERSISTENT.
 
Para ello, ejecutamos el siguiente comando sobre la consola de gvNIX en STS:

----------------------------------------------------------------------
roo> jpa setup --provider HIBERNATE --database HYPERSONIC_PERSISTENT
----------------------------------------------------------------------

=== Paso 3: Generar modelo de entidades

Siguiendo el modelo de entidades link:#detalles-de-la-aplicación[propuesto anteriormente], ejecutaremos los siguientes comandos
para generar nuestro dominio:

Crea todas las entidades de nuestra aplicación ejecutando los siguientes comandos:

--------------------------------------------------------------------------
 entity jpa --class ~.domain.Pet --sequenceName PET_SEQ
 entity jpa --class ~.domain.Visit --sequenceName VISIT_SEQ
 entity jpa --class ~.domain.AbstractPerson --abstract
 entity jpa --class ~.domain.Vet --extends ~.domain.AbstractPerson
 entity jpa --class ~.domain.Owner --extends ~.domain.AbstractPerson
--------------------------------------------------------------------------

Crea los enumerados *PetType* y *Speciality* ejecutando los siguientes comandos:

--------------------------------------------------------------------------
 enum type --class ~.reference.PetType
 enum constant --name Dog
 enum constant --name Cat
 enum constant --name Bird
 enum type --class ~.reference.Specialty
 enum constant --name Cardiology
 enum constant --name Dentistry
 enum constant --name Nutrition
--------------------------------------------------------------------------

Añade todos los campos a las entidades ejecutando los siguientes comandos:

--------------------------------------------------------------------------------------------------------------------------------------
 field string --fieldName firstName --sizeMin 3 --sizeMax 30 --class ~.domain.AbstractPerson
 field string --fieldName lastName --notNull --sizeMin 3 --sizeMax 30
 field string --fieldName address --notNull --sizeMax 50 --sizeMin 1
 field string --fieldName city --notNull --sizeMax 30
 field string --fieldName telephone --notNull
 field string --fieldName homePage --sizeMax 30
 field string --fieldName email --sizeMax 30 --sizeMin 6
 field date --fieldName birthDay --type java.util.Date --notNull
 field string --fieldName description --sizeMax 255 --class ~.domain.Visit
 field date --fieldName visitDate --type java.util.Date --notNull --past
 field reference --fieldName pet --type ~.domain.Pet --notNull
 field reference --fieldName vet --type ~.domain.Vet
 field boolean --fieldName sendReminders --notNull --primitive --class ~.domain.Pet
 field string --fieldName name --notNull --sizeMin 1
 field number --fieldName weight --type java.lang.Float --notNull --min 0
 field reference --fieldName owner --type ~.domain.Owner
 field enum --fieldName type --type ~.reference.PetType --notNull
 field date --fieldName employedSince --type java.util.Calendar --notNull --past --class ~.domain.Vet
 field enum --fieldName specialty --type ~.reference.Specialty --notNull false
 field set --class ~.domain.Owner --fieldName pets --type ~.domain.Pet --mappedBy owner --notNull false --cardinality ONE_TO_MANY
 field set --class ~.domain.Vet --fieldName visits --type ~.domain.Visit --mappedBy vet --notNull false --cardinality ONE_TO_MANY
 field reference --fieldName owner --type ~.domain.Owner --class ~.domain.Vet
 field set --fieldName vets --type ~.domain.Vet --class ~.domain.Owner --cardinality ONE_TO_MANY --mappedBy owner
 field set --fieldName visits --type ~.domain.Visit --class ~.domain.Pet --cardinality ONE_TO_MANY --mappedBy pet
--------------------------------------------------------------------------------------------------------------------------------------

=== Paso 4: Métodos de búsqueda

Para ser capaces de filtrar los registros guardados en nuestra base de datos, es necesario que nuestras entidades dispongan
de unos métodos de búsqueda.

Para instalarlos, ejecutaremos los siguientes comandos:

--------------------------------------------------------------------------------------
finder add --finderName findPetsByNameAndWeight --class ~.domain.Pet
finder add --finderName findPetsByOwner
finder add --finderName findPetsBySendRemindersAndWeightLessThan
finder add --finderName findPetsByTypeAndNameLike
finder add --finderName findVisitsByDescriptionAndVisitDate --class ~.domain.Visit
finder add --finderName findVisitsByVisitDateBetween
finder add --finderName findVisitsByDescriptionLike
--------------------------------------------------------------------------------------

=== Paso 5: Capa web

En este momento ya disponemos de nuestro modelo de entidades generado. Ahora, es necesario que generemos la capa web 
de nuestra aplicación para que los usuarios puedan acceder a ella a través de un navegador.

En primer lugar instalamos todos los componentes web de nuestra aplicación como imágenes, estilos css, tagx, etc... utilizando
el siguiente comando:

-------------
web mvc setup
-------------

A continuación, generamos la capa web de todas las entidades de nuestro proyecto ejecutando el siguiente comando:

----------------------------
web mvc all --package ~.web
----------------------------

Para generar las vistas de los métodos de búsqueda añadidos link:#paso-4-métodos-de-búsqueda[anteriormente] y que el usuario
pueda realizar búsquedas de forma visual, ejecutaremos el siguiente comando:

-------------------
web mvc finder all
-------------------

Si necesitas instalar varios idiomas en tu aplicación, puedes ejecutar los siguientes comandos:

---------------------------
web mvc language --code es
web mvc language --code de
---------------------------

=== Paso 6: Instalar JQuery, Datatables y Bootstrap

A continuación, incluiremos la librería https://jquery.com/[JQuery] en nuestro proyecto generado.
Además, incluiremos el componente http://datatables.net/[Datatables] que utilizaremos en las vistas de listado y finalmente,
transformaremos la apariencia de nuestra aplicación para que se muestre con estilo http://getbootstrap.com/[Bootstrap].

Para instalar jQuery en nuestro proyecto, ejecutamos el siguiente comando:

--------------------
web mvc jquery setup
--------------------

Para que todas nuestras vistas utilicen componentes jQuery, utilizaremos el siguiente comando:

--------------------
web mvc jquery all
--------------------

Seguimos con el tutorial instalando el componente Datatables en nuestro proyecto con el siguiente comando:

-------------------------
web mvc datatables setup
-------------------------

[NOTE]
====
De momento solo instalamos los componentes Datatables, pero nuestras vistas de listado no lo están utilizando.
====

Para finalizar este punto, transformamos la apariencia de nuestra aplicación a Bootstrap con el siguiente comando:

-------------------------
web mvc bootstrap setup
-------------------------

=== Paso 7: Edición en linea y Selección Múltiple

Entre las múltiples funcionalidades que ofrece el componente Datatables, el cual hemos incluido en el 
link:#paso-6-instalar-jquery-datatables-y-bootstrap[paso anterior], encontramos la edición en linea y la selección múltiple.

La funcionalidad de edición en linea permite a los usuarios crear y editar registros directamente desde el componente Datatable
sin abandonar el listado. 

La funcionalidad de selección múltiple permite seleccionar varios registros mostrados en el componente Datatables para así, aplicar
acciones sobre ellos, como puede ser editar o eliminar. 

Para que los Datatables que utilicemos en nuestra aplicación sean capaces de incluir estas funcionalidades
, ejecutaremos los siguientes comandos:

--------------------
jpa gvnix setup
jpa batch all
web mvc batch setup
web mvc batch all
--------------------


=== Paso 8: Patrones de Pantalla

En este punto, vamos a definir una serie de patrones de pantalla "maestro > detalle" utilizando el componente Datatables añadido en el  
link:#paso-6-instalar-jquery-datatables-y-bootstrap[paso anterior].

==== Creación de Maestros

A continuación creamos todas las vistas maestras de nuestra aplicación:

--------------------------------------------------------------------------------
web mvc datatables add --type ~.web.VetController --mode show
web mvc datatables add --type ~.web.PetController
web mvc datatables add --type ~.web.OwnerController
web mvc datatables add --type ~.web.VisitController --inline true --ajax true
--------------------------------------------------------------------------------

[NOTE]
====
Utiliza el parámetro *--mode* con valor show para mostrar un único registro por página. Utiliza el parámetro *--inlineEditing* para habilitar
la edición en linea.
====

==== Creación de Detalles

Después de crear los maestros, continuamos generando los detalles.

Para generar el patrón de pantalla "Maestro Owners > Detalle Pets" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.OwnerController --property pets
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Vets" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.OwnerController --property vets
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Pet > Detalle Visit" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.PetController --property visits
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Vet > Detalle Visit" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.VetController --property visits
--------------------------------------------------------------------------

[NOTE]
====
El ejemplo anterior muestra un patrón de pantalla de tres niveles. (Maestro, detalle y detalle de detalle)
====

=== Paso 9: Primera ejecución

En este momento vamos a ejecutar nuestra aplicación en un servidor Tomcat.

En primer lugar, es necesario añadir el servidor Tomcat a nuestro IDE STS. Para ello, seguiremos los siguientes pasos:

* En la pestaña "Servers" añadiremos un nuevo servidor utilizando "New... > Server".
* Aparecerá una ventana como la siguiente, donde seleccionaremos el servidor "Apache Tomcat v6.0":

image::eclipse_servers_new.png[Nuevo Servidor,align=center]

* Seleccionamos el directorio donde tengamos descargado nuestro apache-tomcat. Si no lo tienes descargado, puedes hacer
click sobre el botón "Download and Install" y se descargará de forma automática:

image::eclipse_servers_configure.png[Configurar servidor,align=center]

* A continuación, añadimos nuestra aplicación generada al servidor Tomcat:

image::eclipse_servers-addremoveapp.png[Nueva app,align:center]

Ahora que ya tenemos un servidor Tomcat configurado y nuestra aplicación añadida, podemos arrancar el servidor Tomcat utilizando
el botón de "Play" con el servidor Tomcat seleccionado:

image::eclipse_servers-buttons.png[Botones Servers,align=center]

Otra forma de arrancar nuestro proyecto es hacer click derecho sobre el proyecto en
STS y seleccionando la opción "Run as... > Run On Server", seleccionamos el servidor sobre el cual
queremos ejecutar nuestro proyecto y presionamos "Finish" para iniciar la ejecución.

image::eclipse_run-on-server.png[Ejecutar aplicación en servidor,align=center]

Una vez haya arrancado, podemos acceder a la URL http://localhost:8080/petclinic/ desde nuestro navegador para 
visualizar la aplicación generada.

image::sample-application-0.png[Estado de la aplicación,align=center]

=== Paso 10: Componente Lupa

El componente lupa provee funcionalidades para buscar datos relacionados de forma rápida y sencilla utilizando AJAX.

Para instalar el componente lupa en nuestra aplicación generada, es necesario ejecutar el siguiente comando:

--------------------
web mvc loupe setup
--------------------

A continuación, añadimos una serie de funcionalidades necesarias para el correcto funcionamiento del componente
en la capa controladora:

------------------------------------------------------
web mvc loupe set --controller ~.web.VisitController
------------------------------------------------------

Finalmente, convertimos los elementos "combobox" a componentes lupa utilizando los siguientes comandos:

---------------------------------------------------------------------------------------------------------------------------
web mvc loupe field --controller ~.web.VisitController --field pet --caption name --additionalFields name,weight --max 5
web mvc loupe field --controller ~.web.VisitController --field vet
---------------------------------------------------------------------------------------------------------------------------

=== Paso 11: Instalación del Menú

gvNIX provee un menú mucho más personalizable que el definido inicialmente por Spring Roo. Por ello, se aconseja 
que todas las aplicaciones incorporen el menú de gvNIX utilizando este sencillo comando:

-----------
menu setup
-----------

=== Paso 12: Aplicar Seguridad

Aplicar seguridad a un proyecto es muy sencillo con gvNIX. Utilizando el siguiente comando, se añade seguridad a nuestro proyecto
generado utilizando http://projects.spring.io/spring-security/[Spring Security].

--------------
security setup
--------------

=== Paso 13: Gestión de Informes

A continuación, incluiremos las funcionalidades necesarias para generar un informe sobre los "Owners" 
que tenemos registrados en nuestro sistema petclinic. Para ello, ejecutamos los siguientes comandos:

--------------------------------------------------------------------------------
web report setup
web report add --controller ~.web.OwnerController --reportName report_owners
--------------------------------------------------------------------------------

=== Paso 14: Control de concurrencia

Configuraremos el control de concurrencia sobre la entidad "Pet" de nuestro proyecto, para así evitar que se pierdan
los datos guardados cuando varios usuarios editan un mismo registro.

Para ello, basta con ejecutar el siguiente comando:

-----------------------------------------
occ checksum set --entity ~.domain.Pet
-----------------------------------------

=== Paso 15: Tests funcionales y tests de integración

En este momento, vamos a añadir una serie de tests funcionales y tests de integración a nuestra aplicación generada. Para los
tests funcionales utilizaremos http://www.seleniumhq.org/[Selenium] y para los tests de integración utilizaremos http://junit.org/[JUnit].

Añadimos los tests funcionales a todas las vistas de nuestro proyecto utilizando los siguientes comandos:

--------------------------------------------------
selenium test --controller ~.web.OwnerController
selenium test --controller ~.web.PetController
selenium test --controller ~.web.VetController
selenium test --controller ~.web.VisitController
--------------------------------------------------

Añadimos los tests de integración a cada una de las entidades de nuestro proyecto utilizando los siguientes comandos:

-----------------------------------------
test integration --entity ~.domain.Vet
test integration --entity ~.domain.Owner
test integration --entity ~.domain.Pet
test integration --entity ~.domain.Visit
-----------------------------------------

=== Paso 16: Servicios web

Para acabar con esta guía rápida sobre las funcionalidades disponibles en la herramienta de desarrollo gvNIX, serviremos 
varios servicios web desde nuestra aplicación generada.

Para ello, ejecutamos los siguientes comandos:

----------------------------------------------------------------------------------------
remote service define ws --class ~.services.PetsServices --serviceName ws_get_all_pets
remote service operation --name ws_list_pets --service ~.services.PetsServices
----------------------------------------------------------------------------------------

[NOTE]
====
Estos servicios estarán disponibles en http://localhost:8080/petclinic/services y podrán ser consumidos
por aplicaciones externas.
====

=== Resultado

Después de seguir este rápido tutorial donde se muestran algunas de las funcionalidades que ofrece la herramienta gvNIX,
tendremos una aplicación adaptativa (responsive UI) que podrá ser visualizada en cualquier dispositivo ya sea ordenadores,
tablets o incluso móviles. La aplicación adaptativa generada tendrá el siguiente aspecto:

image::sample-application-login.png[Login,align=center]
image::sample-application-pet-creation.png[Alta de una mascota,align=center]
image::sample-application-pet-list.png[Listado de mascotas,align=center]
image::sample-application-visit-inline.png[Edición en linea,align=center]


Ahora que ya conoces las funcionalidades básicas de gvNIX, te recomendamos que continues leyendo este manual. 
Algunas secciones que pueden interesarte son:

* link:#gvnix-avanzado-componentes-geo-tutorial-ii[gvNIX Avanzado - Componentes GEO: Tutorial (II)]
* link:#gvnix-addons[Listado de Add-Ons disponibles en gvNIX]


== gvNIX avanzado: Componentes GEO (Tutorial II)

En este capítulo actualizaremos la aplicación generada en la link:#empezando-con-gvnix-tutorial-i[primera parte] de este tutorial 
incluyendo componentes de tipo geográfico.

Los detalles sobre la generación del código y la explicación de cada uno de los comandos ejecutados, se
mostrarán en las siguientes secciones de este manual. 

=== ¿Qué aprenderás?

En esta segunda parte del tutorial, aprenderás a incluir componentes de tipo GEO en tus aplicaciones generadas
utilizando la herramienta de desarrollo de gvNIX.

Las principales características de gvNIX que veremos en este tutorial son las siguientes:

* Configurar persistencia con BBDD que aceptan campos de tipo GEO.
* Incluir soporte espacial utilizando http://www.hibernatespatial.org/[Hibernate Spatial].
* Añadir campos de tipo GEO en entidades generadas.
* Generar buscadores sobre campos de tipo GEO.
* Añadir mapas en las vistas de creación, actualización y visualización.
* Generar geoportales para representar y gestionar los datos de la aplicación.
* Añadir entidades al geoportal generado
* Añadir capas base WMS y TileLayers al geoportal generado.
* Añadir herramientas al geoportal generado.
* Filtrar datos representados en el geoportal utilizando el componente Datatables
* Seleccionar datos representados en el geoportal utilizando el componente Datatables
* Agrupar elementos dependiendo del nivel de zoom.

=== Paso 1: Configurar persistencia GEO

Lo primero que debemos saber es que no todas las bases de datos tienen soporte para tipos de datos 
geográficos, consultas geoespaciales, etc.

Por este motivo, antes de incluir componentes geográficos en nuestra aplicación, es necesario 
configurar una base de datos válida.

gvNIX nos ayudará en esta tarea y nos propone sólo bases de datos compatibles con campos de tipo GEO. 
Actualmente gvNIX soporta las siguientes bases de datos con soporte geo:

* http://www.postgresql.org/[PostgreSql]
* https://www.oracle.com/database/index.html[Oracle 10g/11g]
* http://www.mysql.com/[MySQL]
* http://www.microsoft.com/es-es/server-cloud/products/sql-server/[SqlServer]


En nuestro caso, utilizaremos una base de datos de tipo POSTGRES. Para ello, es necesario que configures una BBDD de tipo 
http://www.postgresql.org/[POSTGRES] en tu equipo y añadas soporte geográfico incluyendo http://trac.osgeo.org/postgis/[POSTGIS]. 

Para realizar la configuración anterior puedes seguir los siguientes pasos:

* Instala http://www.postgresql.org/[PostgreSql] y http://trac.osgeo.org/postgis/[Postgis].
* De manera opcional, puedes instalar http://www.pgadmin.org/[pgadmin] para gestionar tus bases de datos Postgres de forma visual.  
* Crea una nueva base de datos.
* Añade la extensión *postgis* y *postgis_topology* en la base de datos generada, tal y como se muestra en la siguiente imágen:

image::postgis_db.png[Extensiones Postgis,align=true]

Para más información sobre como configurar Postgis consulta su guía de referencia http://postgis.net/documentation/[aquí].

Ahora que disponemos de una base de datos válida configurada en nuestro equipo, actualizaremos nuestro proyecto generado 
para utilizar una base de datos de tipo POSTGRES ejecutando el siguiente comando:

-------------------------------------------------------------------------------------------------------------------------------------------
jpa setup --provider HIBERNATE --database POSTGRES --userName USERNAME --databaseName DATABASENAME --password PASSWORD --hostName HOSTNAME
-------------------------------------------------------------------------------------------------------------------------------------------

=== Paso 2: Añadir soporte GEO al proyecto

En este momento, tu base de datos está configurada para link:#paso-1-configurar-persistencia-geo[soportar campos de tipo GEO] 
y dispone de una serie de funcionalidades para gestionar información geográfica.  Sin embargo, tu proyecto no acepta estos componentes de momento.

Para añadir soporte espacial en el proyecto generado necesitamos actualizar el mismo para que utilice http://www.hibernatespatial.org/[Hibernate Spatial].

Ejecutando el siguiente comando, nuestro proyecto dispondrá de soporte espacial:

------------------------------------------
jpa geo setup --provider HIBERNATE_SPATIAL
------------------------------------------

[NOTE]
====
En caso de ejecutar el comando anterior sobre una base de datos no válida aparecerá el siguiente mensaje indicándonos qué
tipos de base de datos aceptan información geográfica:

----------------------------------------------------------------------------------------------------------------------------------------
There's not any valid database to apply GEO persistence support. GEO is only supported for POSTGRES, ORACLE, MYSQL and MSSQL databases. 
You must change it following the next instructions:

Replace your current dialect with the correct one: 
org.hibernate.dialect.H2Dialect ==> org.hibernate.spatial.dialect.h2geodb.GeoDBDialect
org.hibernate.dialect.PostgreSQLDialect ==> org.hibernate.spatial.dialect.postgis.PostgisDialect
org.hibernate.dialect.MySQLDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialDialect
org.hibernate.dialect.MySQL5Dialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialDialect
org.hibernate.dialect.MySQLInnoDBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialInnoDBDialect
org.hibernate.dialect.MySQL5InnoDBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialInnoDBDialect
org.hibernate.dialect.MySQL5DBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatial56Dialect
org.hibernate.dialect.MySQLSpatial56Dialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatial5InnoDBDialect
org.hibernate.dialect.Oracle10gDialect ==> org.hibernate.spatial.dialect.oracle.OracleSpatial10gDialect
org.hibernate.dialect.OracleDialect ==> org.hibernate.spatial.dialect.oracle.OracleSpatial10gDialect
org.hibernate.dialect.SQLServerDialect ==> org.hibernate.spatial.dialect.SQLServer2008Dialect
----------------------------------------------------------------------------------------------------------------------------------------
====


=== Paso 3: Añadir campos GEO a entidades

Ahora que ya disponemos de soporte espacial en nuestra aplicación, procedemos a añadir campos de tipo GEO en las entidades generadas
en la link:#paso-3-generar-modelo-de-entidades[primera parte de este tutorial].

Es funcionalidad permite añadir varios tipos de campos GEO como los siguientes:

* POLYGON
* POINT
* LINESTRING
* MULTILINESTRING
* GEOMETRY

En este caso añadiremos los campos *localización*, *distancia* y *area* sobre la entidad *Owner*. Para ello, ejecutamos los siguientes
comandos:

-----------------------------------------------------------------------
field geo --fieldName location --type POINT --class ~.domain.Owner
field geo --fieldName distance --type LINESTRING --class ~.domain.Owner
field geo --fieldName area --type POLYGON --class ~.domain.Owner 
-----------------------------------------------------------------------

[NOTE]
====
Los comandos para añadir campos de tipo GEO solo estarán disponibles una vez añadido el soporte espacial en nuestra apliación.
====

=== Paso 4: Generar buscadores GEO

Para ser capaces de posicionar los distintos registros de las entidades sobre una vista de mapa, necesitamos generar una serie de
buscadores devuelvan la información geográfica de uno o varios registros.

Para añadir estos métodos de búsqueda a nuestra aplicación generada, utilizaremos el siguiente comando:

--------------
finder geo all
--------------

=== Paso 5: Generar mapas en CRU

En este punto del tutorial, deberías disponer de una link:#paso-1-configurar-persistencia-geo[Base de datos con soporte GEO], 
link:#paso-2-añadir-soporte-geo-al-proyecto[soporte espacial] configurado en el proyecto,
varios link:#paso-3-añadir-campos-geo-a-entidades[campos de tipo GEO] añadidos en las entidades generadas 
y varios link:#paso-4-generar-buscadores-geo[métodos de búsqueda] de tipo GEO.

En caso afirmativo, continuaremos con la generación de campos de tipo mapa en las vistas de creación, actualización y visualización
de nuestras entidades.

Gracias a estos campos visuales seremos capaces de gestionar de manera cómoda la información geográfica almacenada en la entidad.

Para añadir estos campos sobre una entidad, ejecutaremos los siguientes comandos:

----------------------------------------------------------------------
web mvc geo field --controller ~.web.OwnerController --field location
web mvc geo field --controller ~.web.OwnerController --field distance
web mvc geo field --controller ~.web.OwnerController --field area 
----------------------------------------------------------------------

Después de ejecutar los comandos anteriores, las vistas de creación, actualización y visualización de tus entidades con campos
GEO tendrán el siguiente aspecto:

image::CRU_map.png[Mapa vista CRU,align=center]

[NOTE]
====
Estos componentes visuales no son obligatorios para gestionar la información geográfica de una entidad. En caso de no añadirlos,
se podrá gestionar la información geográfica mediante entrada de texto en formato https://en.wikipedia.org/wiki/Well-known_text[WKT].
====

=== Paso 6: Generar Geoportal

En este momento puedes añadir todos los geoportales que quieras en tu proyecto. Para ello, ejecuta los siguientes comandos:

-----------------------------------------------------------------------------------------------------------
web mvc geo controller --class ~.web.MapViewerController --preferredMapping mapview --projection EPSG4326
web mvc geo controller --class ~.web.MapController --preferredMapping map 
-----------------------------------------------------------------------------------------------------------

Los comandos anteriores generan distintos geoportales en nuestra aplicación y una entrada de menú distinta para cada uno de ellos.
El primer Geoportal está configurado para utilizar la proyección *EPSG4326*. En el segundo caso no se ha especificado la proyección
a utilizar, por lo que se utilizará la proyección por defecto *EPSG3857*.

image::menu_geoportal.png[Menu GEO,align=true]
image::simple_map.png[Geoportal,align=center]

[NOTE]
====
Si necesitas configurar opciones como nivel de Zoom inicial, punto central inicial, capas base, etc.. tendrás que editar de forma
manual las opciones de la vista *views/{mappath}/show.jspx*.
====

=== Paso 7: Añadir entidades al Geoportal

En el link:#paso-6-generar-geoportal[punto anterior] hemos generado varios geoportales vacios, es decir, sin ninguna información representada
sobre los mismos.

En este punto, aprenderemos cómo añadir entidades a los geoportales generados para así representar la información geográfica almacenada
en las mismas.

Ejecutamos el siguiente comando para añadir todas las entidades que dispongan de campos de tipo GEO en todos los geoportales generados:

------------------------
web mvc geo entity all 
------------------------

[NOTE]
====
Si no quieres que la entidad se añada a todos los geoportales generados, utiliza el parámetro *--map* en el comando anterior indicando
en qué mapa quieres incluir la entidad.
====

Si has seguido los pasos anteriores, tu aplicación tendrá el siguiente aspecto:

image::map_entities.png[Entidades en mapa,align=center]
image::map_entity_0.png[Entidad representada en el mapa,align=center]
image::map_entities_1.png[Todos los campos representados,align=center]

=== Paso 8: Añadir capas base al Geoportal

La herramienta gvNIX también nos permite añadir una serie de capas base en nuestro geoportal generado.

Existe más de un tipo de capas base. En este momento, gvNIX permite añadir dos tipos de capas base:

* http://wiki.openstreetmap.org/wiki/Tiles[Tile Layers]
* http://wiki.openstreetmap.org/wiki/WMS[WMS Layers]

A continuación añadiremos una capa de tipo Tile en nuestros geoportales generados, en concreto, añadiremos una capa base de satélite del
proveedor de mapas https://www.here.com/[OVI]. Para ello, ejecutamos el siguiente comando:

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
web mvc geo tilelayer --name satellit --url "http://maptile.maps.svc.ovi.com/maptiler/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8" --index 1 --opacity 0.5
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Además, también añadiremos una capa base de tipo WMS en nuestros geoportales generados, en concreto, añadiremos una capa base con información
geológica de la provincia de Valencia (España) servida por el http://www.igme.es/actividadesIGME/lineas/cartoGeo.htm[IGME]. Para ello,
ejecutamos el siguiente comando:

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
web mvc geo wmslayer --name "geological map of valencia" --url "http://mapas.igme.es/gis/services/Cartografia_Geologica/IGME_GeologicoCValenciana_400/MapServer/WMSServer" --format "image/png" --transparent true --version "1.1.1" --crs EPSG4326 --layers "0,1,2,3"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[NOTE]
====
Al añadir una capa de tipo WMS, es necesario tener en cuenta la proyección en la que se encuentra y en la que está configurada el mapa, ya que
en caso de no coincidir, podría verse desplazada en el mapa o representada de forma incorrecta.
====

[NOTE]
====
Los comandos anteriores añaden las capas base sobre todos los geoportales generados. Para especificar sobre qué geoportal añadir las capas base
es necesario incluir el parámetro *--map*.
====

=== Paso 9: Añadir herramientas al Geoportal

Por defecto, al generar un geoportal utilizando la herramienta de desarrollo gvNIX, podrás ver que aparece una barra de herramientas
en la esquina inferior derecha. En esta barra de herramientas solo aparece una herramienta de tipo "desplazar", representada con el icono
de una mano.

Gracias a esta herramienta, podemos desplazarnos por el mapa generado. Sin embargo, existen varias herramientas más que gvNIX permite
añadir en los geoportales generados:

==== Herramienta de medición

Esta herramienta permite medir distancias entre varios puntos dentro del mapa. 

Para añadir esta herramienta en todas las vistas del mapa, ejecutaremos el siguiente comando:

---------------------------------------
web mvc geo tool measure --name measure
---------------------------------------

==== Herramienta personalizable

Debido a la gran variedad de herramientas que podían existir en un componente mapa, gvNIX provee una herramienta 
personalizable, en la que el desarrollador implementa su funcionalidad, así como el icono que mostrará.

Para incluir esta herramienta personalizable en el geoportal generado, ejecutaremos el siguiete comando:

----------------------------------------------------------------------------------------------------------------------------------------------------------------
web mvc geo tool custom --name latlng --icon fa-location-arrow --activateFunction activateLatLngTool --deactivateFunction deactivateLatLngTool --iconLibrary fa
----------------------------------------------------------------------------------------------------------------------------------------------------------------

Al añadir esta herramienta utilizando el comando anterior, indicamos las funciones javascript que utilizará al 
activar y desactivar la herramienta.

Así, el desarrollador deberá personalizar estas funciones javascript para añadir la funcionalidad deseada a la herramienta, tal y como
se muestra a continuación:

------------------------------------------------------
function activateLatLngTool(element, instance, map){
 map.on("click", function(e){
 alert(e.latlng);
 });
}
function deactivateLatLngTool(element, instance, map){
 map.off("click");
}
------------------------------------------------------

Al finalizar los pasos anteriores, aparecerán los siguientes elementos en nuestra barra de herramientas del geoportal:

image::toolbar_geo.png[Toolbar,align=true]

[NOTE]
====
Los comandos anteriores añaden las herramientas sobre todos los geoportales generados. Para especificar sobre qué geoportal añadir 
las herramientas es necesario incluir el parámetro *--map*.
====

=== Paso 10: Funcionalidades avanzadas

En este momento, ya dispones de una aplicación completa con componentes GEO generada utilizando la herramienta de desarrollo
gvNIX! Pero.. ¿Qué me ofrece esta aplicación GEO?

En este capitulo te dejamos una serie de funcionalidades avanzadas que pueden interesarte. 

==== Filtrar Datos utilizando Datatables

Por defecto, todas las entidades que añades a los geoportales generados pueden ser filtradas. Sabemos que una capa de entidad
se puede filtrar si aparece el siguiente icono en el panel de capas (https://en.wikipedia.org/wiki/Table_of_contents[TOC])

image::filter_icon.png[Icono de filtro,align=true]

Para realizar el filtrado de datos se utiliza el componente Datatables, el cual actualiza la vista de mapa aplicando los mismos filtros 
que al listado, tal y como se ve en el siguiente ejemplo:

En este geoportal, visualizamos todos los registros de la entidad Owner:

image::filter_0.png[Filtrado de capas,align=center]

A continuación, filtramos el Datatable para que solo aparezca un propietario en el listado. Como vemos en la imágen, el filtro se aplica 
al Datatable y el mapa se refresca de forma automática:

image::filter_1.png[Aplicado el filtro,align=center]

[NOTE]
====
Para modificar el tipo de filtrado de una entidad representada en los geoportales, modifica el atributo *filterType* de la vista 
_src/main/webapp/WEB-INF/views/{mappath}/show.jspx_. Si especificas el valor _auto_ en dicha propiedad, al filtrar los datos utilizando
el componente Datatable, el mapa se actualizará de forma automática. Si por el contrario, estableces la propiedad a _manual_ habrá que actualizar
los datos refrescando la página de forma manual. Si estableces la propiedad a _none_, desactivarás la funcionalidad de filtrado para dicha 
capa de entidad.
====

==== Selección de Datos utilizando Datatables

Otra funcionalidad interesante es la selección de registros utilizando el componente Datatables. Al igual que en el filtrado, se seleccionarán
aquellos registros que estén seleccionados en el listado Datatables, tal y como se muestra en la siguiente imágen:

image::selection_map.png[Seleccion en mapa,align=true]

Esta funcionalidad es compatible con el filtrado, por lo que se puede filtrar el componente Datatables y seleccionar un registro al mismo tiempo.

[NOTE]
====
Por defecto, el elemento seleccionado se mostrará en color azul. Puedes modificar el estilo de la selección editando el atributo 
_selection_ de la capa de entidad.
====

==== Agrupación de elementos en Geoportal

Otra funcionalidad que ofrecen los geoportales generados utilizando la herramienta de desarrollo gvNIX, es la agrupación de componentes
dependiendo del nivel de zoom.

Si se representan varios elementos en un espacio muy reducido, cuando el usuario haga zoom para alejar la vista, estos elementos se agruparán
evitando asi problemas de rendimiento tal y como se ve en la siguiente imágen:

image::grouped_markers.png[Agrupación,align=center]

Si hacemos click sobre uno de los grupos, el mapa se desplazará hasta el nivel mínimo de Zoom en el que se pueden representar los elementos.

:numbered:
= II. gvNIX Add-Ons

== Add-on Web Menu
include::addon-web-menu.adoc[]

== Add-on JPA
include::addon-jpa.adoc[]

== Add-on Monitoring
include::addon-monitoring.adoc[]

== Add-on Web MVC
include::addon-web-mvc.adoc[]

== Add-on Bootstrap
include::addon-web-mvc-bootstrap.adoc[]

== Add-on Web MVC Datatables
include::addon-web-mvc-datatables.adoc[]

== Add-on Web MVC GEO
include::addon-web-mvc-geo.adoc[]

== Add-on Campos Lupa
include::addon-web-mvc-loupe.adoc[]

== Add-on OCC (Optimistic Concurrency Control)
include::addon-occ.adoc[]

== Add-on Web Dialog
include::addon-web-dialog.adoc[]

== Add-on Web Report
include::addon-web-report.adoc[]

== Add-on Service
include::addon-service.adoc[]

== Add-on Web MVC i18n
include::addon-web-i18n.adoc[]

== Add-on Dynamic Configuration
include::addon-dynamic-config.adoc[]

== Add-on Web MVC Binding
include::addon-web-mvc-binding.adoc[]

:numbered:
= III. Apéndices

En este capitulo se recoge información adicional sobre todo lo comentado 
en las secciones anteriores así como un apéndice de todos los comandos disponibles 
en la herramienta de desarrollo gvNIX.

[appendix]
== Apéndice de comandos
include::apendice-comandos.adoc[]

[appendix]
== Desarrollo con eclipse
include::guia-desarrollo_eclipse.adoc[]

[appendix]
== Recetas
include::recetas.adoc[]

[appendix]
== Código generado por gvNIX/Roo
include::guia-desarrollo_generacion-codigo.adoc[]

[appendix]
== Mejoras de rendimiento
include::guia-desarrollo_mejoras-rendimiento.adoc[]


:numbered:
= IV. Recursos

// Push titles down one level.
:leveloffset: 1
include::recursos.adoc[]
