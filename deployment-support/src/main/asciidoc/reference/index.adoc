//
// Prerequisites:
//
//   ruby 1.9.3+
//   asciidoctor     (use gem to install)
//   asciidoctor-pdf (use gem to install)
//
// Build the document:
// ===================
//
// HTML5 Asciidoctor:
//   # Embed images in XHTML
//   asciidoctor -b html5 index.adoc
//
// PDF Asciidoctor:
//   $ asciidoctor-pdf index.adoc
//
= {title}
:title:         gvNIX - Documentación de referencia
:Project:       gvNIX, un Add-On Suite de Spring Roo
:Author:        Dirección General de Tecnologías de la Información, Asociación gvSIG, DISID Corporation, S.L.
:version:       2.0.0.M1
:corpsite:      www.gvnix.org
:Copyright:     2010 (C) Dirección General de Tecnologías de la Información - Conselleria de Hacienda y Administración Pública - CC BY-NC-SA 3.0
:keywords:      gvNIX, Documentation
:doctype:       book
:toc:
:toc-placement: left
:toc-title:     Índice de contenidos
:toclevels:     5
:sectnumlevels: 5
:numbered:
:sectanchors:
:icons:         font
:imagesdir:     ./images
:source-highlighter:  coderay
ifdef::backend-pdf[]
:pdf-style:     asciidoctor
:pagenums:
endif::[]

_{version}_

_{project}_ | link:{corpsite}[{corpsite}]

[abstract]

_2010 (C) Dirección General de Tecnologías de la Información - Conselleria de Hacienda y
Administración Pública - Generalitat Valenciana._ Esta obra está bajo la licencia
http://creativecommons.org/licenses/by-sa/3.0/es/[Reconocimiento-Compartir bajo la misma licencia 3.0 España]
de Creative Commons. Puede copiarla, distribuirla y comunicarla públicamente
siempre que especifique sus autores y comparta cualquier obra derivada bajo la
misma licencia.


== Prólogo

=== Overview

gvNIX es un entorno de trabajo Java de código abierto para el desarrollo
rápido de aplicaciones web altamente productivo, flexible y que no
compromete la calidad de los proyectos.

gvNIX trabaja sobre la herramienta de desarrollo http://projects.spring.io/spring-roo[Spring Roo] 
ampliando sus funcionalidades básicas con componentes de alto nivel funcional.

gvNIX está patrocinado por la Dirección General de Tecnologías de la Información
(DGTI) de la Conselleria de Hacienda y Administración Pública de la
Generalitat Valenciana (Comunidad Valenciana, España), gestionado por la
Asociación gvSIG y dirigido por DISID. gvNIX se consolida como estándar para
desarrollo Java de la DGTI de la Generalitat Valenciana.

gvNIX está disponible dentro del proyecto de Migración a Software de
fuentes abiertas http://www.gvpontis.gva.es[gvPONTIS].

=== Requisitos

Antes de empezar a trabajar con la herramienta de desarrollo gvNIX, es aconsejable conocer cómo 
funciona Spring Roo. Para ello, se recomienda leer la 
http://docs.spring.io/spring-roo/docs/2.0.0.M1/reference/html/[documentación de referencia].

Además, para entender mejor la arquitectura de las aplicaciones generadas, se aconseja tener unos conocimientos
básicos sobre aplicaciones desarrolladas utilizando 
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/[Spring].

Para poder trabajar con la herramienta de desarrollo gvNIX en un entorno de desarrollo, es necesario disponer de 
los siguientes componentes:

* http://projects.spring.io/spring-roo/#running-from-shell[Spring Roo] descargado y
descomprimido.
* Versión más actual de Java JDK 6 instalado en el sistema. Se 
recomienda utiliar *Java 7*, aunque se dispone de soporte para Java 8.
(http://www.oracle.com/technetwork/java/javase/downloads/index.html[Más
información]).
* Maven 3.0.5 o superior (http://maven.apache.org/).
* Conexión a Internet para poder instalar de forma correcta gvNIX en
la distribución de Spring Roo y descargar las dependencias de los
proyectos generados.


[NOTE]
====
Solo es posible utilizar gvNIX 2.0+ sobre las versiones 2.0
de Spring Roo en adelante. Esto es debido a que la instalación de 
distribuciones es una característica de las últimas versiones 
de Spring Roo.
====

=== Instalar gvNIX

Para instalar el gvNIX sobre una distribución de Spring Roo. es necesario que Roo conozca 
donde están alojados todos los componentes que forman parte de gvNIX.
Por ello, es necesario instalar en nuestra distribución de Spring Roo el repositorio donde se 
encuentran dichos componentes.

Sigue los siguientes pasos para instalar el repositorio de gvNIX en tu distribución de
Spring Roo 2.0+:

1. Ejecuta la consola de Spring Roo 2.0+:
+
--------------------------------------------
bash:~$ cd /tmp/new_project
bash:~$ ~/software/spring-roo-2.0/bin/roo.sh
--------------------------------------------

2. Accede al http://projects.spring.io/spring-roo/marketplace/["Roo Market Place"] y
copia la URL del repositorio de gvNIX (http://repository.gvnix.org/index.xml).

3. Ejecuta el siguiente comando en tu consola de Spring Roo 2.0+ para 
instalar el repositorio anterior:
+
----------------------------------------------------------------------
roo> addon repository add --url http://repository.gvnix.org/index.xml
----------------------------------------------------------------------

4. Valida que se ha instalado el repositorio de forma correcta listando los componentes
que están disponibles en dicho repositorio. Para ello, ejecuta el siguiente comando:
+
---------------------------------
roo> addon repository introspect
---------------------------------

5. Si todo ha salido bien, aparecerá un listado mostrando todos los componente que forman
parte de la distribución gvNIX.
+
----------------------------------------------------------------------------------------
Not Installed        gvNIX - Addon - Bootstrap3 support (2.0.0.M1)
Not Installed        gvNIX - Addon - Co-official languages of Spain (2.0.0.M1)
Not Installed        gvNIX - Addon - Dynamic Configuration (2.0.0.M1)
Not Installed        gvNIX - Addon - GEO Support (2.0.0.M1)
Not Installed        gvNIX - Addon - JPA layer services (2.0.0.M1)
Not Installed        gvNIX - Addon - Loupe Fields (2.0.0.M1)
Not Installed        gvNIX - Addon - Monitoring Support (2.0.0.M1)
Not Installed        gvNIX - Addon - Optimistic Concurrency Control (2.0.0.M1)
Not Installed        gvNIX - Addon - Services Management (2.0.0.M1)
Not Installed        gvNIX - Addon - Typical Security (2.0.0.M1)
Not Installed        gvNIX - Addon - Web Datatables Addon (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC (JSP) layer services (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Bindings (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Dialogs (2.0.0.M1)
Not Installed        gvNIX - Addon - Web MVC Menu (2.0.0.M1)
Not Installed        gvNIX - Addon - Web Report (2.0.0.M1)
Not Installed        gvNIX - Annotations - GEO Support (2.0.0.M1)
Not Installed        gvNIX - Annotations - JPA layer services (2.0.0.M1)
Not Installed        gvNIX - Annotations - Loupe Fields (2.0.0.M1)
Not Installed        gvNIX - Annotations - Optimistic Concurrency Control (2.0.0.M1)
Not Installed        gvNIX - Annotations - Services Management (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web Datatables Addon (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC (JSP) layer services (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC Bindings (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web MVC Dialogs (2.0.0.M1)
Not Installed        gvNIX - Annotations - Web Report (2.0.0.M1)
Not Installed        gvNIX - Roo Addon Suite (2.0.0.M1)
Not Installed        gvNIX - Support Module (2.0.0.M1)
----------------------------------------------------------------------------------------

6. Ahora que ya tienes instalado el repositorio que contiene los componentes de gvNIX, continuamos con
la instalación de los mismos. Para ello ejecuta el siguiente comando:
+
----------------------------------------------------------------------
roo> addon suite install name --symbolicName org.gvnix.roo.addon.suite
----------------------------------------------------------------------

7. Valida que se ha instalado el Roo Add-On Suite de gvNIX ejecutando el siguiente comando:
+
----------------------
roo> addon suite list
----------------------

8. Si todo ha salido bien, aparecerá un listado mostrando todos los Roo Add-On Suites que tienes
instalados en tu distribución de Spring Roo:
+
----------------------------------------------------------------
Getting all 'Roo Addon Suites' installed on Spring Roo Shell... 

   org.osgi.service.subsystem.root
   org.gvnix.roo.addon.suite
   
2 Roo Addon Suites were found at your Spring Roo installation
----------------------------------------------------------------

9. Para finalizar, valida que todos los componentes de gvNIX se han instalado correctamente 
en la distribución de Spring Roo ejecutando el siguiente comando:
+
----------------
roo> addon list
----------------

10. Si todo ha salido bien, al final del listado que aparecerá en la consola, podrás ver
todos los componentes de gvNIX instalados y activados del siguiente modo:
+
------------------------------------------------------------------------------------------
   86|Active     |    1|gvNIX - Annotations - GEO Support (2.0.0.M1)
   87|Active     |    1|gvNIX - Addon - Dynamic Configuration (2.0.0.M1)
   88|Active     |    1|gvNIX - Addon - Loupe Fields (2.0.0.M1)
   89|Active     |    1|gvNIX - Addon - Web MVC (JSP) layer services (2.0.0.M1)
   90|Active     |    1|gvNIX - Annotations - Web Datatables Addon (2.0.0.M1)
   91|Active     |    1|gvNIX - Addon - JPA layer services (2.0.0.M1)
   92|Active     |    1|gvNIX - Addon - Web Datatables Addon (2.0.0.M1)
   93|Active     |    1|gvNIX - Annotations - Web MVC (JSP) layer services (2.0.0.M1)
   94|Active     |    1|gvNIX - Addon - Services Management (2.0.0.M1)
   95|Active     |    1|gvNIX - Annotations - Web Report (2.0.0.M1)
   96|Active     |    1|gvNIX - Addon - Co-official languages of Spain (2.0.0.M1)
   97|Active     |    1|gvNIX - Annotations - Optimistic Concurrency Control (2.0.0.M1)
   98|Active     |    1|gvNIX - Addon - Web MVC Dialogs (2.0.0.M1)
   99|Active     |    1|gvNIX - Annotations - Services Management (2.0.0.M1)
  100|Active     |    1|gvNIX - Addon - Monitoring Support (2.0.0.M1)
  101|Active     |    1|gvNIX - Addon - Bootstrap3 support (2.0.0.M1)
  102|Active     |    1|gvNIX - Annotations - Web MVC Dialogs (2.0.0.M1)
  103|Active     |    1|gvNIX - Addon - GEO Support (2.0.0.M1)
  104|Active     |    1|gvNIX - Addon - Optimistic Concurrency Control (2.0.0.M1)
  105|Active     |    1|gvNIX - Support Module (2.0.0.M1)
  106|Active     |    1|gvNIX - Annotations - Loupe Fields (2.0.0.M1)
  107|Active     |    1|gvNIX - Annotations - JPA layer services (2.0.0.M1)
  108|Active     |    1|gvNIX - Addon - Web Report (2.0.0.M1)
  109|Active     |    1|gvNIX - Annotations - Web MVC Bindings (2.0.0.M1)
  110|Active     |    1|gvNIX - Addon - Typical Security (2.0.0.M1)
  111|Active     |    1|gvNIX - Addon - Web MVC Menu (2.0.0.M1)
  112|Active     |    1|gvNIX - Addon - Web MVC Bindings (2.0.0.M1)
------------------------------------------------------------------------------------------

Una vez hecho esto, ya se puede trabajar con el entorno gvNIX desde la
línea de comandos. Sin embargo, se recomienda utilizar un IDE de
desarrollo que permita integrar el entorno gvNIX como, por ejemplo STS o
Eclipse.

== Introducción

=== ¿Qué es gvNIX?

gvNIX es un entorno de trabajo Java de código abierto para el desarrollo
rápido de aplicaciones web altamente productivo, flexible y que no
compromete la calidad de los proyectos.

Está compuesto por una serie de herramientas de código abierto distribuídas 
en forma de http://docs.spring.io/spring-roo/docs/2.0.0.M1/reference/html/#available-roo-addon-suites["Spring Roo Add-On Suite"]
a través de un repositorio OSGi R5.
Esto le proporciona un amplio apoyo por parte de importantes
organizaciones como http://spring.io/[Spring] y http://pivotal.io/[Pivotal]. 
Añade funcionalidades de alto nivel a las prestaciones que ya se obtienen con
http://projects.spring.io/spring-roo/[Spring Roo] para mejorar la
productividad.

gvNIX está patrocinado por la Dirección General de Tecnologías de la Información
(DGTI) de la Conselleria de Hacienda y Administración Pública de la
Generalitat Valenciana (Comunidad Valenciana, España), gestionado por la
Asociación gvSIG y dirigido por DISID. gvNIX se consolida como estándar para
desarrollo Java de la DGTI de la Generalitat Valenciana.

gvNIX está disponible dentro del proyecto de Migración a Software de
fuentes abiertas http://www.gvpontis.gva.es[gvPONTIS].

* http://www.gvnix.org[Página del proyecto gvNIX]
* http://www.gvpontis.gva.es/cast/gvnix/[Página de gvNIX dentro del
proyecto gvPONTIS]
* http://projects.spring.io/spring-roo/[Página oficial de Spring Roo]

=== ¿Qué es Spring Roo?

Según su creador, Ben Alex: "Roo es un pequeño genio que observa desde
un segundo plano y gestiona todo aquello de lo que no me quiero
preocupar".

Spring Roo es un entorno de trabajo Java que permite el desarrollo de
aplicaciones web de forma rápida y cómoda para el desarrollador. Sus
principales características son:

* Generación de código en Java (lenguaje estático).
* Eliminar el trabajo tedioso centrando el desarrollo en la lógica de
negocio.
* Convención sobre configuración.
* Desarrollo dirigido por el dominio (Domain-Driven Development):
** Diseño dirigido por el modelo de entidades.
** Lógica en las entidades (Real Object Oriented), eliminando capas
redundantes.
** Otras capas opcionales (servicios, DAOs, ...).
* Crea un proyecto en segundos.
* Realimentación: añade valor durante todo el ciclo de vida.
* No incorpora elementos adicionales al entorno de ejecución, por lo que
no penaliza la velocidad ni la memoria de la aplicación.
* No requiere ningún IDE.
* Recibe instrucciones a través de una consola interactiva con
autocompletado y ayuda en línea.
* Extensible usando _bundles OSGi_.
* Aprovecha el conocimiento: no necesita más conocimiento que el
necesario para el desarrollo de aplicaciones JEE.

=== ¿Qué es un "Roo Add-On Suite"?

Los "Roo Add-On Suites" son la mejor manera de empaquetar y distribuir conjuntos de Add-Ons para que
puedan ser instalados en distribuciones de Spring Roo de forma rápida y sencilla.

Están basados en subsistemas de OSGi R5, los cuales permiten instalar un conjunto de componentes sobre 
la distribución de Spring Roo sin comprometer su modularidad.

Por todo lo anterior, decimos que *gvNIX es un "Spring Roo Add-On Suite"* que puede ser instalado en
distribuciones de Spring Roo para ampliar sus funcionalidades básicas.

=== ¿Qué ofrece gvNIX?

gvNIX aprovecha las características de Spring Roo y aporta su propia
filosofía, ofrecer al desarrollador componentes de alto valor funcional
para aplicaciones corporativas:

* Control de concurrencia a nivel de aplicación sin campos en base de
datos.
* Utilidades de generación de consultas.
* Utilidades de modificaciones múltiples de entidades.
* Gestión de temas visuales utilizando jQuery, Bootstrap, HTML5 y CSS3. 
* Gestión de la visualización de excepciones.
* Gestión de mensajes de usuario en ventana modal.
* Gestión de la estructura de páginas en el menú.
* Gestión de patrones de visualización de entidades y sus relaciones utilizando
el componente Datatables.
* Gestión de transformación de cadenas vacías a valores nulos.
* Gestión de servicios locales y servicios web (importación y
exposición).
* Control de acceso (autenticación y autorización).
* Gestión de configuraciones por entorno.
* Generación de documentos (reportes).
* Gestión de relaciones utilizando componente Lupa.
* Gestión de información geográfica.
* Generación de GeoPortales interactivos.

== Empezando con gvNIX: Tutorial (I)

En este capítulo generaremos una aplicación sencilla paso a paso de forma rápida para que 
puedas ver y entender cómo se trabaja con la herramienta de desarrollo gvNIX en un proyecto básico.

Los detalles sobre la generación del código y la explicación de cada uno de los comandos ejecutados, se
mostrarán en las siguientes secciones de este manual. 

=== ¿Qué aprenderás?

En este tutorial aprenderás como crear una aplicación desde cero utilizando la herramienta de 
desarrollo gvNIX sobre el IDE STS.

Las principales características de gvNIX que veremos en este tutorial son las siguientes:

* Creación de un proyecto
* Configurarción de persistencia
* Generación del modelo de entidades
* Generación de métodos de búsqueda
* Generación de capa web
* Componente Datatables y Bootstrap
* Patrones de Pantalla
* Ejecución de una aplicación en un servidor Tomcat
* Edición de datos en linea
* Componente Lupa
* Instalación y gestión de menú
* Aplicar seguridad a nuestra aplicación
* Generación de informes utilizando Jasper Reports
* Tests funcionales y Tests de integración
* Generación de servicios web.


=== Detalles de la aplicación

La aplicación que se va a generar está basada en la aplicación de ejemplo Petclinic de Spring. Los usuarios de esta aplicación son empleados
de una clínica veterinaria, que a lo largo de su jornada laboral, necesitan gestionar información sobre veterinarios, clientes y sus mascotas.

Después de esta pequeña introducción sobre la aplicación que se va a desarrollar, hemos generado un diagrama de clases simple 
para el modelo de entidades de esta aplicación:

image::petclinic-uml.png[Petclinic UML,align=center]  

Para sacar el máximo partido a las funcionalidades de gvNIX y Spring Roo, es recomendable que las aplicaciones se generen 
siguiendo la filosofía del https://es.wikipedia.org/wiki/Dise%C3%B1o_guiado_por_el_dominio[diseño guiado por el dominio].

[NOTE]
====
Hay que tener en cuenta que la aplicación que se va a generar no será una aplicación real, ya que normalmente necesitaría
una serie de trabajos adicionales para personalizar la capa web, implementar lógica de negocio, etc..
====

=== Paso 1: Crear un proyecto

A continuación, vamos a crear un nuevo proyecto desde STS. Para ello accede a *"New > Project... > Spring > Spring Roo Project"* 
como se muestra en la imagen:

image::eclipse_new_roo_project.png[Nuevo proyecto,align=center] 

Una vez seleccionado el tipo de proyecto que queremos generar, configura el proyecto:

image::eclipse_new_roo_project_2.png[Configuración del Proyecto,align=center]

*Nombre del Proyecto:* petclinic

*Top level package:* com.springsource.petclinic

Al clicar sobre Next y Finish se generará el nuevo proyecto y seguidamente se 
iniciará la consola de Spring Roo.

image::eclipse_roo_shell.png[Consola de gvNIX,align=center] 

*IMPORTANTE* Antes de continuar con el tutorial es necesario que valides que ĺa distribución de 
Spring Roo que estás utilizando tiene instalados los componentes de gvNIX.

Para ello, ejecuta el siguiente comando:

-----------------------
roo> addon suite list
-----------------------

Debe mostrarse el siguiente contenido:

------------------------------------------------------------------
roo> addon suite list 
Getting all 'Roo Addon Suites' installed on Spring Roo Shell... 
 
   org.osgi.service.subsystem.root
   org.gvnix.roo.addon.suite
 
2 Roo Addon Suites were found at your Spring Roo installation
roo>
------------------------------------------------------------------ 

En caso de que solo aparezca el Roo Add-On Suite por defecto "org.osgi.service.subsystem.root", significará
que no has instalado de forma correcta gvNIX. 

Sigue los pasos de la link:#instalar-gvnix[sección anterior] para instalar los componentes de gvNIX
sobre la distribución de Spring Roo antes de continuar con el tutorial.

=== Paso 2: Configurar persistencia

¿Ya aparecen los componentes de gvNIX instalados en tu distribución de Roo? Si no es así, sigue los pasos de la 
link:#instalar-gvnix[sección anterior] para instalar los componentes de gvNIX sobre la distribución de Spring Roo 
antes de continuar con el tutorial.

Vamos a configurar la persistencia de nuestro proyecto. En este caso vamos a utilizar HIBERNATE como ORM y el tipo
 de base de datos HYPERSONIC_PERSISTENT.
 
Para ello, ejecutamos el siguiente comando sobre la consola de gvNIX en STS:

----------------------------------------------------------------------
roo> jpa setup --provider HIBERNATE --database HYPERSONIC_PERSISTENT
----------------------------------------------------------------------

=== Paso 3: Generar modelo de entidades

Siguiendo el modelo de entidades link:#detalles-de-la-aplicación[propuesto anteriormente], ejecutaremos los siguientes comandos
para generar nuestro dominio:

Crea todas las entidades de nuestra aplicación ejecutando los siguientes comandos:

--------------------------------------------------------------------------
 entity jpa --class ~.domain.Pet --sequenceName PET_SEQ
 entity jpa --class ~.domain.Visit --sequenceName VISIT_SEQ
 entity jpa --class ~.domain.AbstractPerson --abstract
 entity jpa --class ~.domain.Vet --extends ~.domain.AbstractPerson
 entity jpa --class ~.domain.Owner --extends ~.domain.AbstractPerson
--------------------------------------------------------------------------

Crea los enumerados *PetType* y *Speciality* ejecutando los siguientes comandos:

--------------------------------------------------------------------------
 enum type --class ~.reference.PetType
 enum constant --name Dog
 enum constant --name Cat
 enum constant --name Bird
 enum type --class ~.reference.Specialty
 enum constant --name Cardiology
 enum constant --name Dentistry
 enum constant --name Nutrition
--------------------------------------------------------------------------

Añade todos los campos a las entidades ejecutando los siguientes comandos:

--------------------------------------------------------------------------------------------------------------------------------------
 field string --fieldName firstName --sizeMin 3 --sizeMax 30 --class ~.domain.AbstractPerson
 field string --fieldName lastName --notNull --sizeMin 3 --sizeMax 30
 field string --fieldName address --notNull --sizeMax 50 --sizeMin 1
 field string --fieldName city --notNull --sizeMax 30
 field string --fieldName telephone --notNull
 field string --fieldName homePage --sizeMax 30
 field string --fieldName email --sizeMax 30 --sizeMin 6
 field date --fieldName birthDay --type java.util.Date --notNull
 field string --fieldName description --sizeMax 255 --class ~.domain.Visit
 field date --fieldName visitDate --type java.util.Date --notNull --past
 field reference --fieldName pet --type ~.domain.Pet --notNull
 field reference --fieldName vet --type ~.domain.Vet
 field boolean --fieldName sendReminders --notNull --primitive --class ~.domain.Pet
 field string --fieldName name --notNull --sizeMin 1
 field number --fieldName weight --type java.lang.Float --notNull --min 0
 field reference --fieldName owner --type ~.domain.Owner
 field enum --fieldName type --type ~.reference.PetType --notNull
 field date --fieldName employedSince --type java.util.Calendar --notNull --past --class ~.domain.Vet
 field enum --fieldName specialty --type ~.reference.Specialty --notNull false
 field set --class ~.domain.Owner --fieldName pets --type ~.domain.Pet --mappedBy owner --notNull false --cardinality ONE_TO_MANY
 field set --class ~.domain.Vet --fieldName visits --type ~.domain.Visit --mappedBy vet --notNull false --cardinality ONE_TO_MANY
 field reference --fieldName owner --type ~.domain.Owner --class ~.domain.Vet
 field set --fieldName vets --type ~.domain.Vet --class ~.domain.Owner --cardinality ONE_TO_MANY --mappedBy owner
 field set --fieldName visits --type ~.domain.Visit --class ~.domain.Pet --cardinality ONE_TO_MANY --mappedBy pet
--------------------------------------------------------------------------------------------------------------------------------------

=== Paso 4: Métodos de búsqueda

Para ser capaces de filtrar los registros guardados en nuestra base de datos, es necesario que nuestras entidades dispongan
de unos métodos de búsqueda.

Para instalarlos, ejecutaremos los siguientes comandos:

--------------------------------------------------------------------------------------
finder add --finderName findPetsByNameAndWeight --class ~.domain.Pet
finder add --finderName findPetsByOwner
finder add --finderName findPetsBySendRemindersAndWeightLessThan
finder add --finderName findPetsByTypeAndNameLike
finder add --finderName findVisitsByDescriptionAndVisitDate --class ~.domain.Visit
finder add --finderName findVisitsByVisitDateBetween
finder add --finderName findVisitsByDescriptionLike
--------------------------------------------------------------------------------------

=== Paso 5: Capa web

En este momento ya disponemos de nuestro modelo de entidades generado. Ahora, es necesario que generemos la capa web 
de nuestra aplicación para que los usuarios puedan acceder a ella a través de un navegador.

En primer lugar instalamos todos los componentes web de nuestra aplicación como imágenes, estilos css, tagx, etc... utilizando
el siguiente comando:

-------------
web mvc setup
-------------

A continuación, generamos la capa web de todas las entidades de nuestro proyecto ejecutando el siguiente comando:

----------------------------
web mvc all --package ~.web
----------------------------

Para generar las vistas de los métodos de búsqueda añadidos link:#paso-4-métodos-de-búsqueda[anteriormente] y que el usuario
pueda realizar búsquedas de forma visual, ejecutaremos el siguiente comando:

-------------------
web mvc finder all
-------------------

Si necesitas instalar varios idiomas en tu aplicación, puedes ejecutar los siguientes comandos:

---------------------------
web mvc language --code es
web mvc language --code de
---------------------------

=== Paso 6: Instalar JQuery, Datatables y Bootstrap

A continuación, incluiremos la librería https://jquery.com/[JQuery] en nuestro proyecto generado.
Además, incluiremos el componente http://datatables.net/[Datatables] que utilizaremos en las vistas de listado y finalmente,
transformaremos la apariencia de nuestra aplicación para que se muestre con estilo http://getbootstrap.com/[Bootstrap].

Para instalar jQuery en nuestro proyecto, ejecutamos el siguiente comando:

--------------------
web mvc jquery setup
--------------------

Para que todas nuestras vistas utilicen componentes jQuery, utilizaremos el siguiente comando:

--------------------
web mvc jquery all
--------------------

Seguimos con el tutorial instalando el componente Datatables en nuestro proyecto con el siguiente comando:

-------------------------
web mvc datatables setup
-------------------------

[NOTE]
====
De momento solo instalamos los componentes Datatables, pero nuestras vistas de listado no lo están utilizando.
====

Para finalizar este punto, transformamos la apariencia de nuestra aplicación a Bootstrap con el siguiente comando:

-------------------------
web mvc bootstrap setup
-------------------------

=== Paso 7: Edición en linea y Selección Múltiple

Entre las múltiples funcionalidades que ofrece el componente Datatables, el cual hemos incluido en el 
link:#paso-6-instalar-jquery-datatables-y-bootstrap[paso anterior], encontramos la edición en linea y la selección múltiple.

La funcionalidad de edición en linea permite a los usuarios crear y editar registros directamente desde el componente Datatable
sin abandonar el listado. 

La funcionalidad de selección múltiple permite seleccionar varios registros mostrados en el componente Datatables para así, aplicar
acciones sobre ellos, como puede ser editar o eliminar. 

Para que los Datatables que utilicemos en nuestra aplicación sean capaces de incluir estas funcionalidades
, ejecutaremos los siguientes comandos:

--------------------
jpa gvnix setup
jpa batch all
web mvc batch setup
web mvc batch all
--------------------


=== Paso 8: Patrones de Pantalla

En este punto, vamos a definir una serie de patrones de pantalla "maestro > detalle" utilizando el componente Datatables añadido en el  
link:#paso-6-instalar-jquery-datatables-y-bootstrap[paso anterior].

==== Creación de Maestros

A continuación creamos todas las vistas maestras de nuestra aplicación:

--------------------------------------------------------------------------------
web mvc datatables add --type ~.web.VetController --mode show
web mvc datatables add --type ~.web.PetController
web mvc datatables add --type ~.web.OwnerController
web mvc datatables add --type ~.web.VisitController --inline true --ajax true
--------------------------------------------------------------------------------

[NOTE]
====
Utiliza el parámetro *--mode* con valor show para mostrar un único registro por página. Utiliza el parámetro *--inlineEditing* para habilitar
la edición en linea.
====

==== Creación de Detalles

Después de crear los maestros, continuamos generando los detalles.

Para generar el patrón de pantalla "Maestro Owners > Detalle Pets" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.OwnerController --property pets
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Vets" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.OwnerController --property vets
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Pet > Detalle Visit" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.PetController --property visits
--------------------------------------------------------------------------

Para generar el patrón de pantalla "Maestro Owners > Detalle Vet > Detalle Visit" ejecutaremos el siguiente comando:

--------------------------------------------------------------------------
web mvc datatables detail add --type ~.web.VetController --property visits
--------------------------------------------------------------------------

[NOTE]
====
El ejemplo anterior muestra un patrón de pantalla de tres niveles. (Maestro, detalle y detalle de detalle)
====

=== Paso 9: Primera ejecución

En este momento vamos a ejecutar nuestra aplicación en un servidor Tomcat.

En primer lugar, es necesario añadir el servidor Tomcat a nuestro IDE STS. Para ello, seguiremos los siguientes pasos:

* En la pestaña "Servers" añadiremos un nuevo servidor utilizando "New... > Server".
* Aparecerá una ventana como la siguiente, donde seleccionaremos el servidor "Apache Tomcat v6.0":

image::eclipse_servers_new.png[Nuevo Servidor,align=center]

* Seleccionamos el directorio donde tengamos descargado nuestro apache-tomcat. Si no lo tienes descargado, puedes hacer
click sobre el botón "Download and Install" y se descargará de forma automática:

image::eclipse_servers_configure.png[Configurar servidor,align=center]

* A continuación, añadimos nuestra aplicación generada al servidor Tomcat:

image::eclipse_servers-addremoveapp.png[Nueva app,align:center]

Ahora que ya tenemos un servidor Tomcat configurado y nuestra aplicación añadida, podemos arrancar el servidor Tomcat utilizando
el botón de "Play" con el servidor Tomcat seleccionado:

image::eclipse_servers-buttons.png[Botones Servers,align=center]


Una vez haya arrancado, podemos acceder a la URL http://localhost:8080/petclinic/ desde nuestro navegador para 
visualizar la aplicación generada.

image::sample-application-0.png[Estado de la aplicación,align=center]

=== Paso 10: Componente Lupa

El componente lupa provee funcionalidades para buscar datos relacionados de forma rápida y sencilla utilizando AJAX.

Para instalar el componente lupa en nuestra aplicación generada, es necesario ejecutar el siguiente comando:

--------------------
web mvc loupe setup
--------------------

A continuación, añadimos una serie de funcionalidades necesarias para el correcto funcionamiento del componente
en la capa controladora:

------------------------------------------------------
web mvc loupe set --controller ~.web.VisitController
------------------------------------------------------

Finalmente, convertimos los elementos "combobox" a componentes lupa utilizando los siguientes comandos:

---------------------------------------------------------------------------------------------------------------------------
web mvc loupe field --controller ~.web.VisitController --field pet --caption name --additionalFields name,weight --max 5
web mvc loupe field --controller ~.web.VisitController --field vet
---------------------------------------------------------------------------------------------------------------------------

=== Paso 11: Instalación del Menú

gvNIX provee un menú mucho más personalizable que el definido inicialmente por Spring Roo. Por ello, se aconseja 
que todas las aplicaciones incorporen el menú de gvNIX utilizando este sencillo comando:

-----------
menu setup
-----------

=== Paso 12: Aplicar Seguridad

Aplicar seguridad a un proyecto puede ser algo complicado. Utilizando el siguiente comando, se añade seguridad a nuestro proyecto
generado utilizando http://projects.spring.io/spring-security/[Spring Security].

--------------
security setup
--------------

=== Paso 13: Gestión de Informes

Vamos a añadir un informe sobre los "Owners" que tenemos registrados en nuestro sistema petclinic. Para ello, ejecutamos los 
siguientes comandos:

--------------------------------------------------------------------------------
web report setup
web report add --controller ~.web.OwnerController --reportName report_owners
--------------------------------------------------------------------------------

=== Paso 14: Control de concurrencia

Vamos a añadir control de concurrencia sobre la entidad "Pet" de nuestro proyecto, para así evitar que se pierdan
los datos guardados cuando varios usuarios editan un mismo registro.

Para ello, basta con ejecutar el siguiente comando:

-----------------------------------------
occ checksum set --entity ~.domain.Pet
-----------------------------------------

=== Paso 15: Tests funcionales y tests de integración

En este momento, vamos a añadir una serie de tests funcionales y tests de integración a nuestra aplicación generada. Para los
tests funcionales utilizaremos http://www.seleniumhq.org/[Selenium] y para los tests de integración utilizaremos http://junit.org/[JUnit].

Añadimos los tests funcionales a todas las vistas de nuestro proyecto utilizando los siguientes comandos:

--------------------------------------------------
selenium test --controller ~.web.OwnerController
selenium test --controller ~.web.PetController
selenium test --controller ~.web.VetController
selenium test --controller ~.web.VisitController
--------------------------------------------------

Añadimos los tests de integración a cada una de las entidades de nuestro proyecto utilizando los siguientes comandos:

-----------------------------------------
test integration --entity ~.domain.Vet
test integration --entity ~.domain.Owner
test integration --entity ~.domain.Pet
test integration --entity ~.domain.Visit
-----------------------------------------

=== Paso 16: Servicios web

Para acabar con esta guía rápida sobre las funcionalidades disponibles en la herramienta de desarrollo gvNIX, vamos a servir 
varios servicios web desde nuestra aplicación generada.

Para ello, ejecutamos los siguientes comandos:

----------------------------------------------------------------------------------------
remote service define ws --class ~.services.PetsServices --serviceName ws_get_all_pets
remote service operation --name ws_list_pets --service ~.services.PetsServices
----------------------------------------------------------------------------------------

[NOTE]
====
Estos servicios estarán disponibles en http://localhost:8080/petclinic/services y podrán ser consumidos
por aplicaciones externas.
====

=== Resultado

Después de seguir este rápido tutorial donde se muestran algunas de las funcionalidades que ofrece la herramienta gvNIX,
tendremos una aplicación generada con el siguiente aspecto:

image::sample-application-login.png[Login,align=center]
image::sample-application-pet-creation.png[Alta de una mascota,align=center]
image::sample-application-pet-list.png[Listado de mascotas,align=center]
image::sample-application-visit-inline.png[Edición en linea,align=center]

Ahora que ya conoces las funcionalidades básicas de gvNIX, te recomendamos que continues leyendo este manual. 
Algunas secciones que pueden interesarte son:

* link:#gvnix-avanzado-componentes-geo-tutorial-ii[gvNIX Avanzado - Componentes GEO: Tutorial (II)]
* link:#gvnix-addons[Listado de Add-Ons disponibles en gvNIX]


== gvNIX avanzado: Componentes GEO (Tutorial II)

En este capítulo actualizaremos la aplicación generada en la link:#empezando-con-gvnix-tutorial-i[primera parte] de este tutorial 
incluyendo componentes de tipo geográfico.

Los detalles sobre la generación del código y la explicación de cada uno de los comandos ejecutados, se
mostrarán en las siguientes secciones de este manual. 

=== ¿Qué aprenderás?

En esta segunda parte del tutorial, aprenderás a incluir componentes de tipo GEO en tus aplicaciones generadas
utilizando la herramienta de desarrollo de gvNIX.

Las principales características de gvNIX que veremos en este tutorial son las siguientes:

* Configurar persistencia con BBDD que aceptan campos de tipo GEO.
* Incluir soporte espacial utilizando http://www.hibernatespatial.org/[Hibernate Spatial].
* Añadir campos de tipo GEO en entidades generadas.
* Generar buscadores sobre campos de tipo GEO.
* Añadir mapas en las vistas de creación, actualización y visualización.
* Generar geoportales para representar y gestionar los datos de la aplicación.
* Añadir entidades al geoportal generado
* Añadir capas base WMS y TileLayers al geoportal generado.
* Añadir herramientas al geoportal generado.
* Filtrar datos representados en el geoportal utilizando el componente Datatables
* Seleccionar datos representados en el geoportal utilizando el componente Datatables
* Agrupar elementos dependiendo del nivel de zoom.

=== Paso 1: Configurar persistencia GEO

Lo primero que debemos saber es que no todas las bases de datos que ofrece la herramienta de desarrollo gvNIX 
a la hora de configurar la persistencia son compatibles con información geográfica.

Por este motivo, antes de incluir componentes geográficos en nuestra aplicación, es necesario configurar una 
base de datos válida.

Las bases de datos (que ofrece gvNIX) compatibles con campos de tipo GEO, son las siguientes:

* http://www.postgresql.org/[PostgreSql]
* https://www.oracle.com/database/index.html[Oracle 10g/11g]
* http://www.mysql.com/[MySQL]
* http://www.microsoft.com/es-es/server-cloud/products/sql-server/[SqlServer]


En nuestro caso, utilizaremos una base de datos de tipo POSTGRES. Para ello, es necesario que configures una BBDD de tipo 
http://www.postgresql.org/[POSTGRES] en tu equipo y añadas soporte geográfico incluyendo http://trac.osgeo.org/postgis/[POSTGIS]. 

Para realizar la configuración anterior puedes seguir los siguientes pasos:

* Instala http://www.postgresql.org/[PostgreSql] y http://trac.osgeo.org/postgis/[Postgis].
* De manera opcional, puedes instalar http://www.pgadmin.org/[pgadmin] para gestionar tus bases de datos Postgres de forma visual.  
* Crea una nueva base de datos.
* Añade la extensión *postgis* y *postgis_topology* en la base de datos generada, tal y como se muestra en la siguiente imágen:

image::postgis_db.png[Extensiones Postgis,align=true]

Para más información sobre como configurar Postgis consulta su guía de referencia http://postgis.net/documentation/[aquí].

Ahora que disponemos de una base de datos válida configurada en nuestro equipo, actualizaremos nuestro proyecto generado 
para utilizar una base de datos de tipo POSTGRES ejecutando el siguiente comando:

-------------------------------------------------------------------------------------------------------------------------------------------
jpa setup --provider HIBERNATE --database POSTGRES --userName USERNAME --databaseName DATABASENAME --password PASSWORD --hostName HOSTNAME
-------------------------------------------------------------------------------------------------------------------------------------------

=== Paso 2: Añadir soporte GEO al proyecto

En este momento, tu base de datos está configurada para link:#paso-1-configurar-persistencia-geo[soportar campos de tipo GEO] 
y dispone de una serie de funcionalidades para gestionar información geográfica.  Sin embargo, tu proyecto no acepta estos componentes de momento.

Para añadir soporte espacial en el proyecto generado necesitamos actualizar el mismo para que utilice http://www.hibernatespatial.org/[Hibernate Spatial].

Ejecutando el siguiente comando, nuestro proyecto dispondrá de soporte espacial:

------------------------------------------
jpa geo setup --provider HIBERNATE_SPATIAL
------------------------------------------

[NOTE]
====
En caso de ejecutar el comando anterior sobre una base de datos no válida aparecerá el siguiente mensaje indicándonos qué
tipos de base de datos aceptan información geográfica:

----------------------------------------------------------------------------------------------------------------------------------------
There's not any valid database to apply GEO persistence support. GEO is only supported for POSTGRES, ORACLE, MYSQL and MSSQL databases. 
You must change it following the next instructions:

Replace your current dialect with the correct one: 
org.hibernate.dialect.H2Dialect ==> org.hibernate.spatial.dialect.h2geodb.GeoDBDialect
org.hibernate.dialect.PostgreSQLDialect ==> org.hibernate.spatial.dialect.postgis.PostgisDialect
org.hibernate.dialect.MySQLDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialDialect
org.hibernate.dialect.MySQL5Dialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialDialect
org.hibernate.dialect.MySQLInnoDBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialInnoDBDialect
org.hibernate.dialect.MySQL5InnoDBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatialInnoDBDialect
org.hibernate.dialect.MySQL5DBDialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatial56Dialect
org.hibernate.dialect.MySQLSpatial56Dialect ==> org.hibernate.spatial.dialect.mysql.MySQLSpatial5InnoDBDialect
org.hibernate.dialect.Oracle10gDialect ==> org.hibernate.spatial.dialect.oracle.OracleSpatial10gDialect
org.hibernate.dialect.OracleDialect ==> org.hibernate.spatial.dialect.oracle.OracleSpatial10gDialect
org.hibernate.dialect.SQLServerDialect ==> org.hibernate.spatial.dialect.SQLServer2008Dialect
----------------------------------------------------------------------------------------------------------------------------------------
====


=== Paso 3: Añadir campos GEO a entidades
=== Paso 4: Generar buscadores GEO
=== Paso 5: Generar mapas en CRU
=== Paso 6: Generar Geoportal
=== Paso 7: Añadir entidades al Geoportal
=== Paso 8: Añadir capas base al Geoportal
=== Paso 9: Añadir herramientas al Geoportal
=== Paso 10: Funcionalidades avanzadas
==== Filtrar Datos utilizando Datatables
==== Selección de Datos utilizando Datatables
==== Agrupación de elementos en Geoportal

== gvNIX Add-Ons

// Push titles down one level.
:leveloffset: 1
include::addon-web-menu.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-jpa.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-monitoring.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc-bootstrap.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc-datatables.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc-geo.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc-loupe.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-occ.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-dialog.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-report.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-service.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-i18n.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-dynamic-config.adoc[]

// Push titles down one level.
:leveloffset: 1
include::addon-web-mvc-binding.adoc[]

== Apéndices

En este capitulo se recoge información adicional sobre todo lo comentado 
en las secciones anteriores así como un apéndice de todos los comandos disponibles 
en la herramienta de desarrollo gvNIX.

// Push titles down one level.
:leveloffset: 1
include::apendice-comandos.adoc[]

// Push titles down one level.
:leveloffset: 1
include::guia-desarrollo_eclipse.adoc[]

// Push titles down one level.
:leveloffset: 1
include::recetas.adoc[]

// Push titles down one level.
:leveloffset: 1
include::guia-desarrollo_generacion-codigo.adoc[]

// Push titles down one level.
:leveloffset: 1
include::guia-desarrollo_mejoras-rendimiento.adoc[]


== Recursos

// Push titles down one level.
:leveloffset: 1
include::recursos.adoc[]
