diff --git a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/JavaParserMutableClassOrInterfaceTypeDetails.java b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/JavaParserMutableClassOrInterfaceTypeDetails.java
index 81ee290..5d9edf6 100644
--- a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/JavaParserMutableClassOrInterfaceTypeDetails.java
+++ b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/JavaParserMutableClassOrInterfaceTypeDetails.java
@@ -513,12 +513,12 @@ public class JavaParserMutableClassOrInterfaceTypeDetails implements MutableClas
 
         // Add constructors
         for (ConstructorMetadata candidate : cit.getDeclaredConstructors()) {
-        	JavaParserConstructorMetadata.addConstructor(compilationUnitServices, typeDeclaration.getMembers(), candidate, false, null);
+        	JavaParserConstructorMetadata.addConstructor(compilationUnitServices, typeDeclaration.getMembers(), candidate, false, new HashSet<JavaSymbolName>());
         }
 
         // Add methods
         for (MethodMetadata candidate : cit.getDeclaredMethods()) {
-        	JavaParserMethodMetadata.addMethod(compilationUnitServices, typeDeclaration.getMembers(), candidate, false, null);
+        	JavaParserMethodMetadata.addMethod(compilationUnitServices, typeDeclaration.getMembers(), candidate, false, new HashSet<JavaSymbolName>());
         }
         
 		return compilationUnit.toString();
diff --git a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserConstructorMetadata.java b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserConstructorMetadata.java
index 91542a2..0ca06ef 100644
--- a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserConstructorMetadata.java
+++ b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserConstructorMetadata.java
@@ -248,7 +248,9 @@ public class JavaParserConstructorMetadata implements ConstructorMetadata {
 					// Possible match, we need to consider parameter types as well now
 					JavaParserConstructorMetadata jpmm = new JavaParserConstructorMetadata(constructor.getDeclaredByMetadataId(), cd, compilationUnitServices, typeParameters);
 					boolean matchesFully = true;
-					for (AnnotatedJavaType existingParameter : jpmm.getParameterTypes()) {
+                                        index = -1;
+                                        for (AnnotatedJavaType existingParameter : jpmm.getParameterTypes()) {
+                                                index++;
 						if (!existingParameter.getJavaType().equals(constructor.getParameterTypes().get(index))) {
 							matchesFully = false;
 							break;
diff --git a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserMethodMetadata.java b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserMethodMetadata.java
index 63b6247..ad27e15 100644
--- a/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserMethodMetadata.java
+++ b/classpath-javaparser/src/main/java/org/springframework/roo/classpath/javaparser/details/JavaParserMethodMetadata.java
@@ -33,16 +33,15 @@ import org.springframework.roo.model.JavaSymbolName;
 import org.springframework.roo.model.JavaType;
 import org.springframework.roo.support.style.ToStringCreator;
 import org.springframework.roo.support.util.Assert;
+import org.springframework.roo.support.util.StringUtils;
 
 /**
  * Java Parser implementation of {@link MethodMetadata}.
  * 
  * @author Ben Alex
  * @since 1.0
- *
  */
 public class JavaParserMethodMetadata implements MethodMetadata {
-
 	private List<AnnotationMetadata> annotations = new ArrayList<AnnotationMetadata>();
 	private List<AnnotatedJavaType> parameterTypes = new ArrayList<AnnotatedJavaType>();
 	private List<JavaSymbolName> parameterNames = new ArrayList<JavaSymbolName>();
@@ -104,7 +103,8 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 		
 		if (methodDeclaration.getThrows() != null) {
 			for (NameExpr throwsType: methodDeclaration.getThrows()) {
-				throwsTypes.add(new JavaType(JavaParserUtils.getClassOrInterfaceType(throwsType).getName()));
+				JavaType throwing = JavaParserUtils.getJavaType(compilationUnitServices, throwsType, fullTypeParameters);
+				throwsTypes.add(throwing);
 			}
 		}
 		
@@ -113,7 +113,6 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 				this.annotations.add(new JavaParserAnnotationMetadata(annotation, compilationUnitServices));
 			}
 		}
-		
 	}
 
 	public int getModifier() {
@@ -160,6 +159,7 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 		tsc.append("parameterTypes", parameterTypes);
 		tsc.append("parameterNames", parameterNames);
 		tsc.append("returnType", returnType);
+		tsc.append("throwsTypes", throwsTypes);
 		tsc.append("annotations", annotations);
 		tsc.append("body", body);
 		return tsc.toString();
@@ -187,8 +187,8 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 				List<Type> typeArgs = new ArrayList<Type>();
 				cit.setTypeArgs(typeArgs);
 				for (JavaType parameter : method.getReturnType().getParameters()) {
-					//NameExpr importedParameterType = JavaParserUtils.importTypeIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), parameter);
-					//typeArgs.add(JavaParserUtils.getReferenceType(importedParameterType));
+					// NameExpr importedParameterType = JavaParserUtils.importTypeIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), parameter);
+					// typeArgs.add(JavaParserUtils.getReferenceType(importedParameterType));
 					typeArgs.add(JavaParserUtils.importParametersForType(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), parameter));
 				}
 			}
@@ -255,24 +255,24 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 				parameterType = cit;
 			}
 
-			// Add exceptions which the method my throw
-			if (method.getThrowsTypes().size() > 0) {
-				List<NameExpr> throwsTypes = new ArrayList<NameExpr>();
-				for (JavaType javaType: method.getThrowsTypes()) {
-					NameExpr importedType = JavaParserUtils.importTypeIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), javaType);
-					throwsTypes.add(importedType);
-				}
-				d.setThrows(throwsTypes);
-			}
-			
 			// Create a Java Parser method parameter and add it to the list of parameters
 			Parameter p = new Parameter(parameterType, new VariableDeclaratorId(parameterName));
 			p.setAnnotations(parameterAnnotations);
 			parameters.add(p);
 		}
 		
+		// Add exceptions which the method my throw
+		if (method.getThrowsTypes().size() > 0) {
+			List<NameExpr> throwsTypes = new ArrayList<NameExpr>();
+			for (JavaType javaType: method.getThrowsTypes()) {
+				NameExpr importedType = JavaParserUtils.importTypeIfRequired(compilationUnitServices.getEnclosingTypeName(), compilationUnitServices.getImports(), javaType);
+				throwsTypes.add(importedType);
+			}
+			d.setThrows(throwsTypes);
+		}
+		
 		// Set the body
-		if (method.getBody() == null || method.getBody().length() == 0) {
+		if (!StringUtils.hasText(method.getBody())) {
 			// Never set the body if an abstract method
 			if (!Modifier.isAbstract(method.getModifier())) {
 				d.setBody(new BlockStmt());
@@ -317,18 +317,25 @@ public class JavaParserMethodMetadata implements MethodMetadata {
 			if (bd instanceof MethodDeclaration) {
 				// Next method should appear after this current method
 				MethodDeclaration md = (MethodDeclaration) bd;
-				if (md.getName().equals(d.getName()) && md.getParameters().size() == d.getParameters().size()) {
-					// Possible match, we need to consider parameter types as well now
-					JavaParserMethodMetadata jpmm = new JavaParserMethodMetadata(method.getDeclaredByMetadataId(), md, compilationUnitServices, typeParameters);
-					boolean matchesFully = true;
-					for (AnnotatedJavaType existingParameter : jpmm.getParameterTypes()) {
-						if (!existingParameter.getJavaType().equals(method.getParameterTypes().get(index))) {
-							matchesFully = false;
-							break;
+				if (md.getName().equals(d.getName())) {
+					if ((md.getParameters() == null || md.getParameters().isEmpty()) && (d.getParameters() == null || d.getParameters().isEmpty())) {
+						throw new IllegalStateException("Method '" + method.getMethodName().getSymbolName() + "' already exists");
+					} else if (md.getParameters() != null && md.getParameters().size() == d.getParameters().size()) {
+						// Possible match, we need to consider parameter types as well now
+						JavaParserMethodMetadata jpmm = new JavaParserMethodMetadata(method.getDeclaredByMetadataId(), md, compilationUnitServices, typeParameters);
+						boolean matchesFully = true;
+						index = -1;
+						for (AnnotatedJavaType existingParameter : jpmm.getParameterTypes()) {
+							index++;
+							AnnotatedJavaType parameterType = method.getParameterTypes().get(index);
+							if (!existingParameter.getJavaType().equals(parameterType.getJavaType())) {
+								matchesFully = false;
+								break;
+							}
+						}
+						if (matchesFully) {
+							throw new IllegalStateException("Method '" + method.getMethodName().getSymbolName() + "' already exists with identical parameters");
 						}
-					}
-					if (matchesFully) {
-						throw new IllegalStateException("Method '" + method.getMethodName().getSymbolName() + "' already exists with identical parameters");
 					}
 				}
 			}
diff --git a/classpath/src/main/java/org/springframework/roo/classpath/details/AnnotationMetadataUtils.java b/classpath/src/main/java/org/springframework/roo/classpath/details/AnnotationMetadataUtils.java
index fb46586..bd8541a 100644
--- a/classpath/src/main/java/org/springframework/roo/classpath/details/AnnotationMetadataUtils.java
+++ b/classpath/src/main/java/org/springframework/roo/classpath/details/AnnotationMetadataUtils.java
@@ -10,6 +10,7 @@ import org.springframework.roo.classpath.details.annotations.DoubleAttributeValu
 import org.springframework.roo.classpath.details.annotations.EnumAttributeValue;
 import org.springframework.roo.classpath.details.annotations.IntegerAttributeValue;
 import org.springframework.roo.classpath.details.annotations.LongAttributeValue;
+import org.springframework.roo.classpath.details.annotations.NestedAnnotationAttributeValue;
 import org.springframework.roo.classpath.details.annotations.StringAttributeValue;
 import org.springframework.roo.model.EnumDetails;
 import org.springframework.roo.model.ImportRegistrationResolver;
@@ -21,8 +22,8 @@ import org.springframework.roo.support.util.Assert;
  * Utilities to use with {@link AnnotationMetadata}.
  * 
  * @author Ben Alex
+ * @author Alan Stewart
  * @since 1.0
- *
  */
 public abstract class AnnotationMetadataUtils {
 
@@ -35,7 +36,7 @@ public abstract class AnnotationMetadataUtils {
 	public static final String toSourceForm(AnnotationMetadata annotation) {
 		return toSourceForm(annotation, null);
 	}
-	
+
 	/**
 	 * Converts the annotation into a string-based form.
 	 * 
@@ -45,10 +46,10 @@ public abstract class AnnotationMetadataUtils {
 	 */
 	public static final String toSourceForm(AnnotationMetadata annotation, ImportRegistrationResolver resolver) {
 		Assert.notNull(annotation, "Annotation required");
-		
+
 		StringBuilder sb = new StringBuilder();
 		sb.append("@");
-		
+
 		if (resolver != null) {
 			if (resolver.isFullyQualifiedFormRequiredAfterAutoImport(annotation.getAnnotationType())) {
 				sb.append(annotation.getAnnotationType().getFullyQualifiedTypeName());
@@ -58,11 +59,11 @@ public abstract class AnnotationMetadataUtils {
 		} else {
 			sb.append(annotation.getAnnotationType().getFullyQualifiedTypeName());
 		}
-		
+
 		if (annotation.getAttributeNames().size() == 0) {
 			return sb.toString();
 		}
-		
+
 		sb.append("(");
 		boolean requireComma = false;
 		for (JavaSymbolName attributeName : annotation.getAttributeNames()) {
@@ -71,12 +72,12 @@ public abstract class AnnotationMetadataUtils {
 				sb.append(", ");
 				requireComma = false;
 			}
-			
+
 			// Compute the value
 			AnnotationAttributeValue<? extends Object> value = annotation.getAttribute(attributeName);
-			
+
 			String attributeValue = computeAttributeValue(value, resolver);
-			
+
 			if (attributeValue != null) {
 				// We have a supported attribute
 				if (!"value".equals(attributeName.getSymbolName()) || annotation.getAttributeNames().size() > 1) {
@@ -94,12 +95,12 @@ public abstract class AnnotationMetadataUtils {
 	private static String computeAttributeValue(AnnotationAttributeValue<? extends Object> value, ImportRegistrationResolver resolver) {
 		String attributeValue = null;
 		if (value instanceof BooleanAttributeValue) {
-			attributeValue = ((BooleanAttributeValue)value).getValue().toString();
+			attributeValue = ((BooleanAttributeValue) value).getValue().toString();
 		} else if (value instanceof CharAttributeValue) {
-			attributeValue = "'" + ((CharAttributeValue)value).getValue().toString() + "'";
+			attributeValue = "'" + ((CharAttributeValue) value).getValue().toString() + "'";
 		} else if (value instanceof ClassAttributeValue) {
-			JavaType clazz = ((ClassAttributeValue)value).getValue();
-			if (resolver.isFullyQualifiedFormRequiredAfterAutoImport(clazz)) {
+			JavaType clazz = ((ClassAttributeValue) value).getValue();
+			if (resolver == null || resolver.isFullyQualifiedFormRequiredAfterAutoImport(clazz)) {
 				attributeValue = clazz.getFullyQualifiedTypeName() + ".class";
 			} else {
 				attributeValue = clazz.getSimpleTypeName() + ".class";
@@ -112,22 +113,45 @@ public abstract class AnnotationMetadataUtils {
 				attributeValue = dbl.getValue().toString() + "D";
 			}
 		} else if (value instanceof EnumAttributeValue) {
-			EnumDetails enumDetails = ((EnumAttributeValue)value).getValue();
+			EnumDetails enumDetails = ((EnumAttributeValue) value).getValue();
 			JavaType clazz = enumDetails.getType();
-			if (resolver.isFullyQualifiedFormRequiredAfterAutoImport(clazz)) {
+			if (resolver == null || resolver.isFullyQualifiedFormRequiredAfterAutoImport(clazz)) {
 				attributeValue = clazz.getFullyQualifiedTypeName() + "." + enumDetails.getField().getSymbolName();
 			} else {
 				attributeValue = clazz.getSimpleTypeName() + "." + enumDetails.getField().getSymbolName();
 			}
 		} else if (value instanceof IntegerAttributeValue) {
-			attributeValue = ((IntegerAttributeValue)value).getValue().toString();
+			attributeValue = ((IntegerAttributeValue) value).getValue().toString();
 		} else if (value instanceof LongAttributeValue) {
-			attributeValue = ((LongAttributeValue)value).getValue().toString() + "L";
+			attributeValue = ((LongAttributeValue) value).getValue().toString() + "L";
 		} else if (value instanceof StringAttributeValue) {
-			attributeValue = "\"" + ((StringAttributeValue)value).getValue() + "\"";
+			attributeValue = "\"" + ((StringAttributeValue) value).getValue() + "\"";
+		} else if (value instanceof NestedAnnotationAttributeValue) {
+			AnnotationMetadata annotationMetadata = ((NestedAnnotationAttributeValue) value).getValue();
+			StringBuilder data = new StringBuilder("@");
+			JavaType annotationType = annotationMetadata.getAnnotationType();
+			if (resolver == null || resolver.isFullyQualifiedFormRequiredAfterAutoImport(annotationType)) {
+				data.append(annotationType.getFullyQualifiedTypeName());
+			} else {
+				data.append(annotationType.getSimpleTypeName());
+			}
+			if (!annotationMetadata.getAttributeNames().isEmpty()) {
+				data.append("(");
+				int i = 0;
+				for (JavaSymbolName attributeName : annotationMetadata.getAttributeNames()) {
+					i++;
+					if (i > 1) {
+						data.append(", ");
+					}
+					data.append(attributeName.getSymbolName()).append(" = ");
+					data.append(computeAttributeValue(annotationMetadata.getAttribute(attributeName), resolver));
+				}
+				data.append(")");
+			}
+			attributeValue = data.toString();
 		} else if (value instanceof ArrayAttributeValue<?>) {
 			ArrayAttributeValue<?> array = (ArrayAttributeValue<?>) value;
-			StringBuilder data = new StringBuilder();
+			StringBuilder data = new StringBuilder("{ ");
 			int i = 0;
 			for (AnnotationAttributeValue<? extends Object> val : array.getValue()) {
 				i++;
@@ -136,8 +160,10 @@ public abstract class AnnotationMetadataUtils {
 				}
 				data.append(computeAttributeValue(val, resolver));
 			}
-			attributeValue = "{" + data.toString() + "}";
+			data.append(" }");
+			attributeValue = data.toString();
 		}
+
 		return attributeValue;
 	}
 }
diff --git a/classpath/src/main/java/org/springframework/roo/classpath/itd/AbstractItdMetadataProvider.java b/classpath/src/main/java/org/springframework/roo/classpath/itd/AbstractItdMetadataProvider.java
index e4d12d4..d21ccd3 100644
--- a/classpath/src/main/java/org/springframework/roo/classpath/itd/AbstractItdMetadataProvider.java
+++ b/classpath/src/main/java/org/springframework/roo/classpath/itd/AbstractItdMetadataProvider.java
@@ -245,7 +245,7 @@ public abstract class AbstractItdMetadataProvider implements ItdRoleAwareMetadat
 		}
 		
 		// Cancel production if the governor is not a class, and the subclass only wants to know about classes
-		if (cid != null && dependsOnGovernorBeingAClass && cid.getPhysicalTypeCategory() != PhysicalTypeCategory.CLASS) {
+		if (cid != null && dependsOnGovernorBeingAClass && cid.getPhysicalTypeCategory() != PhysicalTypeCategory.CLASS && cid.getPhysicalTypeCategory() != PhysicalTypeCategory.ENUMERATION) {
 			produceMetadata = false;
 		}
 		
diff --git a/model/src/main/java/org/springframework/roo/model/JavaType.java b/model/src/main/java/org/springframework/roo/model/JavaType.java
index f1fa2a0..3c3f500 100644
--- a/model/src/main/java/org/springframework/roo/model/JavaType.java
+++ b/model/src/main/java/org/springframework/roo/model/JavaType.java
@@ -114,7 +114,7 @@ public final class JavaType implements Comparable<JavaType>, Cloneable {
 			int offset = fullyQualifiedTypeName.lastIndexOf(".");
 			simpleTypeName = fullyQualifiedTypeName.substring(offset+1);
 		}
-		if (!Character.isUpperCase(simpleTypeName.charAt(0))) {
+		if (!Character.isUpperCase(simpleTypeName.charAt(0)) && !StringUtils.startsWithIgnoreCase(simpleTypeName, "package-info")) {
 			// Doesn't start with an uppercase letter, so let's verify it starts with an underscore and then an uppercase
 			if (simpleTypeName.length() < 2 || !Character.isUpperCase(simpleTypeName.charAt(1)) || '_' != simpleTypeName.charAt(0)) {
 				throw new IllegalArgumentException("The first letter of the type name portion must be uppercase (attempted '" + fullyQualifiedTypeName + "')");
diff --git a/pom.xml b/pom.xml
index 63c3854..432738e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -213,6 +213,7 @@
             <plugin>
                 <groupId>org.codehaus.mojo</groupId>
                 <artifactId>exec-maven-plugin</artifactId>
+                <version>1.1.1</version>
                 <executions>
                     <execution>
                         <phase>generate-resources</phase>
