<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="guia-desarrollo"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Desarrollo de aplicaciones con gvNIX</title>

  <xi:include href="guia-desarrollo_aplicacion-base.xml" />

  <section xml:id="guia-desarrollo_gestion-acceso-datos">
    <title xml:lang="es">Gestión de acceso a datos</title>

    <para xml:lang="es">En lo ejemplos que han aparecido hasta ahora se han
    estado usando bases de datos que se encuentran definidas en memoria y se
    recrean cada vez que arrancamos la aplicación.</para>

    <para xml:lang="es">El framework admite múltiples tipos de base de datos,
    entre ellas:</para>

    <itemizedlist>
      <listitem>
        <para>PostgreSQL</para>
      </listitem>

      <listitem>
        <para>MySQL</para>
      </listitem>

      <listitem>
        <para>Oracle</para>
      </listitem>

      <listitem>
        <para>SYBASE</para>
      </listitem>

      <listitem>
        <para>Microsoft SQL Server</para>
      </listitem>

      <listitem>
        <para>DB2</para>
      </listitem>

      <listitem>
        <para>HSQLDB (en memoria o persistente)</para>
      </listitem>

      <listitem>
        <para>H2 en memoria</para>
      </listitem>
    </itemizedlist>

    <para xml:lang="es">Y múltiples librerías de mapeo de objetos a bases de
    datos relacionales (<link
    xlink:href="http://es.wikipedia.org/wiki/Mapeo_objeto-relacional">ORM</link>):</para>

    <itemizedlist>
      <listitem>
        <para>Hibernate</para>
      </listitem>

      <listitem>
        <para>EclipseLink</para>
      </listitem>

      <listitem>
        <para>OpenJPA</para>
      </listitem>
    </itemizedlist>

    <para xml:lang="es">Toda esta configuración se realiza mediante comandos
    de la consola y en cualquier momento. Por ello, una opción interesante es
    usar para desarrollo una de las bases de datos que residen en memoria para
    las primeras fases del desarrollo. Luego migrar es posible migrar a otra
    base de datos persistente.</para>

    <section>
      <title>Comandos de configuración del acceso a datos</title>

      <para>Para hacer la configuración se usan los siguientes
      comandos:</para>

      <itemizedlist>
        <listitem>
          <para><command>persistence setup</command></para>
        </listitem>

        <listitem>
          <para><command>database properties</command></para>
        </listitem>
      </itemizedlist>

      <section>
        <title><command>persistence setup</command></title>

        <para xml:lang="es">Este permite la configuración del acceso a datos.
        Entre los parámetros necesitaremos el proveedor de ORM y la base de
        datos a usar.</para>

        <para xml:lang="es">Los parámetros que admite este comando son:</para>

        <variablelist>
          <varlistentry>
            <term>--provider</term>

            <listitem>
              <para xml:lang="es">Proveedor de ORM a usar. Este comando admite
              autocompletado. Los valores posibles son:</para>

              <variablelist>
                <varlistentry>
                  <term>DATANUCLEUS</term>

                  <listitem>
                    <para><link xlink:href="http://www.datanucleus.org/">Data
                    Nucleus</link></para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>ECLIPSELINK</term>

                  <listitem>
                    <para><link
                    xlink:href="http://www.eclipse.org/eclipselink/">EclipseLink</link></para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>HIBERNATE</term>

                  <listitem>
                    <para><link
                    xlink:href="http://www.hibernate.org/">Hibernate</link></para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term>OPENJPA</term>

                  <listitem>
                    <para><link
                    xlink:href="http://openjpa.apache.org/">OpenJPA</link></para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--database</term>

            <listitem>
              <para xml:lang="es">Tipo de base de datos a usar. Este comando
              admite autocompletado. Los valores posible son:</para>

              <itemizedlist>
                <listitem>
                  <para>DB2 <emphasis>(Hay que instalar manualmente el driver
                  JDBC)</emphasis></para>
                </listitem>

                <listitem>
                  <para>DERBY</para>
                </listitem>

                <listitem>
                  <para>GOOGLE_APP_ENGINE</para>
                </listitem>

                <listitem>
                  <para>H2_IN_MEMORY</para>
                </listitem>

                <listitem>
                  <para>HYPERSONIC_IN_MEMORY</para>
                </listitem>

                <listitem>
                  <para>HYPERSONIC_PERSISTENT</para>
                </listitem>

                <listitem>
                  <para>MSSQL</para>
                </listitem>

                <listitem>
                  <para>ORACLE <emphasis>(Hay que instalar manualmente el
                  driver JDBC)</emphasis></para>
                </listitem>

                <listitem>
                  <para>POSTGRES</para>
                </listitem>

                <listitem>
                  <para>SYBASE</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--applicationId</term>

            <listitem>
              <para xml:lang="es">Identificación de aplicación en Google App
              Engine (sólo usado para esta base de datos).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--jndiDataSource</term>

            <listitem>
              <para xml:lang="es">Fuente de datos JNDI a usar.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--databaseName</term>

            <listitem>
              <para xml:lang="es">Nombre de la base de datos.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--userName</term>

            <listitem>
              <para xml:lang="es">Nombre del usuario para la conexión.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>--password</term>

            <listitem>
              <para xml:lang="es">Contraseña del usuario de la
              conexión.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para xml:lang="es">Dependiendo del tipo de base de datos podemos
        puede ser necesarios unos u otros parámetros y puede o no ser
        necesario instrucciones adiciones para la configuración del acceso a
        datos.</para>
      </section>

      <section>
        <title><command>database properties</command></title>

        <para xml:lang="es">Este conjunto de instrucciones permiten la
        consulta, eliminación y actualización de las propiedades de conexión a
        la BBDD. Estas propiedades se almacenan el fichero
        <filename>src/main/resources/META-INF/spring/database.properties</filename>
        de la aplicación.</para>

        <para xml:lang="es">Sus variantes son:</para>

        <variablelist>
          <varlistentry>
            <term>database properties list</term>

            <listitem>
              <para xml:lang="es">Lista las propiedades de configuración de la
              base de datos.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>database properties remove</term>

            <listitem>
              <para xml:lang="es">Elimina una propiedad de la configuración.
              Requiere un único parámetro <parameter>--key</parameter> para
              especificar la clave a eliminar.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>database properties set</term>

            <listitem>
              <para xml:lang="es">Crea o actualiza una de las propiedades la
              configuración. Requiere un parámetro
              <parameter>--key</parameter> con el nombre de la propiedad y un
              <parameter>--value</parameter> con el valor a establecer.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title>Ejemplo de configuración de acceso a datos a PostgreSQL</title>

      <para xml:lang="es">En este ejemplo vamos a configurar la conexión a un
      servidor PostgreSQL en una máquina en nuestra red local. Los datos de
      conexión de ejemplo serán:</para>

      <itemizedlist>
        <listitem>
          <para xml:lang="es">Servidor de base de datos:
          <literal>dbserver</literal></para>
        </listitem>

        <listitem>
          <para xml:lang="rd">Puerto de conexión:
          <literal>5438</literal></para>
        </listitem>

        <listitem>
          <para>Nombre de la base de datos: <literal>my_db</literal></para>
        </listitem>

        <listitem>
          <para xml:lang="es">Nombre de usuario de la base de datos:
          <literal>user1</literal></para>
        </listitem>

        <listitem>
          <para xml:lang="es">Contraseña del usuario:
          <literal>1234</literal></para>
        </listitem>
      </itemizedlist>

      <para xml:lang="es">Hay que recordar que estos comando se pueden
      realizar en cualquier momento.</para>

      <para xml:lang="es">Los pasos a seguir para la configuración son:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Usar el comando <command>persistence
          setup</command> con los parámetros que disponemos:</para>

          <programlisting>roo&gt; <command>persistence setup --provider HIBERNATE --database POSTGRES --databaseName my_db --userName user1 --password 1234</command>
Created SRC_MAIN_RESOURCES/META-INF/persistence.xml
Please enter your database details in src/main/resources/META-INF/spring/database.properties.
Created SRC_MAIN_RESOURCES/META-INF/spring/database.properties
Managed SRC_MAIN_RESOURCES/META-INF/spring/applicationContext.xml
Managed ROOT/pom.xml ...
roo&gt; </programlisting>

          <para xml:lang="es">Podemos observar que ya se nos sugiere que es
          necesario actualizar el fichero
          <filename>database.properties</filename>. Esto es debido a que el
          comando no contempla todas las opciones necesarias para completar la
          configuración.</para>
        </listitem>

        <listitem>
          <para xml:lang="es">Comprobar como ha quedado la configuración de la
          conexión. Para ello usar el comando <command>database properties
          list</command>:</para>

          <programlisting>roo&gt; <command>database properties list</command>
database.driverClassName = org.postgresql.Driver
database.password = 1234
database.url = jdbc:postgresql://localhost:5432/my_db
database.username = user1
roo&gt; </programlisting>

          <para>Podemos observar que lo único que nos falta es configurar el
          servidor y el puerto de la base de datos en la propiedad
          <literal>database.url</literal>.</para>
        </listitem>

        <listitem>
          <para xml:lang="es">Configurar la URL de conexión a servidor
          correctamente usando el comando <command>database properties
          set</command>:</para>

          <programlisting>roo&gt; <command>database properties set --key database.url --value jdbc:postgresql://dbserver:5438/my_db </command>
Managed SRC_MAIN_RESOURCES/META-INF/spring/database.properties
roo&gt; </programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Volver a comprobar el estado de los parámetros
          con el comando <command>database properties list</command>:</para>

          <programlisting>roo&gt; <command>database properties list</command>
database.driverClassName = org.postgresql.Driver
database.password = 1234
database.url = jdbc:postgresql://dbserver:5438/my_db
database.username = user1
roo&gt; </programlisting>
        </listitem>
      </orderedlist>

      <para xml:lang="es">Una vez hecho, la siguiente vez que arranquemos la
      aplicación usará la base de datos que le hemos configurado. Es
      recomendable la lectura de la sección <link
      linkend="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente">Enlazar
      modelo de entidades con base de datos existente</link>.</para>

      <warning>
        <para xml:lang="es"><emphasis role="bold">Por defecto las aplicaciones
        de Spring Roo se configuran para que la Base de datos se regenere cada
        vez que se arranca la aplicación (borrando y creando de nuevo las
        tablas), por lo que es conveniente que si se utiliza una Base de datos
        preexistente se configure correctamente el fichero
        <filename>src/main/resources/META-INF/persistence.xml</filename> para
        evitar sorpresas desagradables. Más información <link
        linkend="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_regeneracion-bbdd">aquí</link>.</emphasis></para>
      </warning>
    </section>

    <section xml:id="guia-desarrollo_gestion-acceso-datos_multiples-fuentes-datos">
      <title xml:lang="es">Múltiples fuentes de datos</title>

      <para><emphasis role="bold">TBC</emphasis></para>

      <para>En este <link
      xlink:href="http://forum.springsource.org/showpost.php?p=289577&amp;postcount=4">post
      del foro de Spring Roo</link> tenemos un ejemplo de los cambios a
      realizar en nuestra aplicación para que las entidades tenga distintas
      fuentes de datos.</para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades">
    <title xml:lang="es">Gestión de entidades</title>

    <para xml:lang="es">En Spring Roo el artefacto que define la unidad de
    dato es la <classname>Entidad</classname> o <classname>Entity</classname>.
    En este artefacto se definirán los atributos que la componen y los
    servicios (o reglas de negocio) que ofrece para manejarla al resto de las
    entidades o de la aplicación. Por ello es una pieza clave de la
    aplicación.</para>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion">
      <title xml:lang="es">Definición de una entidad</title>

      <para xml:lang="es">Una entidad se define en una clase
      <filename>.java</filename> con una serie de anotaciones de Roo y de JPA.
      Estas anotaciones automatizan comportamiento (sobre todo las de Roo
      añadiendo accesores/mutadores automáticos por ejemplo) y su persistencia
      (las de JPA como las nombre de tabla).</para>

      <para xml:lang="es">Además de las anotaciones de clase, se definen
      propiedades (variables de instancia) que almacenarán la información de
      la entidad. Estas propiedades también pueden llevar anotaciones de JPA
      (para modificar el nombre o tamaño de campo, definir una relación con
      una entidad, etc) y/o otras como las de validación (<link
      xlink:href="http://jcp.org/en/jsr/detail?id=303">JSR 303</link>).</para>

      <para xml:lang="es">Luego, se completa con todos aquellos métodos
      específico de las reglas de negocio de la entidad.</para>

      <para xml:lang="es">En principio, gvNIX nos añadirá todos los métodos
      estándar necesarios para completar la definición de entidad, como los de
      persistencia (almacenamiento y recuperación). Esto se completa usando la
      librería AspectJ y sus ITD. Un ITD es un conjunto de definiciones de una
      clase java que se extraen del propio fichero de forma de que en el .java
      sólo vemos lo fundamental. Luengo, en tiempo de compilación estos
      elementos se incrustarán en la clase final de forma transparente.
      Podemos ver esto elemento en unos ficheros llamados
      <filename>*_Roo_*.aj</filename> que se generan junto al fichero
      <filename>.java</filename> al que hacen referencia.</para>

      <para xml:lang="es">Si por algún motivo necesitamos <emphasis
      role="bold">personalizar el comportamiento</emphasis> de alguno de los
      <emphasis role="bold">métodos estándar que genera Roo</emphasis>,
      simplemente tenemos que <emphasis role="bold">definirlos en el en la
      clase java</emphasis> y, cuando el framework detecte el cambio, en el
      fichero <filename>*_Roo_*.aj</filename> afectado dejara de aparecer esta
      definición.</para>

      <para xml:lang="es">Las características de una
      <classname>Entity</classname> son:</para>

      <itemizedlist>
        <listitem>
          <para xml:lang="es">Tiene un identificador único.</para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene (opcionalmente) un campo de gestión de concurrencia de
          forma optimista.<footnote>
              <para>Ver el <link
              linkend="addon-persistence_occchecksum">OCCCheckSum</link> en el
              <link linkend="addon-persistence">Add-on
              Persistence</link></para>
            </footnote></para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene implementados los métodos para almacenarse y recuperarse
          de la fuente de datos.</para>
        </listitem>

        <listitem>
          <para>Genera de forma automática los <emphasis>accesores</emphasis>
          y <emphasis>mutadores</emphasis> (<emphasis>getters</emphasis> y
          <emphasis>setters</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <para xml:lang="es">Para generar una entidad podemos optar por dos
      mecanismos:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Usando los comandos de consola
          (<emphasis>recomendado</emphasis>).</para>
        </listitem>

        <listitem>
          <para xml:lang="es">Creando una clase a mano.</para>
        </listitem>
      </orderedlist>

      <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando">
        <title xml:lang="es">Crear una Entidad usando comandos</title>

        <para xml:lang="es">Desde la consola del framework podemos crear
        entidades de forma sencilla. Para ello tenemos disponibles dos
        comandos:</para>

        <itemizedlist>
          <listitem>
            <para xml:lang="es">El comando <command>entity</command>.</para>
          </listitem>

          <listitem>
            <para xml:lang="es">El comando <command>field</command>.</para>
          </listitem>
        </itemizedlist>

        <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_entity">
          <title xml:lang="es">El comando <command>entity</command></title>

          <para xml:lang="es">Este comando crea una nueva entidad en nuestro
          proyecto. Requiere como mínimo definir el parámetro
          <parameter>--class</parameter> para especificar el nombre y el
          paquete de na nueva entidad. En este parámetro podemos utilizar el
          carácter <literal>~</literal> como abreviatura de el paquete base
          del proyecto.</para>

          <para xml:lang="es">Entre los parámetros disponibles podemos
          destacar:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para la entidad
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierType</term>

              <listitem>
                <para xml:lang="es">Permite definir el tipo (clase java) de
                identificador (clave primaria) que usará esta entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre del <emphasis>campo en la
                entidad</emphasis> (no en BBDD) que se usará para el
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>columna de la
                BBDD</emphasis> donde almacenar el valor de clave
                primaria.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--table</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>tabla de la
                BBDD</emphasis> donde almacenar los datos para esta
                entidad.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">El resto de las opciones podemos verlas usando
          el autocompletado de la consola de roo o usando el comando
          <command>help entity</command>.</para>

          <para xml:lang="es">Existen más opciones para configurar la entidad,
          aunque no todos se pueden especificar usando este comando. Ver el
          apartado <link
          linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-rooentity">Anotación
          RooEntity</link>.</para>
        </section>

        <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field">
          <title xml:lang="es">El comando <command>field</command></title>

          <para xml:lang="es">No existe un comando <command>field</command>
          propiamente dicho, pero es el nombre de un grupo de comando para
          añadir campos a una entidad. Los comandos finales se forma con el
          <command>field {tipo}</command> donde <parameter>{tipo}</parameter>
          es el tipo de dato que va almacenar. Así tenemos los
          siguientes:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">field string</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo cadena.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field boolean</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo booleano.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field date</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo fecha.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field email template</term>

              <listitem xml:lang="es">
                <para>Crea un campo con una plantilla preparada para almacenar
                direcciones de correo electrónico.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field enum</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo enumerado.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field number</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo numérico (es posible especificarle
                el tipo mediante el parámetro
                <parameter>--type</parameter>).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field reference</term>

              <listitem xml:lang="es">
                <para>Crea un campo que será una referencia a otra
                entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field set</term>

              <listitem xml:lang="es">
                <para>Crea un campo que devolverá una lista de elementos de
                una entidad relacionados con este elemento.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field other</term>

              <listitem xml:lang="es">
                <para>Crea un campo de otro tipo no registrado.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Cada uno de estos comandos admiten algunos parámetros que son
          comunes entre ellos o muy específicos. Entre los comunes (para la
          mayoría) podemos encontrar los siguientes:</para>

          <variablelist>
            <varlistentry>
              <term>--fieldName</term>

              <listitem>
                <para xml:lang="es">Nombre del campo que vamos a
                generar.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--class</term>

              <listitem>
                <para xml:lang="es">Clase entidad donde vamos a crear el
                campo. Admite el uso de <literal>~</literal> y tiene
                autocompletado. No es necesario especificar si acabamos de
                crear una entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--notNull y --nullRequired</term>

              <listitem>
                <para xml:lang="es">Especifica el comportamiento de campo
                antes los valores nulos.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--column</term>

              <listitem>
                <para xml:lang="es">Nombre de la columna en BBDD donde se
                almacenará el valor.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--sizeMax y --sizeMin</term>

              <listitem>
                <para xml:lang="es">Limitaciones de tamaño.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Existe mas opciones dependiendo del tipo de
          dato, para mas información ver la ayuda de la consola.</para>

          <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field_ejemplos">
            <title xml:lang="es">Ejemplos</title>

            <para xml:lang="es">Estos son algunos ejemplos de creación de
            campos:</para>

            <orderedlist>
              <listitem>
                <para xml:lang="es">Campo cadena con validaciones:</para>

                <programlisting>roo&gt; <command>field string --fieldName nombre --notNull --sizeMax 50 --sizeMin 1 --comment "Nombre del pais" --column pais_nombre --regexp [A-Z].*</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @NotNull
    @Column(name = "pais_nombre")
    @Size(min = 1, max = 50)
    @Pattern(regexp = "[A-Z].*")
    private String nombre;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con referencia a otra entidad
                (muchos a uno):</para>

                <programlisting>roo&gt; <command>field reference --fieldName pais --type ~.domain.Pais --notNull</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToOne(targetEntity = Pais.class)
    @JoinColumn
    private Pais pais;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con elementos de otra entidad (uno a
                muchos):</para>

                <programlisting>roo&gt; <command>field set --class ~.domain.Pais --element ~.domain.Provincia --fieldName provincias --mappedBy pais</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToMany(cascade = CascadeType.ALL, mappedBy = "pais")
    private Set&lt;Provincia&gt; provincias = new HashSet&lt;Provincia&gt;();</programlisting>
              </listitem>
            </orderedlist>
          </section>
        </section>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-a-mano">
        <title xml:lang="es">Crear una Entidad a mano</title>

        <para xml:lang="es">Para que se identifique una clase
        <literal>java</literal> como entidad, debe de estar anotada como
        <classname>@RooEntity</classname> y como
        <classname>@Entity</classname> de JPA. El framework, cuando crea la
        entidad con el comando <command>entity</command> genera una clase como
        esta:</para>

        <programlisting>    @Entity
    @RooJavaBean
    @RooToString
    @RooEntity
    public class Entity1 {
        
            @Size(max = 20)
            @NotNull
            private String name;
                
            @Size(max = 20)
            private String appellidos;
    }</programlisting>

        <para xml:lang="es">Nosotros podemos crear manualmente una clase
        <emphasis>java</emphasis> con estas anotaciones y manejarla desde
        gvNIX sin problemas.</para>

        <para xml:lang="es">Entre las anteriores anotaciones podemos
        ver:</para>

        <variablelist>
          <varlistentry>
            <term>@Entity</term>

            <listitem>
              <para xml:lang="es">Anotación JPA que identifica esta clase como
              persistente.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooJavaBean</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe generar
              los getter/setter que falten para acceder modificar los valores
              de nuestros campos. Si alguno estuviese generado, el framework
              no lo generará.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooToString</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe genera
              un método automático <methodname>toString()</methodname> para
              esta clase. Este método se genera a partir de las propiedades de
              la clase.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooEntity</term>

            <listitem>
              <para xml:lang="es">Anotación que informa Roo que esta clase es
              una entidad. Esta anotación genera todos lo métodos necesarios
              de persistencia y manejo básicos necesario para manejar la
              entidad.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <important>
          <para>gvNIX solo reconoce las <emphasis role="bold">anotaciones de
          las propiedades</emphasis> que estén <emphasis role="bold">en la
          declaración de la propiedad</emphasis> de la clase, <emphasis
          role="bold">no en los métodos accesores</emphasis></para>
        </important>

        <important>
          <para>gvNIX solo distinguirá las como <emphasis role="bold">entidad
          las clases correctamente anotadas</emphasis> y que estén <emphasis
          role="bold">dentro del paquete base de la aplicación (o
          subpaquetes)</emphasis>.</para>
        </important>

        <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-rooentity">
          <title xml:lang="es">La anotación
          <classname>@RooEntity</classname></title>

          <para xml:lang="es">Como ya hemos mencionado, informa a gvNIX que
          esta clase debe ser tratada como una entidad. Esto provoca que Roo
          genere un fichero <filename>{Entidad}_Roo_Entity.aj</filename> en el
          que añadirá todo aquellos métodos y atributos que sean
          necesarios.</para>

          <para xml:lang="es">Esta anotación admite parámetros de
          configuración. Entre ellos podemos ver:</para>

          <variablelist>
            <varlistentry>
              <term>identifierType</term>

              <listitem>
                <para xml:lang="es">Clase java para el campo usado como
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre de campo a usar como identificador
                (de la clase).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de columna en la BBDD para
                almacenar el valor del identificador (clave primaria).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionField</term>

              <listitem>
                <para xml:lang="es">Nombre del campo para la gestión de
                concurrencia. Si se establece a <literal>""</literal> (cadena
                vacía) no se usará gestión de concurrencia.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionType</term>

              <listitem>
                <para xml:lang="es">Tipo a usar para el campo de gestión de
                concurrencia. (normalmente un numérico o TimeStamp)</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Es posible usar un identificador personalizado.
          Para ello hay que declarar el campo en la clase Java y anotarlo con
          <classname>@Id</classname>. Luego hay que proporcionar sus
          <methodname>getter</methodname> y
          <methodname>setter</methodname>.</para>
        </section>

        <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-roojavabean">
          <title xml:lang="es">La anotación
          <classname>@RooJavaBean</classname></title>

          <para xml:lang="es">Genera los getter y setter para todos aquellos
          campos que no estén ya generados. Utiliza el fichero
          <filename>{Entidad}_Roo_JavaBean.aj</filename>. También es admitida
          en otras clases que no sean entidades, por lo que es muy útil para
          toda la aplicación.<important>
              <para>La <emphasis role="bold">restricción del paquete
              base</emphasis> que se menciona en la <link
              linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-rooentity">anotación
              <classname>@RooEntity</classname></link> se <emphasis
              role="bold">aplica a todas las anotaciones</emphasis> de
              gvNIX.</para>
            </important></para>
        </section>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">
        <title xml:lang="es">Modificar el modelo</title>

        <para xml:lang="es">Como podréis comprobar, no existe comando para
        <emphasis role="bold">eliminar una entidad</emphasis> del modelo. Para
        ello lo único que tenéis que hacer es <emphasis role="bold">eliminar
        el fichero</emphasis> <filename>.java</filename> de la entidad y
        gvNIX, automáticamente, detectará el cambio y limpiara el sus
        elementos relacionados (ficheros {entidad}_Roo_*.aj, controladores
        asociados, elementos de menú).</para>

        <para xml:lang="es">Para <emphasis role="bold">eliminar un
        campo</emphasis> solo hay que <emphasis role="bold">eliminarlo de la
        clase</emphasis> <filename>.java</filename> y todos los componentes
        relacionados serán actualizados automáticamente.</para>

        <para xml:lang="es">Para <emphasis role="bold">añadir un
        campo</emphasis> una entidad existente se puede hacer <emphasis
        role="bold">manualmente</emphasis> (con las anotaciones adecuadas)
        <emphasis role="bold">o usando el comando</emphasis> <command><link
        linkend="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field">field</link></command>.</para>

        <para xml:lang="es">En cualquier caso gvNIX <emphasis
        role="bold">monitoriza los cambios en el proyecto</emphasis> y
        <emphasis role="bold">actualiza los componentes</emphasis>
        relacionados cuando es necesario.</para>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_definicion_identificadores-compuestos">
        <title xml:lang="es">Identificadores Compuestos</title>

        <para xml:lang="es">Ahora mismo no está completo el soporte para
        identificadores que estén compuestos de mas de un campo.</para>

        <para xml:lang="es">Para más información ver:</para>

        <itemizedlist>
          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-505">ROO-505</link></para>
          </listitem>

          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-345">ROO-345</link></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente">
      <title xml:lang="es">Enlazar modelo de entidades con base de datos
      existente</title>

      <para xml:lang="es">Una vez creado el modelo de datos se puede necesitar
      ajustar ciertos aspecto para que encaje en una base de dato ya
      existente.</para>

      <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_tablas">
        <title>Tablas en la base de datos.</title>

        <para>Por defecto, se usa como nombre de tabla el nombre de la
        entidad. Este comportamiento lo podemos modelar usando la anotación
        <classname><link
        xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Table.html">@Table</link></classname>
        de la clase java de la entidad, añadiéndole los parámetros
        necesarios.</para>

        <para>Este es un ejemplo de uso de esta anotación:</para>

        <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
@Table(name = "ENT1")
public class Entity1 {

    private String field1;
}</programlisting>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_columnas">
        <title>Columnas en la base de datos.</title>

        <para>Por defecto, se usa el nombre del campo (propiedades de la clase
        java) y su tipo para hacer el mapeo en la tabla de base de datos.
        Existen varías anotaciones que permiten modelar como se mapean los
        campos a columnas de la tabla.</para>

        <para>Las más importantes son:</para>

        <variablelist>
          <varlistentry>
            <term><classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Column.htmlhttp://java.sun.com/javaee/5/docs/api/javax/persistence/Column.html">@column</link></classname></term>

            <listitem>
              <para>Concreta la definición del mapeo de el campo sobre la
              columna de la base de datos. Si se omite este anotación se usan
              ajustes por defecto</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Transient.html">@Transient</link></classname></term>

            <listitem>
              <para>Indica que el campo (propiedad de la clase java) no tiene
              representación en la tabla (no será cargado ni
              persistido)</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinColumn.html">@JoinColumn</link></classname>,
            <classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinColumns.html">@JoinColumns</link></classname>,
            <link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OneToOne.html"><classname>@OneToOne</classname></link>,
            <link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/ManyToOne.html"><classname>@ManyToOne</classname></link></term>

            <listitem>
              <para>Definición del mapeo de un campo de relación
              <emphasis>n-1</emphasis> con otra entidad</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinTable.html">@JoinTable</link></classname>,
            <link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OneToMany.html"><classname>@OneToMany</classname></link>,
            <classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/ManyToMany.html">@ManyToMany</link></classname>,
            <classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OrderBy.html">@OrderBy</link></classname></term>

            <listitem>
              <para>Definición del mapeo de un campo de relación
              <emphasis>1-n</emphasis> o <emphasis>n-m</emphasis></para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Un ejemplo del uso de algunas de estas anotaciones:</para>

        <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
@Table(name = "ENT1")
public class Entity1 {

    private String field1; //<emphasis role="bold">[1]</emphasis>

    @Transient
    private String tmpInfo; //<emphasis role="bold">[2]</emphasis>

    @Column(name="ORDER_COST", precision=12, scale=2) //<emphasis role="bold">[3]</emphasis>
    private BigDecimal cost;

    @ManyToOne(targetEntity = Customer.class) //<emphasis role="bold">[4]</emphasis>
    @JoinColumn(name = "CUSTOMER_ID") //<emphasis role="bold">[5]</emphasis>
    private Customer customer;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "entity1") //<emphasis
            role="bold">[6]</emphasis>
    private Set&lt;Price&gt; prices = new java.util.HashSet&lt;Price&gt;();

}</programlisting>

        <variablelist>
          <varlistentry>
            <term>[1]</term>

            <listitem>
              <para>Este campo se cargará y almacenará en la columna
              <literal>field1</literal> de la tabla
              <literal>ENT1</literal></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>[2]</term>

            <listitem>
              <para>Este campo no se tendrá en cuenta en la carga y guardado
              de la base de datos.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>[3]</term>

            <listitem>
              <para>Este campo numérico se cargará y almacenará en la columna
              <literal>ORDER_COST</literal> de la tabla
              <literal>ENT1</literal>, usando los valores de
              <emphasis>precisión</emphasis> y <emphasis>escala</emphasis>
              especificados.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>[4]</term>

            <listitem>
              <para>Declara que la propiedad tiene origen en una relación
              <emphasis>n-1</emphasis>, con la entidad
              <classname>Customer</classname>. La tablas de esta entidad y sus
              columnas se tomarán de las declaraciones que se hayan hecho en
              esa entidad.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>[5]</term>

            <listitem>
              <para>Especifica que la columna de clave ajena en la tabla
              <literal>ENT1</literal> para esta relación (con
              <classname>Customer</classname>) es
              <literal>CUSTOMER_ID</literal></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>[6]</term>

            <listitem>
              <para>Declara que el campo <literal>prices</literal> es una
              relación <emphasis>1-n</emphasis> con la entidad
              <literal>Price</literal>. También declara que los cambios de
              <literal>Entity1</literal> se aplican en cascada sobre
              <literal>Price</literal>. El campo (propiedad en la clase java)
              que estable la clave ajena en <literal>Price</literal> se llama
              <literal>entity1</literal>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_clave-primaria">
        <title>Clave primaria.</title>

        <para>Por defecto, se genera un campo Id (propiedad en la clase java),
        de tipo <classname>java.lang.Long</classname>, como identificador
        (clave primaria) de la entidad. Para ajustar esto se dispone de dos
        opciones:</para>

        <orderedlist>
          <listitem>
            <para>Configurar la anotación <link
            linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-rooentity">anotación
            <classname>@RooEntity</classname></link> ajustar el nombre del
            campo, tipo y nombre de columna en la tabla. Un ejemplo de
            esto:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(identifierField="entity1Id", 
        identifierType=Long.class, identifierColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>
          </listitem>

          <listitem>
            <para>Añadir manualmente el campo en la clase java. La declaración
            se detectará por el framework que no la generará automáticamente.
            Un ejemplo de esto:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ENT1_ID")
    private Long ent1Id;

    public Long getEnt1Id(){
        return ent1Id;
    }

    public void setEnt1Id(Long ent1Id){
        this.ent1Id = ent1Id;
    }

    private String field1;

}</programlisting>

            <para>Si se declara el campo de identificador en la clase java,
            también es necesario añadir sus métodos <emphasis>get y
            set</emphasis> manualmente.</para>

            <para>Para más información sobre las anotaciones JPA (como
            <classname><link
            xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/GeneratedValue.html">@GeneratedValue</link></classname>
            ) consultar el <link
            xlink:href="http://java.sun.com/javaee/5/docs/api/index.html?javax/persistence/package-summary.html">API</link>.</para>
          </listitem>
        </orderedlist>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_campo-control-optimista">
        <title>Campo para el control de concurrencia optimista.</title>

        <para>Por defecto, se genera un campo de control de concurrencia
        optimista llamado <literal>version</literal> de tipo
        <classname>java.lang.Integer</classname>. Para ajustarlo disponemos de
        tres opciones:</para>

        <orderedlist>
          <listitem>
            <para>Configurar la anotación <link
            linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano_anotacion-rooentity">anotación
            <classname>@RooEntity</classname></link> ajustar el nombre del
            campo, y tipo. Si dejamos el nombre de campo a <emphasis>cadena
            vacía</emphasis> (<literal>""</literal>) no se generará ningún
            campo. Un ejemplo de esto:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(versionField="version", 
        versionType=Long.class, identifierColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>

            <para>Otro ejemplo desactivando el control de concurrencia
            optimista:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(versionField="")
public class Entity1 {

    private String field1;

}</programlisting>
          </listitem>

          <listitem>
            <para>Añadir manualmente el campo en la clase java. La declaración
            se detectará por el framework que no la generará automáticamente.
            Un ejemplo de esto:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Version
    @Column(name = "ENT1_VERSION")
    private Integer version;

    public Integer getVersion(){
        return ent1Id;
    }

    public void setVersion(Integer version){
        this.version = version;
    }

    private String field1;

}</programlisting>
          </listitem>

          <listitem>
            <para>Usar el control de concurrencia optimista de gvNIX. Para
            ello se debe usar el comando <command><link
            linkend="apendice-comandos_addon-persistence_occchecksum_occ-checksum-set">occ
            checksum set</link></command>. Con este comando la clase se
            quedará así:</para>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Version
    @Transient
    private String occChekcsum;

    public String getOccChekcsum() {
        return this.occChekcsum;
    }

    public void setOccChekcsum(String checksum) {
        this.occChekcsum = checksum;
    }

    private String field1;

}</programlisting>
          </listitem>
        </orderedlist>
      </section>

      <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_regeneracion-bbdd">
        <title xml:lang="es">Regeneración de la Base de datos en cada
        arranque.</title>

        <para xml:lang="es">Por defecto, la configuración de Roo <emphasis
        role="bold">reconstruye la BBDD en cada ejecución de la
        aplicación</emphasis>. Cuando usamos una base de datos preexistente o
        compartida, normalmente, este comportamiento no nos convenga.</para>

        <para xml:lang="es">Para evitar esto se debe modificar el fichero
        <filename>src/main/resources/META-INF/persistence.xml</filename>
        comentando la siguiente linea:</para>

        <programlisting>    &lt;!-- &lt;property name="hibernate.hbm2ddl.auto" value="create"/&gt; --&gt;</programlisting>
      </section>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_ingenieria-inversa">
      <title xml:lang="es">Ingeniería inversa de entidades</title>

      <para xml:lang="es">En en proyecto de Spring Roo tiene planeado añadir
      soporte para soportar ingeniería inversa de entidades. En un principio
      nosotros sugerimos el uso de Hiberate Tools para realizar la tarea, pero
      desde el proyecto pretenden dar un soporte nativo a ello.</para>

      <para xml:lang="es">En la versión en desarrollo (v1.1.0M2) se ha
      iniciado ya el desarrollo del mecanismo para ello. Se puede ver más
      información en: <link
      xlink:href="https://jira.springsource.org/browse/ROO-435">ROO-435</link>.</para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_web">
    <title xml:lang="es">Gestión de la capa web</title>

    <para xml:lang="es">En la Capa Web se centra el control de gestión de las
    peticiones por parte del usuario. Esta capa dependerá del Front-End que
    vallamos a usar. Actualmente están disponibles el Spring MVC y el GWT.
    Este último, aunque es funcional, todavía está en fase de refinamiento. En
    este apartado nos centraremos en cómo se genera la aplicación para Spring
    MVC.</para>

    <para xml:lang="es">La gestión de peticiones en Spring MVC se base en los
    controllers, clases en las que, mediante anotaciones, vamos a ir
    registrando que métodos atienden que peticiones. Un controller puede tener
    o no asociada una entidad.</para>

    <para xml:lang="es">Actualmente es posible generar controllers para
    gestionar las peticiones de CRUDA de una entidad de forma automática,
    generados a partir de la información que el framework tiene de la entidad.
    Esto incluye búsquedas configurables (se registran en la entidad y se
    generan vistas para usarlas).</para>

    <section xml:id="guia-desarrollo_web_definir-controller">
      <title xml:lang="es">Definir un Controller</title>

      <para xml:lang="es">Un controller es una clase Java anotada con
      <classname>@Controller</classname> y que identifica a que peticiones
      atiende mediante la anotación <classname>@RequestMapping</classname>.
      Esta última anotación se puede usar tanto en la clase como en los
      métodos.</para>

      <para xml:lang="es">Para crear los controllers, al igual que las
      entidades, tenemos la opción de crearlos a mano además de unos comandos
      que nos aporta el framework.</para>

      <section xml:id="guia-desarrollo_web_definir-controller_usando-comandos">
        <title xml:lang="es">Crear controller usando comandos</title>

        <para xml:lang="es">Desde la consola del framework podemos crear
        controllers de forma sencilla, ya sean para el gestionar el CRUDS (la
        S no es error tipográfico sino que significa
        <literal>Search</literal>) como independientes. Para ello tenemos tres
        comandos:</para>

        <itemizedlist>
          <listitem>
            <para><command>controller class</command></para>
          </listitem>

          <listitem>
            <para><command>controller scaffold</command></para>
          </listitem>

          <listitem>
            <para><command>controller all</command></para>
          </listitem>
        </itemizedlist>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-class">
          <title>controller class</title>

          <para xml:lang="es">Este comando permite crear un controller
          plantilla no vinculado a ninguna entidad en concreto para su
          implementación manual.</para>

          <para xml:lang="es">Los parámetros para este comando son:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para el controller
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--preferredMapping</term>

              <listitem>
                <para xml:lang="es">Permite la ruta de la petición para este
                controller.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Un ejemplo:</para>

          <programlisting>roo&gt; <command>controller class --class ~.web.MyController</command></programlisting>

          <para>Genera una clase como esta:</para>

          <programlisting>@RequestMapping("/my/**")
@Controller
public class MyController {

    @RequestMapping
    public void get(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response) {
    }

    @RequestMapping(method = RequestMethod.POST, value = "{id}")
    public void post(@PathVariable Long id, ModelMap modelMap, HttpServletRequest request, HttpServletResponse response) {
    }

    @RequestMapping
    public String index() {
        return "my/index";
    }
}</programlisting>

          <para xml:lang="es">En este ejemplo la clase atenderá cualquier
          petición cuya URL comience por <filename>{URLBase}/my</filename>
          definido por la anotación <classname>@RequestMapping</classname>. El
          método receptor, tal cual están definidas las anotaciones
          <classname>@RequestMapping</classname> en los métodos cumplirán
          estas reglas:</para>

          <orderedlist>
            <listitem>
              <para>Las peticiones de tipo POST con una petición cuya URL
              cumpla <filename>{URLBase}/myController/{entero}</filename>
              entrarán por el método <methodname>post</methodname> de la
              clase.</para>
            </listitem>

            <listitem>
              <para>las peticiones a <filename>{URLBase}/my/index</filename>
              que se atenderán en el método <methodname>index</methodname> que
              muestra la vista <filename>my/index</filename>.</para>
            </listitem>

            <listitem>
              <para>El resto de peticiones serán atendidas en el método
              <methodname>get</methodname> de la clase.</para>
            </listitem>
          </orderedlist>

          <para xml:lang="es">Para más información sobre la anotación
          <classname>@RequestMapping</classname> ver la documentación de <link
          xlink:href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping">Spring
          MVC</link>.</para>

          <para>Este comando, además, generará la vista la vista
          <filename>WEB-INF/views/my/index.jspx</filename>, añadirá una
          entrada de menú para ella y actualizará el fichero
          <filename>WEB-INF/i18n/application.properties</filename> con
          entradas de internacionalización.</para>
        </section>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-scaffold">
          <title>controller scaffold</title>

          <para xml:lang="es">Este comando crear un Controller con el CRUDS
          una Entidad especificada. No hay restricciones para crear varios
          controllers para la misma Entidad.</para>

          <para xml:lang="es">Este comando, además de generar el Controller
          genera las vistas para la creación, visualización, listado,
          actualización y búsquedas de los registros de la entidad.</para>

          <para xml:lang="es">Las URL de las peticiones que acepta el
          Controller generado siguen el convenio <link
          xlink:href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</link>
          (<link
          xlink:href="http://es.wikipedia.org/wiki/Representational_State_Transfer">en
          español</link>). Toda la lógica se genera en un fichero
          <filename>*_Roo_*.aj</filename> asociado al controller, de forma que
          la clase Java queda limpia de los métodos generados
          automáticamente.</para>

          <para xml:lang="es">Los parámetros para este comando son:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para el controller
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--entity</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase Entidad que manejará el
                Controller.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--path</term>

              <listitem>
                <para xml:lang="es">Ruta base para la generación de la URL
                para las peticiones basadas en RESTful.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--disallowedOperations</term>

              <listitem>
                <para xml:lang="es">Lista de operaciones, separada por comas,
                de las operaciones NO permitidas en este controller. Los
                elementos de esta lista deben estar entre estos:
                <literal>create update delete</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-scafold">
          <title>controller all</title>

          <para xml:lang="es">Este comando ejecuta un <link
          linkend="guia-desarrollo_web_definir-controller_comandos_controller-scaffold">controller
          scaffold</link> para cada una de las entidades registradas en la
          aplicación.</para>

          <para xml:lang="es">Los parámetros para este comando son:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--package</term>

              <listitem>
                <para xml:lang="es">Nombre del paquete donde se generarán los
                controllers.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section xml:id="guia-desarrollo_web_definir-controller_a-mano">
        <title xml:lang="es">Crear controller a mano</title>

        <para xml:lang="es">Para que una clase <literal>java</literal> sea un
        controller de Spring debe estar anotada con la anotación
        <classname>@Controller</classname> y añadir la anotación <link
        xlink:href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping"><classname>@RequestMapping</classname></link>
        como convenga para hacer el mapeo de URL y métodos. Los controllers
        puedes ser propios, para realizar las operaciones que deseemos o
        podemos crear controllers automáticos de CRUDA que genera Roo.</para>

        <section xml:id="guia-desarrollo_web_definir-controller_a-mano_propio">
          <title>Controllers propios</title>

          <para>Para crear un controller manual, además de generar la clase
          con la anotaciones pertinentes, debemos tener en cuenta las
          siguientes cuestiones:</para>

          <itemizedlist>
            <listitem>
              <para xml:lang="es">Si usamos vista, deberemos crearlas dentro
              de <filename>WEB-INF/views/{path}</filename> junto con un
              fichero <filename>WEB-INF/views/{path}/views.xml</filename> de
              configuración del <literal>Tiles</literal>.</para>
            </listitem>

            <listitem>
              <para>Si usamos cadenas de literales susceptibles de
              internacionalización deberíamos darlas de alta en los ficheros
              <filename>WEB-INF/i18n/*.properties</filename> para los idiomas
              disponibles.</para>
            </listitem>
          </itemizedlist>
        </section>

        <section xml:id="guia-desarrollo_web_definir-controller_a-mano_automatico">
          <title xml:lang="es">Controllers CRUDA automáticos</title>

          <para xml:lang="es">Para crear un controller automático de Spring
          Roo hay que añadir, además de las anotaciones ya explicadas, la
          anotación <classname>@RooWebScaffold</classname> que admite la
          siguiente configuración:</para>

          <variablelist>
            <varlistentry>
              <term>path</term>

              <listitem>
                <para xml:lang="es">Ruta base del controller. Debe coincidir
                con la ruta de la anotación
                <classname>@RequestMapping</classname> de la clase. También se
                usará como ruta base para crear las vistas automáticas a
                partir de <filename>WEB-INF/views/</filename> en la
                aplicación.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>formBackingObject</term>

              <listitem>
                <para xml:lang="es">Objeto que maneja el controller. Debe ser
                una clase java anotada como entidad de Roo.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>update delete create</term>

              <listitem>
                <para xml:lang="es">Establece si hay que crear esto métodos en
                el controller. Por defecto <literal>True</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>exposeFinders</term>

              <listitem>
                <para xml:lang="es">Generar vistas para las búsquedas
                declaradas en la entidad o no. Por defecto
                <literal>True</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>registerConverters</term>

              <listitem>
                <para xml:lang="es">Crear un método
                <classname>@InitBinder</classname> para registrar
                convertidores de Objetos a cadenas. Por defecto
                <literal>True</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Cuando el framework detecte la anotación
          realizará las siguientes operaciones:</para>

          <orderedlist>
            <listitem>
              <para xml:lang="es">Creará un fichero *_Roo_Controller.aj donde
              generará todos los método para gestionar las peticiones
              automáticas al controller.</para>
            </listitem>

            <listitem>
              <para>Añadirá las vista necesaria en
              <filename>WEB-INF/views/{nombre_controller}</filename> para
              gestionar las acciones configuradas en la anotación.</para>
            </listitem>

            <listitem>
              <para>Añadirá las entradas de menú pertinentes.</para>
            </listitem>

            <listitem>
              <para>Añadirá en el fichero
              <filename>WEB-INF/i18n/application.properties</filename>
              entradas para los literales</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </section>
  </section>
</chapter>
