<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="guia-desarrollo"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Guía de desarrollo de aplicaciones con gvNIX</title>

  <xi:include href="guia-desarrollo_aplicacion-base.xml" />

  <section xml:id="guia-desarrollo_manejo-entidades">
    <title xml:lang="es">Manejo de Entidades</title>

    <para xml:lang="es">En Spring Roo el artefacto que define la unidad de
    dato es la <classname>Entidad</classname> o <classname>Entity</classname>.
    En este artefacto se definirán los atributos que la componen y los
    servicios (o reglas de negocio) que ofrece para manejarla al resto de las
    entidades o de la aplicación. Por ello es una pieza clave de la
    aplicación.</para>

    <section xml:id="guia-desarrollo_manejo-entidades_definicion">
      <title xml:lang="es">Definición de una entidad</title>

      <para xml:lang="es">Una entidad se define en una clase
      <filename>.java</filename> con una serie de anotaciones de Roo y de JPA.
      Estas anotaciones automatizan comportamiento (sobre todo las de Roo
      añadiendo accesores/mutadores automáticos por ejemplo) y su persistencia
      (las de JPA como las nombre de tabla).</para>

      <para xml:lang="es">Además de las anotaciones de clase, se definen
      propiedades (variables de instancia) que almacenarán la información de
      la entidad. Estas propiedades también pueden llevar anotaciones de JPA
      (para modificar el nombre o tamaño de campo, definir una relación con
      una entidad, etc) y/o otras como las de validación (<link
      xlink:href="http://jcp.org/en/jsr/detail?id=303">JSR 303</link>).</para>

      <para xml:lang="es">Luego, se completa con todos aquellos métodos
      específico de las reglas de negocio de la entidad.</para>

      <para xml:lang="es">En principio, gvNIX nos añadirá todos los métodos
      estándar necesarios para completar la definición de entidad, como los de
      persistencia (almacenamiento y recuperación). Esto se completa usando la
      librería AspectJ y sus ITD. Un ITD es un conjunto de definiciones de una
      clase java que se extraen del propio fichero de forma de que en el .java
      sólo vemos lo fundamental. Luengo, en tiempo de compilación estos
      elementos se incrustarán en la clase final de forma transparente.
      Podemos ver esto elemento en unos ficheros llamados
      <filename>*_Roo_*.aj</filename> que se generan junto al fichero
      <filename>.java</filename> al que hacen referencia.</para>

      <para xml:lang="es">Si por algún motivo necesitamos <emphasis
      role="bold">personalizar el comportamiento</emphasis> de alguno de los
      <emphasis role="bold">métodos estándar que genera Roo</emphasis>,
      simplemente tenemos que <emphasis role="bold">definirlos en el en la
      clase java</emphasis> y, cuando el framework detecte el cambio, en el
      fichero <filename>*_Roo_*.aj</filename> afectado dejara de aparecer esta
      definición.</para>

      <para xml:lang="es">Las características de una
      <classname>Entity</classname> son:</para>

      <itemizedlist>
        <listitem>
          <para xml:lang="es">Tiene un identificador único.</para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene (opcionalmente) un campo de gestión de concurrencia de
          forma optimista.<footnote>
              <para>Ver el <link
              linkend="addon-persistence_occchecksum">OCCCheckSum</link> en el
              <link linkend="addon-persistence">Add-on
              Persistence</link></para>
            </footnote></para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene implementados los métodos para almacenarse y recuperarse
          de la fuente de datos.</para>
        </listitem>

        <listitem>
          <para>Genera de forma automática los <emphasis>Accesores</emphasis>
          y <emphasis>Mutadores</emphasis> (<emphasis>getters</emphasis> y
          <emphasis>setters</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <para xml:lang="es">Para generar una entidad podemos optar por dos
      mecanismos:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Usando los comandos de consola
          (<emphasis>recomendado</emphasis>).</para>
        </listitem>

        <listitem>
          <para xml:lang="es">Creando una clase a mano.</para>
        </listitem>
      </orderedlist>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando">
        <title xml:lang="es">Crear una Entidad usando comandos</title>

        <para xml:lang="es">Desde la consola del framework podemos crear
        Entidades de forma sencilla. Para ello tenemos disponibles dos
        comandos:</para>

        <itemizedlist>
          <listitem>
            <para xml:lang="es">El comando <command>entity</command>.</para>
          </listitem>

          <listitem>
            <para xml:lang="es">El comando <command>field</command>.</para>
          </listitem>
        </itemizedlist>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_entity">
          <title xml:lang="es">El comando <command>entity</command></title>

          <para xml:lang="es">Este comando crea una nueva entidad en nuestro
          proyecto. Requiere como mínimo definir el parámetro
          <parameter>--class</parameter> para especificar el nombre y el
          paquete de na nueva entidad. En este parámetro podemos utilizar el
          carácter <literal>~</literal> como abreviatura de el paquete base
          del proyecto.</para>

          <para xml:lang="es">Entre los parámetros disponibles podemos
          destacar:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para la entidad
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierType</term>

              <listitem>
                <para xml:lang="es">Permite definir el tipo (clase java) de
                identificador (clave primaria) que usará esta entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre del <emphasis>campo en la
                entidad</emphasis> (no en BBDD) que se usará para el
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>columna de la
                BBDD</emphasis> donde almacenar el valor de clave
                primaria.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--table</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>tabla de la
                BBDD</emphasis> donde almacenar los datos para esta
                entidad.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">El resto de las opciones podemos verlas usando
          el autocompletado de la consola de roo o usando el comando
          <command>help entity</command>.</para>

          <para xml:lang="es">Existen más opciones para configurar la entidad,
          aunque no todos se pueden especificar usando este comando. Ver el
          apartado <link
          linkend="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">Anotación
          RooEntity</link>.</para>
        </section>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field">
          <title xml:lang="es">El comando <command>field</command></title>

          <para xml:lang="es">No existe un comando <command>field</command>
          propiamente dicho, pero es el nombre de un grupo de comando para
          añadir campos a una entidad. Los comandos finales se forma con el
          <command>field {tipo}</command> donde <parameter>{tipo}</parameter>
          es el tipo de dato que va almacenar. Así tenemos los
          siguientes:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">field string</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo cadena.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field boolean</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo booleano.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field date</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo fecha.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field email template</term>

              <listitem xml:lang="es">
                <para>Crea un campo con una plantilla preparada para almacenar
                direcciones de correo electrónico.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field enum</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo enumerado.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field number</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo numérico (es posible especificarle
                el tipo mediante el parámetro
                <parameter>--type</parameter>).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field reference</term>

              <listitem xml:lang="es">
                <para>Crea un campo que será una referencia a otra
                entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field set</term>

              <listitem xml:lang="es">
                <para>Crea un campo que devolverá una lista de elementos de
                una entidad relacionados con este elemento.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field other</term>

              <listitem xml:lang="es">
                <para>Crea un campo de otro tipo no registrado.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Cada uno de estos comandos admiten algunos parámetros que son
          comunes entre ellos o muy específicos. Entre los comunes (para la
          mayoría) podemos encontrar los siguientes:</para>

          <variablelist>
            <varlistentry>
              <term>--fieldName</term>

              <listitem>
                <para xml:lang="es">Nombre del campo que vamos a
                generar.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--class</term>

              <listitem>
                <para xml:lang="es">Clase entidad donde vamos a crear el
                campo. Admite el uso de <literal>~</literal> y tiene
                autocompletado. No es necesario especificar si acabamos de
                crear una entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--notNull y --nullRequired</term>

              <listitem>
                <para xml:lang="es">Especifica el comportamiento de campo
                antes los valores nulos.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--column</term>

              <listitem>
                <para xml:lang="es">Nombre de la columna en BBDD donde se
                almacenará el valor.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--sizeMax y --sizeMin</term>

              <listitem>
                <para xml:lang="es">Limitaciones de tamaño.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Existe mas opciones dependiendo del tipo de
          dato, para mas información ver la ayuda de la consola.</para>

          <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field_ejemplos">
            <title xml:lang="es">Ejemplos</title>

            <para xml:lang="es">Estos son algunos ejemplos de creación de
            campos:</para>

            <orderedlist>
              <listitem>
                <para xml:lang="es">Campo cadena con validaciones:</para>

                <programlisting>roo&gt; <command>field string --fieldName nombre --notNull --sizeMax 50 --sizeMin 1 --comment "Nombre del pais" --column pais_nombre --regexp [A-Z].*</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @NotNull
    @Column(name = "pais_nombre")
    @Size(min = 1, max = 50)
    @Pattern(regexp = "[A-Z].*")
    private String nombre;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con referencia a otra entidad
                (muchos a uno):</para>

                <programlisting>roo&gt; <command>field reference --fieldName pais --type ~.domain.Pais --notNull</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToOne(targetEntity = Pais.class)
    @JoinColumn
    private Pais pais;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con elementos de otra entidad (uno a
                muchos):</para>

                <programlisting>roo&gt; <command>field set --class ~.domain.Pais --element ~.domain.Provincia --fieldName provincias --mappedBy pais</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToMany(cascade = CascadeType.ALL, mappedBy = "pais")
    private Set&lt;Provincia&gt; provincias = new HashSet&lt;Provincia&gt;();</programlisting>
              </listitem>
            </orderedlist>
          </section>
        </section>
      </section>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano">
        <title xml:lang="es">Crear una Entidad a mano</title>

        <para xml:lang="es">Para que se identifique una clase *java* como
        entidad, debe de estar anotada como <classname>@RooEntity</classname>
        y como <classname>@Entity</classname> de JPA. El framework, cuando
        crea la entidad con el comando <command>entity</command> genera una
        clase como esta:</para>

        <programlisting>    @Entity
    @RooJavaBean
    @RooToString
    @RooEntity
    public class Entity1 {
        
            @Size(max = 20)
            @NotNull
            private String name;
                
            @Size(max = 20)
            private String appellidos;
    }</programlisting>

        <para xml:lang="es">Nosotros podemos crear manualmente una clase
        <emphasis>java</emphasis> con estas anotaciones y manejarla desde
        gvNIX sin problemas.</para>

        <para xml:lang="es">Entre las anteriores anotaciones podemos
        ver:</para>

        <variablelist>
          <varlistentry>
            <term>@Entity</term>

            <listitem>
              <para xml:lang="es">Anotación JPA que identifica esta clase como
              persistente.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooJavaBean</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe generar
              los getter/setter que falten para acceder modificar los valores
              de nuestros campos. Si alguno estuviese generado, el framework
              no lo generará.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooToString</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe genera
              un método automático <methodname>toString()</methodname> para
              esta clase. Este método se genera a partir de las propiedades de
              la clase.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooEntity</term>

            <listitem>
              <para xml:lang="es">Anotación que informa Roo que esta clase es
              una entidad. Esta anotación genera todos lo métodos necesarios
              de persistencia y manejo básicos necesario para manejar la
              entidad.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <important>
          <para>gvNIX solo reconoce las <emphasis role="bold">anotaciones de
          las propiedades</emphasis> que estén <emphasis role="bold">en la
          declaración de la propiedad</emphasis> de la clase, <emphasis
          role="bold">no en los métodos accesores</emphasis></para>
        </important>

        <important>
          <para>gvNIX solo distinguirá las como <emphasis role="bold">entidad
          las clases correctamente anotadas</emphasis> y que estén <emphasis
          role="bold">dentro del paquete base de la aplicación (o
          subpaquetes)</emphasis>.</para>
        </important>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">
          <title xml:lang="es">La anotación
          <classname>@RooEntity</classname></title>

          <para xml:lang="es">Como ya hemos mencionado, informa a gvNIX que
          esta clase debe ser tratada como una entidad. Esto provoca que Roo
          genere un fichero <filename>{Entidad}_Roo_Entity.aj</filename> en el
          que añadirá todo aquellos métodos y atributos que sean
          necesarios.</para>

          <para xml:lang="es">Esta anotación admite parámetros de
          configuración. Entre ellos podemos ver:</para>

          <variablelist>
            <varlistentry>
              <term>identifierType</term>

              <listitem>
                <para xml:lang="es">Clase java para el campo usado como
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre de campo a usar como identificador
                (de la clase).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de columna en la BBDD para
                almacenar el valor del identificador (clave primaria).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionField</term>

              <listitem>
                <para xml:lang="es">Nombre del campo para la gestión de
                concurrencia. Si se establece a <literal>""</literal> (cadena
                vacía) no se usará gestión de concurrencia.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionType</term>

              <listitem>
                <para xml:lang="es">Tipo a usar para el campo de gestión de
                concurrencia. (normalmente un numérico o TimeStamp)</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Es posible usar un identificador personalizado.
          Para ello hay que declarar el campo en la clase Java y anotarlo con
          <classname>@Id</classname>. Luego hay que proporcionar sus
          <methodname>getter</methodname> y
          <methodname>setter</methodname>.</para>
        </section>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-roojavabean">
          <title xml:lang="es">La anotación
          <classname>@RooJavaBean</classname></title>

          <para xml:lang="es">Genera los getter y setter para todos aquellos
          campos que no estén ya generados. Utiliza el fichero
          <filename>{Entidad}_Roo_JavaBean.aj</filename>. También es admitida
          en otras clases que no sean entidades, por lo que es muy útil para
          toda la aplicación.<important>
              <para>La <emphasis role="bold">restricción del paquete
              base</emphasis> que se menciona en la <link
              linkend="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">anotación
              @RooEntity</link> se <emphasis role="bold">aplica a todas las
              anotaciones</emphasis> de gvNIX.</para>
            </important></para>
        </section>
      </section>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_modificar-modelo">
        <title xml:lang="es">Modificar el modelo</title>

        <para xml:lang="es">Como podréis comprobar, no existe comando para
        <emphasis role="bold">eliminar una entidad</emphasis> del modelo. Para
        ello lo único que tenéis que hacer es <emphasis role="bold">eliminar
        el fichero</emphasis> <filename>.java</filename> de la entidad y
        gvNIX, automáticamente, detectará el cambio y limpiara el sus
        elementos relacionados (ficheros {entidad}_Roo_*.aj, controladores
        asociados, elementos de menú).</para>

        <para xml:lang="es">Para <emphasis role="bold">eliminar un
        campo</emphasis> solo hay que <emphasis role="bold">eliminarlo de la
        clase</emphasis> <filename>.java</filename> y todos los componentes
        relacionados serán actualizados automáticamente.</para>

        <para xml:lang="es">Para <emphasis role="bold">añadir un
        campo</emphasis> una entidad existente se puede hacer <emphasis
        role="bold">manualmente</emphasis> (con las anotaciones adecuadas)
        <emphasis role="bold">o usando el comando</emphasis> <command><link
        linkend="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field">field</link></command>.</para>

        <para xml:lang="es">En cualquier caso gvNIX <emphasis
        role="bold">monitoriza los cambios en el proyecto</emphasis> y
        <emphasis role="bold">actualiza los componentes</emphasis>
        relacionados cuando es necesario.</para>
      </section>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_identificadores-compuestos">
        <title xml:lang="es">Identificadores Compuestos</title>

        <para xml:lang="es">Ahora mismo no está completo el soporte para
        identificadores que estén compuestos de mas de un campo.</para>

        <para xml:lang="es">Para más información ver:</para>

        <itemizedlist>
          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-505">ROO-505</link></para>
          </listitem>

          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-345">ROO-345</link></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section xml:id="guia-desarrollo_manejo-entidades_ingenieria-inversa">
      <title xml:lang="es">Ingeniería inversa de entidades</title>

      <para xml:lang="es">En en proyecto de Spring Roo tiene planeado añadir
      soporte para soportar ingeniería inversa de entidades. En un principio
      nosotros sugerimos el uso de Hiberate Tools para realizar la tarea, pero
      desde el proyecto pretenden dar un soporte nativo a ello.</para>

      <para xml:lang="es">En la versión en desarrollo (v1.1.0M2) se ha
      iniciado ya el desarrollo del mecanismo para ello. Se puede ver más
      información en: <link
      xlink:href="https://jira.springsource.org/browse/ROO-435">ROO-435</link>.</para>
    </section>

    <section xml:id="guia-desarrollo_manejo-entidades_regeneracion-bbdd">
      <title xml:lang="es">Regeneración de la Base de datos en cada
      arranque.</title>

      <para xml:lang="es">Por defecto, la configuración de Roo <emphasis
      role="bold">reconstruye la BBDD en cada ejecución de la
      aplicación</emphasis>. Cuando usamos una base de datos pre-existente o
      compartida, lo mas seguro, que este comportamiento no nos
      convenga.</para>

      <para xml:lang="es">Para evitar esto se debe modificar el fichero
      <filename>src/main/resources/META-INF/persistence.xml</filename>
      comentando la siguiente linea:</para>

      <programlisting>    &lt;!-- &lt;property name="hibernate.hbm2ddl.auto" value="create"/&gt; --&gt;</programlisting>
    </section>

    <section>
      <title xml:lang="es">Múltipes fuentes de datos</title>

      <para>En este <link
      xlink:href="http://forum.springsource.org/showpost.php?p=289577&amp;postcount=4">post
      del foro de Spring Roo</link> tenemos un ejemplo de los cambios a
      realizar en nuestra aplicación para que las entidades tenga distintas
      fuentes de datos.</para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_web">
    <title xml:lang="es">Capa Web</title>

    <para xml:lang="es">En la Capa Web se centra el control de gestión de las
    peticiones por parte del usuario. Esta capa dependerá del Front-End que
    vallamos a usar. Actualmente están diponibles el Spring MVC y el GWT. Este
    último, aunque es funcional, todavía está en fase de refinamiento. En este
    apardo nos centraremos en cómo se genera la aplicación para Spring
    MVC.</para>

    <para xml:lang="es">La gestión de peticiones en Spring MVC se base en los
    Controllers, clases en las que, mediante anotaciones, vamos a ir
    registrando que métodos atienden que penticiones. Un controler puede tener
    o no asociada una entidad.</para>

    <para xml:lang="es">Actualmente es posible generar controllers para
    gestionar las peticiones de CRUD de una entidad de forma automática,
    generados a partir de la información que el framework tiene de la entidad.
    Esto incluye busqueadas configurables (se registran en la entidad y se
    generan vistas para usarlas).</para>

    <section xml:id="guia-desarrollo_web_definir-controller">
      <title xml:lang="es">Definir un Controller</title>

      <para xml:lang="es">Un controller es una clase Java anotada con
      <classname>@Controller</classname> y que identifica a que peticiones
      atiende mediante la anotación <classname>@RequestMapping</classname>.
      Esta última anotación se puede usar tanto en la clase como en los
      métodos.</para>

      <para xml:lang="es">Para crear los Controllers, al igual que las
      entidades, tenemos la opción de crearlos a mano además de unos comandos
      que nos aporta el framework.</para>

      <section>
        <title xml:lang="es">Crear controller usando comandos</title>

        <para xml:lang="es">Desde la consola del framework podemos crear
        controllers de foma sencilla, ya sean para el gestionar el CRUDS (la S
        no es error tipográfico sino que signifa <literal>Search</literal>)
        como independientes. Para ello tenemos tres comandos:</para>

        <itemizedlist>
          <listitem>
            <para><command>controller class</command></para>
          </listitem>

          <listitem>
            <para><command>controller scafold</command></para>
          </listitem>

          <listitem>
            <para><command>controller all</command></para>
          </listitem>
        </itemizedlist>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-class">
          <title>controller class</title>

          <para xml:lang="es">Este comando crear un Controller plantilla no
          vinculado a ninguna entidad en concreto para su implementación
          manual.</para>

          <para xml:lang="es">Los parámetros para este comando son:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para el controller
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--preferredMapping</term>

              <listitem>
                <para xml:lang="es">Permite la ruta de la petición para este
                controller.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Un ejemplo:</para>

          <programlisting>roo&gt; <command>controller class --class ~.web.MyController</command></programlisting>

          <para>Genera una clase como esta:</para>

          <programlisting>@RequestMapping("/my/**")
@Controller
public class MyController {

    @RequestMapping
    public void get(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response) {
    }

    @RequestMapping(method = RequestMethod.POST, value = "{id}")
    public void post(@PathVariable Long id, ModelMap modelMap, HttpServletRequest request, HttpServletResponse response) {
    }

    @RequestMapping
    public String index() {
        return "my/index";
    }
}</programlisting>

          <para xml:lang="es">En este ejemplo la clase atenderá cualquier
          petición cuya URL comienze por <filename>{URLBase}/my</filename>
          definido por la anotación <classname>@RequestMapping</classname>. El
          método receptor, tal cual están definidas las anotaciones
          <classname>@RequestMapping</classname> en los métodos cumplirán
          estas reglas:</para>

          <orderedlist>
            <listitem>
              <para>Las peticiones de tipo POST con una petición cuya URL
              cumpla <filename>{URLBase}/myController/{entero}</filename>
              entrarán por el método <methodname>post</methodname> de la
              clase.</para>
            </listitem>

            <listitem>
              <para> las peticiones a <filename>{URLBase}/my/index</filename>
              que se atenderán en el método <methodname>index</methodname> que
              muestra la vista <filename>my/index</filename>.</para>
            </listitem>

            <listitem>
              <para>El resto de peticiones serán atendidas en el método
              <methodname>get</methodname> de la clase.</para>
            </listitem>
          </orderedlist>

          <para xml:lang="es">Para más información sobre la antación
          <classname>@RequestMapping</classname> ver la documentación de <link
          xlink:href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping">Spring
          MVC</link>.</para>
        </section>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-scaffold">
          <title>controller scaffold</title>

          <para xml:lang="es">Este comando crear un Controller con el CRUDS
          una Entidad especificada. No hay restrinciones para crear varios
          controllers para la misma Entidad.</para>

          <para xml:lang="es">Este comando, además de generar el Controller
          genera las vistas para la creación, visualización, listado,
          actualización y busquedas de los registros de la entidad.</para>

          <para xml:lang="es">Las URL de las peticiones que acepta el
          Controller generado siguen el convenio <link
          xlink:href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</link>
          (<link
          xlink:href="http://es.wikipedia.org/wiki/Representational_State_Transfer">en
          español</link>). Toda la lógica se genera en un ficher
          <filename>*_Roo_*.aj</filename> asociado al controler, de forma que
          la clase Java queda limpia de los métodos generados
          automáticamente.</para>

          <para xml:lang="es">Los parámetros para este comando son:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para el controller
                (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--entity</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase Entidad que manjará el
                Controller.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--path</term>

              <listitem>
                <para xml:lang="es">Ruta base para la generación de la URL
                para las peticiones basadas en RESTful.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--disallowedOperations</term>

              <listitem>
                <para xml:lang="es">Lista de operaciones, sepearada por comas,
                de las operaciones NO permitidas en este controler. Los
                elementos de esta lista deben estar enter estos:
                <literal>create update delete</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>

        <section xml:id="guia-desarrollo_web_definir-controller_comandos_controller-scafold">
          <title>controller all</title>

          <para xml:lang="es">Este comando crear un Controller
          plantilla</para>
        </section>
      </section>
    </section>
  </section>
</chapter>
