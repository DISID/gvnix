<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="guia-desarrollo_gestion-entidades"
         xml:lang="es" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Gestión de entidades</title>

  <para xml:lang="es">Las entidades del modelo del dominio son uno de los
  elementos más importantes de gvNIX.</para>

  <para xml:lang="es">En Java una entidad se corresponde con una clase,
  definida en un archivo <filename>.java</filename>.</para>

  <para>Además de la lógica de negocio, cada clase contiene una serie de
  anotaciones de clase y de atributos que forman parte de la metainformación
  que permite a gvNIX realizar acciones automáticas.</para>

  <example>
    <title>Una clase Java</title>

    <programlistingco>
      <areaspec>
        <area coords="1" xml:id="ex.annot.class"></area>

        <area coords="7" xml:id="ex.annot.attri"></area>
      </areaspec>

      <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

        @Size(max = 20)
        @NotNull
        private String name;

        @Size(max = 20)
        private String appellidos;
}</programlisting>

      <calloutlist>
        <callout arearefs="ex.annot.class">
          <para>Anotación de clase</para>
        </callout>

        <callout arearefs="ex.annot.attri">
          <para>Anotación de atributo</para>
        </callout>
      </calloutlist>
    </programlistingco>
  </example>

  <para xml:lang="es">gvNIX añadirá todos los métodos estándar necesarios para
  completar la definición de entidad, como los de persistencia (almacenamiento
  y recuperación). Como se vió en la sección de generación de código se
  crearán una serie de archivos <filename>.aj</filename> que en tiempo de
  compilación se incluyen a la clase de forma transparente.</para>

  <para xml:lang="es">Si por algún motivo necesitamos <emphasis>personalizar
  el comportamiento</emphasis> de alguno de los <emphasis>métodos estándar que
  genera Roo</emphasis>, simplemente tenemos que <emphasis>definirlos en la
  clase java</emphasis>. Cuando el framework detecta el cambio actualiza el
  fichero <filename>*_Roo_*.aj</filename> para eliminar esta
  definición.</para>

  <para xml:lang="es">Existen formas de crear una entidad:</para>

  <orderedlist>
    <listitem>
      <para xml:lang="es">Usando el intérprete de comandos.</para>
    </listitem>

    <listitem>
      <para xml:lang="es">Usando nuestro IDE habitual.</para>
    </listitem>
  </orderedlist>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando">
    <title xml:lang="es">Crear una entidad con el intérprete de
    comandos</title>

    <para xml:lang="es">Desde el intérprete de comandos podemos crear
    entidades de forma sencilla con los comandos: <command>entity</command> y
    <command>field</command>.</para>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_entity">
      <title xml:lang="es">Comando entity</title>

      <para xml:lang="es">Este comando crea una nueva entidad en nuestro
      proyecto. Requiere como mínimo definir el parámetro
      <parameter>--class</parameter> para especificar el nombre y el paquete
      de la nueva clase En este parámetro podemos utilizar el carácter
      <literal>~</literal> como abreviatura de el paquete base del
      proyecto.</para>

      <para xml:lang="es">Entre los parámetros disponibles podemos
      destacar:</para>

      <variablelist>
        <varlistentry>
          <term xml:lang="es">--class</term>

          <listitem>
            <para xml:lang="es">Nombre de la clase java para la entidad
            (incluido su paquete) (recordar que se puede usar el
            <literal>~</literal> para especificar el paquete base de la
            aplicación).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierType</term>

          <listitem>
            <para xml:lang="es">Permite definir el tipo (clase java) de
            identificador (clave primaria) que usará esta entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierField</term>

          <listitem>
            <para xml:lang="es">Nombre del <emphasis>campo en la
            entidad</emphasis> (no en BBDD) que se usará para el
            identificador.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--identifierColumn</term>

          <listitem>
            <para xml:lang="es">Nombre de la <emphasis>columna de la
            BBDD</emphasis> donde almacenar el valor de clave primaria.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--table</term>

          <listitem>
            <para xml:lang="es">Nombre de la <emphasis>tabla de la
            BBDD</emphasis> donde almacenar los datos para esta
            entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">--testAutomatically</term>

          <listitem>
            <para xml:lang="es">Genera los test unitarios para esta entidad
            usando JUnit.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para xml:lang="es">El resto de las opciones podemos verlas usando el
      autocompletado de la consola de roo o usando el comando <command>help
      entity</command>.</para>

      <important>
        <title xml:lang="es">Enlazar modelo de entidades con base de datos
        existente</title>

        <para xml:lang="es">Notar que los parámetros
        <command>--identifierColumn</command> y <command>--table</command>
        permiten que en tiempo de creación podemos indicar que la entidad sea
        persistente sobre un modelo relacional creado con anterioridad.</para>
      </important>

      <important>
        <title xml:lang="es">Eliminar y modificar entidades</title>

        <para xml:lang="es">No se pueden eliminar o modificar las entidades
        desde línea de comandos. Esto se debe realizar usando el IDE. Para más
        información ver la sección <link
        linkend="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">Modificar
        una entidad</link>.</para>
      </important>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field">
      <title xml:lang="es">Comando field</title>

      <para xml:lang="es">No existe un comando <command>field</command>
      propiamente dicho, pero es el nombre de un grupo de comando para añadir
      campos a una entidad. Los comandos finales se forma con el
      <command>field {tipo}</command> donde <parameter>{tipo}</parameter> es
      el tipo de dato que va almacenar. Así tenemos los siguientes:</para>

      <variablelist>
        <varlistentry>
          <term xml:lang="es">field string</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo cadena.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field boolean</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo booleano.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field date</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo fecha.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field email template</term>

          <listitem xml:lang="es">
            <para>Crea un campo con una plantilla preparada para almacenar
            direcciones de correo electrónico.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field enum</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo enumerado.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field number</term>

          <listitem xml:lang="es">
            <para>Crea un campo de tipo numérico (es posible especificarle el
            tipo mediante el parámetro <parameter>--type</parameter>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field reference</term>

          <listitem xml:lang="es">
            <para>Crea un campo que será una referencia a otra entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field set</term>

          <listitem xml:lang="es">
            <para>Crea un campo que devolverá una lista de elementos de una
            entidad relacionados con este elemento.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term xml:lang="es">field other</term>

          <listitem xml:lang="es">
            <para>Crea un campo de otro tipo no registrado.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Cada uno de estos comandos admiten algunos parámetros que son
      comunes entre ellos o muy específicos. Entre los comunes (para la
      mayoría) podemos encontrar los siguientes:</para>

      <variablelist>
        <varlistentry>
          <term>--fieldName</term>

          <listitem>
            <para xml:lang="es">Nombre del campo que vamos a generar.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--class</term>

          <listitem>
            <para xml:lang="es">Clase entidad donde vamos a crear el campo.
            Admite el uso de <literal>~</literal> y tiene autocompletado. No
            es necesario especificar si acabamos de crear una entidad.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--notNull y --nullRequired</term>

          <listitem>
            <para xml:lang="es">Especifica el comportamiento de campo antes
            los valores nulos.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--column</term>

          <listitem>
            <para xml:lang="es">Nombre de la columna en BBDD donde se
            almacenará el valor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>--sizeMax y --sizeMin</term>

          <listitem>
            <para xml:lang="es">Limitaciones de tamaño.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para xml:lang="es">Existen más opciones dependiendo del tipo de dato,
      para más información ver la ayuda de la consola.</para>

      <important>
        <title xml:lang="es">Enlazar modelo de entidades con base de datos
        existente</title>

        <para xml:lang="es">Notar que el parámetro <command>--column</command>
        permiten que en tiempo de creación podemos indicar que la entidad sea
        persistente sobre un modelo relacional creado con anterioridad.</para>
      </important>

      <important>
        <title xml:lang="es">Eliminar y modificar campos</title>

        <para xml:lang="es">No se pueden eliminar o modificar los campos desde
        línea de comandos. Esto se debe realizar usando el IDE. Para más
        información ver la sección <link
        linkend="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">Modificar
        una entidad</link>.</para>
      </important>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-con-comando_field_ejemplos">
      <title xml:lang="es">Proyecto ejemplo</title>

      <para xml:lang="es">El modelo del dominio del proyecto de la aplicación
      de venta de pizzas lo crearemos con la siguiente secuencia de
      comandos:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Topping:</para>

          <programlisting>roo&gt; <command>entity --class ~.domain.Topping --testAutomatically</command>
~.domain.Topping roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
                </programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Base:</para>

          <programlisting>~.domain.Topping roo&gt; <command>entity --class ~.domain.Base --testAutomatically</command>
~.domain.Base roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
                </programlisting>
        </listitem>

        <listitem>
          <para xml:lang="es">Pizza:</para>

          <programlisting>~.domain.Base roo&gt; <command>entity --class ~.domain.Pizza --testAutomatically</command>
~.domain.Pizza roo&gt; <command>field string --fieldName name --notNull --sizeMin 2 
--comment "Nombre de la pizza" --column pizza_nombre --regexp [A-Za-z0-9].*</command>
~.domain.Pizza roo&gt; <command>field number --fieldName price --type java.lang.Float</command>
~.domain.Pizza roo&gt; <command>field set --fieldName toppings --type ~.domain.Topping</command>
~.domain.Pizza roo&gt; <command>field reference --fieldName base --type ~.domain.Base</command>
                </programlisting>

          <para xml:lang="es">Esta secuencia de comandos genera la siguiente
          clase Java:</para>

          <programlistingco>
            <areaspec>
              <area coords="10" xml:id="ex.regexp"></area>

              <area coords="16" xml:id="ex.set"></area>

              <area coords="21" xml:id="ex.entity"></area>
            </areaspec>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Pizza {

    @NotNull
    @Column(name = "pizza_nombre")
    @Size(min = 2)
    @Pattern(regexp = "[A-Za-z0-9].*")
    private String name;

    private Float price;

    @ManyToMany(cascade = CascadeType.ALL)
    private Set&lt;es.gva.cit.sentencias.domain.Topping&gt; toppings = 
      new java.util.HashSet&lt;es.gva.cit.sentencias.domain.Topping&gt;();

    @ManyToOne(targetEntity = Base.class)
    @JoinColumn
    private Base base;
}</programlisting>

            <calloutlist>
              <callout arearefs="ex.regexp">
                <para>Validación del texto</para>
              </callout>

              <callout arearefs="ex.set">
                <para xml:lang="es">Asociación con un conjunto de
                entidades</para>
              </callout>

              <callout arearefs="ex.entity">
                <para xml:lang="es">Asociación con otra entidad</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </listitem>

        <listitem>
          <para xml:lang="es">PizzaOrder:</para>

          <programlisting>~.domain.Pizza roo&gt; <command>entity --class ~.domain.PizzaOrder --testAutomatically</command>
~.domain.PizzaOrder roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
~.domain.PizzaOrder roo&gt; <command>field string --fieldName address --notNull --sizeMax 30</command>
~.domain.PizzaOrder roo&gt; <command>field number --fieldName total --type java.lang.Float</command>
~.domain.PizzaOrder roo&gt; <command>field date --fieldName deliveryDate --type java.util.Date</command>
~.domain.PizzaOrder roo&gt; <command>field set --fieldName pizzas --type ~.domain.Pizza</command>
                </programlisting>
        </listitem>
      </orderedlist>

      <para>En este punto, se ha completado la versión inicial del modelo del
      dominio</para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_crear-a-mano">
    <title xml:lang="es">Crear una entidad con un IDE</title>

    <para>Llegados a este punto recordar que, para pasar a trabajar con
    Eclipse deberíamos ejecutar, si no lo hemos hecho todavía, el comando
    <emphasis role="bold">perform eclipse</emphasis> desde la línea de
    comandos de gvNIX o bien su equivalente maven <emphasis role="bold">mvn
    eclipse:eclipse</emphasis> desde el interprete de comandos del
    sistema.</para>

    <para xml:lang="es">Como hemos visto en el punto anterior el código Java
    generado no tiene ningún elemento particular de Roo, por lo que crear
    nuestro modelo del dominio con cualquier IDE consiste en codificar las
    clases Java con las anotaciones que permiten a Roo monitorizar y generar
    código.</para>

    <para>Es importante destacar que el objetivo de utilizar anotaciones de
    Roo es permitir que nuestro proyecto también se pueda gestionar
    (automáticamente o por el desarrollador) con el intérprete de comandos, de
    esta forma, podemos codificar clases con nuestro IDE y arrancando el
    intérprete de comandos de Roo se generará toda la infraestructura
    necesaria para la persistencia, validación, etc</para>

    <para xml:lang="es">Entre las anotaciones que podemos utilizar en la
    codificación de nuestro modelo, podemos destacar:</para>

    <variablelist>
      <varlistentry>
        <term>@Entity</term>

        <listitem>
          <para xml:lang="es">Anotación JPA que identifica esta clase como
          persistente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>@RooJavaBean</term>

        <listitem>
          <para xml:lang="es">Anotación que informa a Roo que debe generar los
          getter/setter que falten para acceder modificar los valores de
          nuestros campos. Si alguno estuviese generado, el framework no lo
          generará.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>@RooToString</term>

        <listitem>
          <para xml:lang="es">Anotación que informa a Roo que debe genera un
          método automático <methodname>toString()</methodname> para esta
          clase. Este método se genera a partir de las propiedades de la
          clase.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>@RooEntity</term>

        <listitem>
          <para xml:lang="es">Anotación que informa Roo que esta clase es una
          entidad. Esta anotación genera todos lo métodos necesarios de
          persistencia y manejo básicos necesario para manejar la
          entidad.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <important>
      <para>gvNIX solo reconoce las <emphasis>anotaciones de las
      propiedades</emphasis> que se encuentren <emphasis>en la declaración de
      la propiedad</emphasis> de la clase, <emphasis>no en los métodos
      accesores (getter/setter)</emphasis></para>
    </important>

    <important>
      <para>gvNIX solo distinguirá como entidad las <emphasis>clases
      correctamente anotadas</emphasis> y que estén <emphasis>dentro del
      paquete base de la aplicación (o subpaquetes)</emphasis>.</para>
    </important>

    <important>
      <para>Notar que para usar las anotaciones hay que importar sus
      clases:</para>

      <programlisting>import javax.persistence.Entity;
import org.springframework.roo.addon.javabean.RooJavaBean;
import org.springframework.roo.addon.entity.RooEntity;
import org.springframework.roo.addon.tostring.RooToString;</programlisting>
    </important>

    <para>Consultar el <link
    xlink:href="http://static.springsource.org/spring-roo/org.springframework.roo.annotations/apidocs/">API
    de las anotaciones</link> para un detalle exhaustivo de las anotaciones y
    parámetros disponibles.</para>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_modificar-modelo">
    <title xml:lang="es">Modificar una entidad</title>

    <para xml:lang="es">Si queremos añadir un campo a una entidad existente
    podemos hacerlo desde la línea de comandos de gvNIX. Cuando estamos
    trabajando sobre entidades en la línea de comandos, gvNIX se situa en el
    contexto de la entidad (por eso en el ejemplo de la sección anterior, al
    añadir campos sobre la entidad PizzaOrder no hace falta especificar en
    cada comando sobre que entidad estamos trabajando).</para>

    <para xml:lang="es">Para añadir un nuevo campo deberemos usar el mismo
    comando <emphasis role="bold">field</emphasis> indicando sobre que entidad
    queremos trabajar mediante el parámetro
    <emphasis>--class.</emphasis><programlisting>roo&gt; <command>field string --fieldName refCode --notNull --sizeMin 2 --class ~.domain.Pizza</command>
~.domain.Pizza roo&gt; </programlisting>Notar que tras ejecutar el comando
    <emphasis>field</emphasis> indicando el parámetro
    <emphasis>--class</emphasis> nos quedamos en el contexto de la entidad
    Pizza y por tanto si seguimos ejecutando el comando field sin indicar
    <emphasis>--class</emphasis> los campos se añadirán a esta entidad.</para>

    <note>
      <para>También podemos situarnos en el contexto de una entidad (o de
      cualquier clase del proyecto) mediante el comando <emphasis
      role="bold">focus</emphasis> indicando el parámetro
      <emphasis>--class</emphasis>.</para>

      <programlisting>roo&gt; <emphasis role="bold">focus --class ~.domain.Pizza</emphasis>
~.domain.Pizza roo&gt;</programlisting>
    </note>

    <para xml:lang="es">A diferencia de la creación de entidades, la
    modificación del modelo del dominio sólo puede hacerse utilizando nuestro
    IDE habitual.</para>

    <variablelist>
      <varlistentry>
        <term>Eliminar una entidad</term>

        <listitem>
          <para xml:lang="es">Borrar el fichero <filename>.java</filename> de
          la clase Java y automáticamente se detectará el cambio y se
          limpiarán todos los elementos relacionados: ficheros
          {entidad}_Roo_*.aj, controladores asociados, elementos de menú,
          etc.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Eliminar un atributo</term>

        <listitem>
          <para xml:lang="es">Borrarlo de la clase Java y todos los
          componentes relacionados serán actualizados automáticamente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Modificar un atributo</term>

        <listitem>
          <para xml:lang="es">Modificar el atributo deseado en la clase Java y
          gvNIX actualizará los ficheros relacionados para contemplar los
          cambios.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_definicion_identificadores-compuestos">
    <title xml:lang="es">Identificadores compuestos</title>

    <para><emphasis>TBC</emphasis></para>

    <!--
        <para xml:lang="es">Ahora mismo no está completo el soporte para
        identificadores que estén compuestos de mas de un campo.</para>

        <para xml:lang="es">Para más información ver:</para>

        <itemizedlist>
          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-505">ROO-505</link></para>
          </listitem>

          <listitem>
            <para><link
            xlink:href="https://jira.springsource.org/browse/ROO-345">ROO-345</link></para>
          </listitem>
        </itemizedlist>
-->
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente">
    <title xml:lang="es">Enlazar modelo de entidades con base de datos
    existente</title>

    <para xml:lang="es">Una vez hemos desarrollado el modelo de entidades de
    nuestra aplicación, puede ocurrir que la persistencia deba realizarse
    sobre un modelo relacional concreto, en estos casos podemos utilizar
    nuestro IDE para modificar las clases Java y plasmar la información
    necesaria que permitirá a gvNIX actualizar el sistema de
    persistencia.</para>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_tablas">
      <title>Usar una tabla concreta</title>

      <para>Con la anotación de clase <classname><link
      xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Table.html">@Table</link></classname>
      podemos indicar el nombre de la tabla donde se guardarán los objetos de
      la clase.</para>

      <example>
        <title>Uso de la anotación</title>

        <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
@Table(name = "ENT1")
public class Entity1 {

    private String field1;
}</programlisting>
      </example>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_columnas">
      <title>Usar una columna concreta</title>

      <para>Existen varias anotaciones que permiten definir la correspondencia
      entre atributos de una entidad y las columnas de la tabla.</para>

      <para>Las más importantes son:</para>

      <variablelist>
        <varlistentry>
          <term><classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Column.html">@Column</link></classname></term>

          <listitem>
            <para>Indicar en qué columna de la base de datos se almacenará el
            valor del atributo. Si se omite este anotación se usan ajustes por
            defecto.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Transient.html">@Transient</link></classname></term>

          <listitem>
            <para>Indica que el atributo de la clase Java no tiene
            representación en la tabla (no será cargado ni almacenado).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinColumn.html">@JoinColumn</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinColumns.html">@JoinColumns</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OneToOne.html">@OneToOne</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/ManyToOne.html">@ManyToOne</link></classname></term>

          <listitem>
            <para>Definir la correspondencia de una asociación
            <emphasis>N-1.</emphasis></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/JoinTable.html">@JoinTable</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OneToMany.html">@OneToMany</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/ManyToMany.html">@ManyToMany</link></classname>,
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/OrderBy.html">@OrderBy</link></classname></term>

          <listitem>
            <para>Definir la correspondencia de una asociación
            <emphasis>1-N</emphasis> o <emphasis>N-M.</emphasis></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title>Uso de las anotaciones</title>

        <programlistingco>
          <areaspec>
            <area coords="8" xml:id="ex.annot.field"></area>

            <area coords="11" xml:id="ex.annot.trans"></area>

            <area coords="13" xml:id="ex.annot.preci"></area>

            <area coords="16" xml:id="ex.annot.many"></area>

            <area coords="17" xml:id="ex.annot.join"></area>

            <area coords="20" xml:id="ex.annot.one"></area>
          </areaspec>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
@Table(name = "ENT1")
public class Entity1 {

    private String field1;

    @Transient
    private String tmpInfo;

    @Column(name="ORDER_COST", precision=12, scale=2)
    private BigDecimal cost;

    @ManyToOne(targetEntity = Customer.class)
    @JoinColumn(name = "CUSTOMER_ID")
    private Customer customer;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "entity1")
    private Set&lt;Price&gt; prices = new java.util.HashSet&lt;Price&gt;();
}</programlisting>

          <calloutlist>
            <callout arearefs="ex.annot.field">
              <para>Este campo se cargará y almacenará en la columna
              <literal>field1</literal> de la tabla
              <literal>ENT1</literal></para>
            </callout>

            <callout arearefs="ex.annot.trans">
              <para>Este campo no se tendrá en cuenta en la carga y guardado
              de la base de datos.</para>
            </callout>

            <callout arearefs="ex.annot.preci">
              <para>Este campo numérico se cargará y almacenará en la columna
              <literal>ORDER_COST</literal> de la tabla
              <literal>ENT1</literal>, usando los valores de
              <emphasis>precisión</emphasis> y <emphasis>escala</emphasis>
              especificados.</para>
            </callout>

            <callout arearefs="ex.annot.many">
              <para>Declara que la propiedad tiene origen en una relación
              <emphasis>n-1</emphasis>, con la entidad
              <classname>Customer</classname>. La tablas de esta entidad y sus
              columnas se tomarán de las declaraciones que se hayan hecho en
              esa entidad.</para>
            </callout>

            <callout arearefs="ex.annot.join">
              <para>Especifica que la columna de clave ajena en la tabla
              <literal>ENT1</literal> para esta relación (con
              <classname>Customer</classname>) es
              <literal>CUSTOMER_ID</literal></para>
            </callout>

            <callout arearefs="ex.annot.one">
              <para>Declara que el campo <literal>prices</literal> es una
              relación <emphasis>1-n</emphasis> con la entidad
              <literal>Price</literal>. También declara que los cambios de
              <literal>Entity1</literal> se aplican en cascada sobre
              <literal>Price</literal>. El campo (propiedad en la clase java)
              que estable la clave ajena en <literal>Price</literal> se llama
              <literal>entity1</literal>.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_clave-primaria">
      <title>Clave primaria</title>

      <para>Por defecto, se genera un campo Id (propiedad en la clase java),
      de tipo <classname>java.lang.Long</classname>, como identificador (clave
      primaria) de la entidad. Para adaptarlo a nuestras necesidades:</para>

      <orderedlist>
        <listitem>
          <para>Configurar la anotación <link
          xlink:href="http://static.springsource.org/spring-roo/org.springframework.roo.annotations/apidocs/org/springframework/roo/addon/entity/RooEntity.html">@RooEntity</link>
          para ajustar el nombre del campo, tipo y nombre de columna en la
          tabla.</para>

          <example>
            <title>Uso de las anotaciones</title>

            <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(identifierField="entity1Id", 
        identifierType=Long.class, identifierColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>
          </example>
        </listitem>

        <listitem>
          <para>Añadir manualmente el campo en la clase java. La declaración
          se detectará por el framework que no la generará automáticamente. Un
          ejemplo de esto:</para>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ENT1_ID")
    private Long ent1Id;

    public Long getEnt1Id(){
        return ent1Id;
    }

    public void setEnt1Id(Long ent1Id){
        this.ent1Id = ent1Id;
    }

    private String field1;

}</programlisting>

          <para>Si se declara el campo de identificador en la clase java,
          también es necesario añadir sus métodos <emphasis>get y
          set</emphasis> manualmente.</para>

          <para>Para más información sobre las anotaciones JPA (como
          <classname><link
          xlink:href="http://java.sun.com/javaee/5/docs/api/javax/persistence/GeneratedValue.html">@GeneratedValue</link></classname>
          ) consultar el <link
          xlink:href="http://java.sun.com/javaee/5/docs/api/index.html?javax/persistence/package-summary.html">API</link>.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_campo-control-optimista">
      <title>Campo para el control de concurrencia optimista.</title>

      <para>Por defecto, se genera un campo de control de concurrencia
      optimista llamado <literal>version</literal> de tipo
      <classname>java.lang.Integer</classname>. Para ajustarlo disponemos de
      tres opciones:</para>

      <orderedlist>
        <listitem>
          <para>Configurar la anotación @RooEntity, ajustar el nombre del
          campo, y tipo. Si dejamos el nombre de campo a <emphasis>cadena
          vacía</emphasis> (<literal>""</literal>) no se generará ningún
          campo. Un ejemplo de esto:</para>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(versionField="version", 
        versionType=Long.class, identifierColumn="ENT_ID")
public class Entity1 {

    private String field1;

}</programlisting>

          <para>Otro ejemplo desactivando el control de concurrencia
          optimista:</para>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity(versionField="")
public class Entity1 {

    private String field1;

}</programlisting>
        </listitem>

        <listitem>
          <para>Añadir manualmente el campo en la clase java. La declaración
          se detectará por el framework que no la generará automáticamente. Un
          ejemplo de esto:</para>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Version
    @Column(name = "ENT1_VERSION")
    private Integer version;

    public Integer getVersion(){
        return ent1Id;
    }

    public void setVersion(Integer version){
        this.version = version;
    }

    private String field1;

}</programlisting>
        </listitem>

        <listitem>
          <para>Usar el control de concurrencia optimista de gvNIX. Para ello
          se debe usar el comando <command><link
          linkend="apendice-comandos_addon-persistence_occchecksum_occ-checksum-set">occ
          checksum set</link></command>. Con este comando la clase se quedará
          así:</para>

          <programlisting>@Entity
@RooJavaBean
@RooToString
@RooEntity
public class Entity1 {

    @Version
    @Transient
    private String occChekcsum;

    public String getOccChekcsum() {
        return this.occChekcsum;
    }

    public void setOccChekcsum(String checksum) {
        this.occChekcsum = checksum;
    }

    private String field1;

}</programlisting>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="guia-desarrollo_gestion-entidades_enlazar-base-datos-existente_regeneracion-bbdd">
      <title xml:lang="es">Regeneración de la Base de datos en cada
      arranque.</title>

      <para xml:lang="es">Recordar que por defecto, la configuración de Roo
      <emphasis role="bold">reconstruye la base de datos en cada ejecución de
      la aplicación</emphasis>. Cuando usamos una base de datos existente o
      compartida debemos cambiar este comportamiento.</para>

      <para xml:lang="es">Modificar el fichero
      <filename>src/main/resources/META-INF/persistence.xml</filename> y
      comentar la siguiente linea:</para>

      <programlisting>    &lt;!-- &lt;property name="hibernate.hbm2ddl.auto" value="create"/&gt; --&gt;</programlisting>
    </section>

    <section>
      <title>Clase Repartidor para nuestro proyecto de ejemplo</title>

      <programlisting>@RooJavaBean
@RooToString
@RooEntity
public class Repartidor {

    @NotNull
    @Size(min = 2)
    private java.lang.String name;

}</programlisting>

      <para>Generamos los test de integración para la nueva entidad y
      definimos la relación entre PizzaOrder y el Repartidor del pedido.
      También generamos el controlador que gestionará la nueva entidad.</para>

      <programlisting>roo&gt; <command>test integration --entity ~.domain.Repartidor</command>
...
roo&gt; <command>field reference --class ~.domain.PizzaOrder --fieldName repartidor --type ~.domain.Repartidor
</command>...
roo&gt; <command>controller scaffold --entity ~.domain.Repartidor --class ~.web.RepartidorController</command>
...
</programlisting>

      <para>Podemos volver a lanzar los test de integración para confirmar que
      todo se ha generado correctamente.</para>

      <programlisting>roo&gt; <command>perform tests
</command>...
[INFO] BUILD SUCCESSFUL</programlisting>
    </section>
  </section>

  <section xml:id="guia-desarrollo_gestion-entidades_ingenieria-inversa">
    <title xml:lang="es">Ingeniería inversa de entidades</title>

    <!--
      <para xml:lang="es">En el proyecto de Spring Roo se tiene planeado añadir
      soporte para soportar ingeniería inversa de entidades. En un principio
      nosotros sugerimos el uso de Hiberate Tools para realizar la tarea, pero
      desde el proyecto pretenden dar un soporte nativo a ello.</para>

      <para xml:lang="es">En la versión en desarrollo (v1.1.0M2) se ha
      iniciado ya el desarrollo del mecanismo para ello. Se puede ver más
      información en: <link
      xlink:href="https://jira.springsource.org/browse/ROO-435">ROO-435</link>.</para>
-->

    <para xml:lang="es">gvNIX permite la utilización de ingeniería inversa
    para gestionar las entidades JPA del proyecto, lo cual nos ofrece la
    opción de, que basado en la metainformación recopilada de la BBDD
    configurada en nuestro proyecto, nos genere todas las entidades con sus
    campos de manera automática. El encargado de esta funcionalidad es el
    Add-on <emphasis>Database Reverse Engineering</emphasis> (DBRE) que se
    instala en el proyecto mediante el comando <emphasis>addon
    install</emphasis>.</para>

    <section xml:id="guia-desarrollo_ingenieria-inversa_instalacion">
      <title>Instalación del Add-on</title>

      <para>El Add-on DBRE soporta la mayoria de las Bases de Datos
      relacionales que pueden ser gestionadas por gvNIX (MySQL, MS SQL,
      PostgreSQL). El driver a utilizar lo detecta gvNIX y nos pregunta si
      queremos descargarlo e instalarlo la primera vez que invocamos los
      comandos <emphasis>database introspect</emphasis> o <emphasis>database
      reverse engineer.</emphasis><warning>
          <para>Si lanzamos este comando con la configuración actual del
          proyecto que usa HYPERSONIC_IN_MEMORY como BBDD nos indicará que no
          hay driver disponible para HSQLDB.</para>
        </warning>Si lo hacemos en un proyecto que tenga MySQL como
      BBDD:<programlisting>roo&gt; <emphasis role="bold">database introspect --schema no-schema-required</emphasis>
Located add-on that may offer this JDBC driver
1 found, sorted by rank; T = trusted developer; R = Roo 1.1 compatible
<emphasis role="bold">ID T R DESCRIPTION -------------------------------------------------------------
01 Y Y 5.1.13.0001 #jdbcdriver driverclass:com.mysql.jdbc.Driver. This...</emphasis>
--------------------------------------------------------------------------------
[HINT] use 'addon info id --searchResultId ..' to see details about a search result
[HINT] use 'addon install id --searchResultId ..' to install a specific search result, or
[HINT] use 'addon install bundle --bundleSymbolicName TAB' to install a specific add-on version
JDBC driver not available for 'com.mysql.jdbc.Driver'</programlisting><programlisting>ID T R DESCRIPTION ------------------------------------------------------------- 
01 Y Y 5.1.13.0001 #jdbcdriver driverclass:com.mysql.jdbc.Driver. This...</programlisting>esta
      sección de la salida del comando database introspect nos indica que hay
      disponible un driver para el soporte de DBRE y nos sugiere que hacer a
      continuación (lineas que empiezan con [HINT]).</para>

      <para>Podemos obtener más información sobre el dirver mediante:</para>

      <programlisting>roo&gt; <command>addon info id --searchResultId 01</command></programlisting>

      <para>Donde le estamos diciendo que nos ofreca más información
      (--searchResultId) del Add-on 01 que nos ha devuelto el comando
      anterior.</para>

      <para>Para instalarlo se puede hacer usando el id del Add-on o bien su
      nombre simbólico.<programlisting>roo&gt; <command>addon install id --searchResultId 01</command></programlisting></para>

      <para>o</para>

      <programlisting>roo&gt; <command>addon install bundle --bundleSymbolicName org.springframework.roo.wrapping.mysql-connector-java;&lt;version&gt;</command></programlisting>

      <para>Al instante tendremos disponible el driver JDBC y podremos empezar
      a usar los comandos <emphasis>database introspect</emphasis> o
      <emphasis>database reverse.</emphasis></para>
    </section>

    <section>
      <title>Comandos del Add-on DBRE</title>

      <para>DBRE ofrece dos comandos: <emphasis>database introspect</emphasis>
      o <emphasis>database reverse engineer.</emphasis></para>

      <programlisting>roo&gt; <command>database introspect --schema</command> &lt;nombre del esquema&gt; --file &lt;nombre del fichero&gt; --enableViews</programlisting>

      <para>el comando nos mostrará la estructura de la BBDD en formato XML.
      Es obligatorio indicar el esquema al que nos referimos, para ello
      presionado la tecla TAB nos mostrará una lista de esquemas de nuestra
      BBDD. Algunas BBDD no usan el concepto de esquema, MySQL entre ellas,
      aun así la opción --schema es necesaria y por ello el asistente nos
      mostraría como esquema "no-schema-required". La opción --file indica que
      guarde la información también en un fichero determinado y --enableViews
      especifica que también debe recoger información sobre las vistas.</para>

      <programlisting>roo&gt; <command>database reverse engineer --schema</command> --package --testAutomatically --enableViews --includeTables --excludeTables</programlisting>

      <para>este comando crea las entidades JPA de nuestro proyecto
      representando las tablas y columnas de nuestra BBDD. Al igual que antes
      --schema es obligatorio. Podemos usar --package para indicar el nombre
      del paquete de nuestro proyecto donde crear las clases Java, si no lo
      hacemos en las siguientes ejecuciones del comando, las clases se crearan
      en el mismo paquete que en la primera vez.</para>

      <para>Podemos indicarle que genere automáticamente los test de
      integración para cada una de las nuevas entidades creadas con
      --testAutomatically.</para>

      <para>Si indicamos la opción --enableViews en este comando, se crearan
      entidades JPA que representes las vistas que se encuentren en la
      introspección de la BBDD. Esto solo debería usarse en casos especiales
      como pueden ser aquellas BBDD que dispongan de disparadores
      (<emphasis>triggers</emphasis>).</para>

      <para>Podemos filtrar las tablas que se van a tener en cuenta en la
      operación. --includeTables indicará cuales son las tablas que queremos
      que sean tenidas en cuenta. Podemos indicar uno o varios nombres de
      tabla, si indicamos más de uno deberemos indicarlos entre comillas
      dobles. Se permite el uso de * para hacer matching de uno o varios
      caracteres en la búsqueda o el uso de ? para indicar un único caracter.
      De manera opuesta --excludeTables indica que tablas no han de ser
      tenidas en cuenta durante la ingeniería inversa y admite el mismo uso de
      * y ?. Por ejemplo:</para>

      <programlisting>roo&gt; database reverse engineer --schema no-schema-required --package ~.domain --includeTables "foo* bar?"</programlisting>

      <para>Con este comando se generarían las entidades de aquellas tablas de
      la BBDD que tengan como nombre foo&lt;cualquier cosa&gt; y bar&lt;otro
      caracter más&gt;, por ejemplo 'foo_tabla_cool' y 'bars'.</para>

      <warning>
        <para>al excluir tables, además de evitar que se creen las entidades
        de estas tablas se evita tabmién que no se creen las asociaciones y
        relaciones en otras entidades. Esto se hace para evitar problemas de
        compilación en el código del proyecto.</para>
      </warning>

      <para>Como DBRE ofrece ingeniería inversa incremental, se puede ejecutar
      este comando tantas veces como se necesite y de esta forma gvNIX
      mantendrá todas las entidades JPA de manera automática.</para>

      <important>
        <para>Cuando empezamos a usar el Add-on de ingeniería inversa se
        modifica el fichero META-INF/persistence.xml cambiando el valor de la
        propiedad <emphasis>hibernate.hbm2ddl.auto</emphasis> por el de
        validate para evitar que pongamos en peligro la integridad de la BBDD
        a la que estamos conectados en nuestro proyecto.</para>
      </important>
    </section>

    <section>
      <title>Anotación @RooDbManaged</title>

      <para>Tal y como se ha comentado en la sección <link
      linkend="guia-desarrollo_gestion-entidades_definicion_crear-a-mano">Crear
      una entidad con un IDE</link> se hace uso de una serie de anotaciones
      Java para que gvNIX gestione el código del proyecto. A las anotaciones
      descritas anteriormente añadimos ahora la anotación @RooDbManaged que se
      le añade a todas las entidades creadas durante el proceso de ingeniería
      inversa.</para>

      <programlisting>@RooJavaBean
@RooToString
<command>@RooDbManaged</command>(automaticallyDelete = true)
@RooEntity(table = "pizza")
public class Pizza {
}</programlisting>

      <para>El atributo <emphasis>automaticallyDelete</emphasis> que acompaña
      a la anotación y que toma el valor <emphasis>true</emphasis> indica a
      gvNIX que puede eliminar la entidad en el caso de que la tabla de la
      BBDD a la cual hace referencia sea eliminada. Si el atributo toma el
      valor <emphasis>false</emphasis>, o si cualquier otra parte del código
      de esta entidad es modificado (elimnamos una anotación, añadimos algún
      método, ...) la entidad no se eliminará en caso de que la tabla
      desaparezca de la BBDD.</para>
    </section>

    <section>
      <title>Soporte de funcionalidades JPA 2.0</title>

      <para>El Add-on DBRE crea y mantiene claves primarias simples,
      compuestas y relaciones entre entidades.</para>

      <section>
        <title>Claves primarias simples</title>

        <para>Para el caso de claves primarias simples DBRE genera un campo
        identificador en el ITD de la entidad anotado con las anotaciones @Id
        y @Column tal como se hace al ejecutar el comando
        <emphasis>entity</emphasis>.</para>
      </section>

      <section>
        <title>Claves primarias compuestas</title>

        <para>En este caso DBRE realiza una solución más elaborada. Crea una
        clase Java que representa la clave primaria anotandala con
        @RooIdentifier(dbManaged = true) y añade el atributo "identifierType"
        con el nombre de la clase del identificador a la anotación @RooEntity
        en la clase de la entidad. Veamos un ejemplo:</para>

        <programlisting>@RooJavaBean
@RooToString
@RooDbManaged(automaticallyDelete = true)
@RooEntity(identifierType = LineItemPK.class, table = "line_item", schema = "order")
public class LineItem {
}</programlisting>

        <programlisting>@RooIdentifier(dbManaged = true)
public class LineItemPK {
}</programlisting>

        <para>En el ITD de la entidad LineItem existirá un campo anotado con
        @EmbeddedId del tipo LineItemPK:</para>

        <programlisting>privileged aspect LineItem_Roo_Entity {
    
    declare @type: LineItem: @Entity;
    
    declare @type: LineItem: @Table(name = "line_item", schema = "order");
    
    @PersistenceContext
    transient EntityManager LineItem.entityManager;
    
    @EmbeddedId
    private LineItemPK LineItem.id;
    
    public LineItemPK LineItem.getId() {
        return this.id;
    }
    
    public void LineItem.setId(LineItemPK id) {
        this.id = id;
    }

    ...
}</programlisting>

        <para>Y en el ITD de la clase que representa la clave compuesta
        tendremos los campos de la clave primaria con la anotación
        @Embeddable:</para>

        <programlisting>privileged aspect LineItemPK_Roo_Identifier {
    
    declare @type: LineItemPK: @Embeddable;
    
    @Column(name = "line_item_id", nullable = false)
    private BigDecimal LineItemPK.lineItemId;
    
    @Column(name = "order_id", nullable = false)
    private BigDecimal LineItemPK.orderId;
    
    public LineItemPK.new(BigDecimal lineItemId, BigDecimal orderId) {
        super();
        this.lineItemId = lineItemId;
        this.orderId = orderId;
    }

    private LineItemPK.new() {
        super();
    }

    ...
}</programlisting>
      </section>
    </section>
  </section>

  <section xml:id="guia-desarrollo_aplicacion-base_test-integracion">
    <title xml:lang="es">Pruebas unitarias</title>

    <para xml:lang="es">En la creación de entidades, especificando el
    parámetro <command>--testAutomatically</command> se generarán
    automáticamente las plantillas de pruebas unitarias que nos permitirán
    validar el buen funcionamiento de nuestro código.</para>

    <para>Para ejecutar los test utilizaremos el comando <command>perform
    tests</command>:</para>

    <programlisting>~.domain.PizzaOrder roo&gt; <command>perform test</command>
<computeroutput>[Thread-4] [INFO] Scanning for projects...
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] Building pizzashop
[Thread-4] [INFO]    task-segment: [test]
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] [aspectj:compile {execution: default}]
...
...
[Thread-4] -------------------------------------------------------
[Thread-4]  T E S T Soo&gt; 
[Thread-4] -------------------------------------------------------
[Thread-4] Running com.springsource.roo.pizzashop.domain.PizzaOrderIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.389 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.ToppingIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.174 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.PizzaIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.145 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.BaseIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.137 sec
[Thread-4] zzaOrder roo&gt; 
[Thread-4] Results :roo&gt; 
[Thread-4] zzaOrder roo&gt; 
[Thread-4] Tests run: 36, Failures: 0, Errors: 0, Skipped: 0
[Thread-4] zzaOrder roo&gt; 
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] BUILD SUCCESSFUL
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] Total time: 17 seconds
[Thread-4] [INFO] Finished at: Wed Jun 16 21:10:22 CEST 2010
[Thread-4] [INFO] Final Memory: 45M/299M
[Thread-4] [INFO] ------------------------------------------------------------------------</computeroutput>
~.domain.PizzaOrder roo&gt;</programlisting>
  </section>
</chapter>
