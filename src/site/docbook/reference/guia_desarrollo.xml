<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="guia-desarrollo"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Guía de desarrollo de aplicaciones con gvNIX</title>

  <section xml:id="guia-desarrollo_aplicacion-base">
    <title xml:lang="es">Crear una Aplicación Base con gvNIX</title>

    <para xml:lang="es">Utilizando Spring Roo para desarrollar una aplicación
    web para una <emphasis role="bold">Pizza Shop</emphasis>. Entre los
    requerimientos para la aplicación de la pizzería se incluye la capacidad
    para crear una Pizza por los empleados de la pizzería. La <emphasis
    role="bold">Pizza</emphasis> se compone de una <emphasis
    role="bold">Base</emphasis> y uno o más <emphasis
    role="bold">Toppings</emphasis> (Ingredientes). Además el dueño de la
    tienda quiere permitir que los clientes hagan pedidos a través de la
    web.</para>

    <para xml:lang="es">Después de esta breve explicación se ha creado un
    diagrama para el modelo de datos.</para>

    <figure>
      <title>Pizza Shop Domain Model</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pizza.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <section xml:id="guia-desarrollo_aplicacion-base_crear-projecto">
      <title xml:lang="es">Crear el nuevo proyecto</title>

      <para xml:lang="es">Creamos un nuevo proyecto Roo, para eso hay que
      crear el directorio del proyecto y acceder a la consola de gvNIX:</para>

      <programlisting>bash&gt; <command>mkdir pizza</command>
bash&gt; <command>cd pizza</command>
bash&gt; <command>gvnix</command>
<computeroutput>    ____  ____  ____  
   / __ \/ __ \/ __ \ 
  / /_/ / / / / / / / 
 / _, _/ /_/ / /_/ /  
/_/ |_|\____/\____/    1.1.0.M1 [rev 3a0b8a3]


Welcome to Spring Roo. For assistance press TAB or type "hint" then hit ENTER.</computeroutput>
roo&gt;</programlisting>

      <para xml:lang="es">Después accedemos a la consola de Roo y tecleamos
      <command>hint</command> para mostrar la guía en el proceso de creación
      del proyecto:</para>

      <programlisting>roo&gt; <command>hint</command> 
<computeroutput>Welcome to Roo! We hope you enjoy your stay!

Before you can use many features of Roo, you need to start a new project.

To do this, type 'project' (without the quotes) and then hit TAB.

Enter a --topLevelPackage like 'com.mycompany.projectname' (no quotes).
When you've finished completing your --topLevelPackage, press ENTER.
Your new project will then be created in the current working directory.

Note that Roo frequently allows the use of TAB, so press TAB regularly.
Once your project is created, type 'hint' and ENTER for the next suggestion.
You're also welcome to visit http://forum.springframework.org for Roo help.</computeroutput></programlisting>

      <para xml:lang="es">Nos muestra las instrucciones para continuar y crear
      un proyecto, teclear <command>project</command> y pulsar la tecla TAB
      (tabulador) y se mostrará el parámetro
      <parameter>--topLevelPackage</parameter> y definir el paquete principal
      del proyecto en este caso
      <package>com.springsource.roo.pizzashop</package>. Indicamos también con
      que JDK se va a trabajar en el proyecto añadiendo el atributo
      <parameter>--java 5</parameter>, el número 5 corresponde a la versión
      del JDK utilizado, en este caso JDK 1.5, si no se especifica Roo por
      defecto utiliza el JDK 1.6</para>

      <programlisting>roo&gt; <command>project --topLevelPackage com.springsource.roo.pizzashop --java 5</command>
<computeroutput>Created /Users/sschmidt/Development/workspaces/test9/pom.xml
Created SRC_MAIN_JAVA
Created SRC_MAIN_RESOURCES
Created SRC_TEST_JAVA
Created SRC_TEST_RESOURCES
Created SRC_MAIN_WEBAPP
Created SRC_MAIN_RESOURCES/META-INF/spring
Created SRC_MAIN_RESOURCES/META-INF/spring/applicationContext.xml
Created SRC_MAIN_RESOURCES/META-INF/spring/log4j.properties</computeroutput></programlisting>

      <para xml:lang="es">Como vemos la posición del shell ha cambiado, ahora
      estamos dentro del proyecto indicándolo con el nombre del paquete que
      hemos creado como base</para>

      <programlisting>com.springsource.roo.pizzashop roo&gt;</programlisting>

      <important>
        <para xml:lang="es">Si se utiliza el JDK1.5 hay ejecutar las
        siguientes intrucciones para evitar la excepción
        <errortext>NoClassDefFoundError:
        javax/xml/bind/JAXBException:</errortext><programlisting>roo&gt; <emphasis
              role="bold">dependency add --groupId javax.xml.bind --artifactId jaxb-api --version 2.1</emphasis>
<computeroutput>dependency add --groupId javax.xml.bind --artifactId jaxb-api --version 2.1</computeroutput>
roo&gt; <command>dependency add --groupId com.sun.xml.bind --artifactId jaxb-impl --version 2.1.3</command>
<computeroutput>Managed ROOT/pom.xml [Added dependency com.sun.xml.bind:jaxb-impl:2.1.3]</computeroutput></programlisting></para>
      </important>

      <para xml:lang="es">Se crea una estructura de carpetas parecida a la que
      crea maven.</para>

      <figure>
        <title xml:lang="es">Estructura de carpetas</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/projectfolders.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para xml:lang="es">Ahora se ha de definir el proveedor JPA con la BBDD
      asociada. Volvemos a teclear *hint* y nos muestra el siguiente paso a
      seguir:</para>

      <programlisting>roo&gt; <command>hint</command>
<computeroutput>Roo requires the installation of a JPA provider and associated database.

Type 'persistence setup' and then hit TAB three times.
We suggest you type 'H' then TAB to complete "HIBERNATE".
After the --provider, press TAB twice for database choices.
For testing purposes, type (or TAB) HYPERSONIC_IN_MEMORY.
If you press TAB again, you'll see there are no more options.
As such, you're ready to press ENTER to execute the command.

Once JPA is installed, type 'hint' and ENTER for the next suggestion.</computeroutput>
roo&gt;</programlisting>

      <para xml:lang="es">Creamos la persistencia utilizando los comandos que
      nos muestra y tabulando para que nos muestre las opciones
      disponibles:</para>

      <programlisting>roo&gt; <command>persistence setup --provider HIBERNATE --database HYPERSONIC_IN_MEMORY</command>
<computeroutput>Created SRC_MAIN_RESOURCES/META-INF/persistence.xml
Created SRC_MAIN_RESOURCES/META-INF/spring/database.properties
Managed SRC_MAIN_RESOURCES/META-INF/spring/applicationContext.xml
Managed ROOT/pom.xml [Added dependency org.hsqldb:hsqldb:1.8.0.10]
Managed ROOT/pom.xml [Added dependency org.hibernate:hibernate-core:3.5.0-Final]
Managed ROOT/pom.xml [Added dependency org.hibernate:hibernate-entitymanager:3.5.0-Final]
Managed ROOT/pom.xml [Added dependency org.hibernate.javax.persistence:hibernate-jpa-2.0-api:1.0.0.Final]
Managed ROOT/pom.xml [Added dependency org.hibernate:hibernate-validator:4.0.2.GA]
Managed ROOT/pom.xml [Added dependency javax.validation:validation-api:1.0.0.GA]
Managed ROOT/pom.xml [Added dependency cglib:cglib-nodep:2.2]
Managed ROOT/pom.xml [Added dependency javax.transaction:jta:1.1]
Managed ROOT/pom.xml [Added dependency org.springframework:spring-jdbc:${spring.version}]
Managed ROOT/pom.xml [Added dependency org.springframework:spring-orm:${spring.version}]
Managed ROOT/pom.xml [Added dependency commons-pool:commons-pool:1.5.4]
Managed ROOT/pom.xml [Added dependency commons-dbcp:commons-dbcp:1.3]
Managed ROOT/pom.xml</computeroutput>
roo&gt;</programlisting>

      <warning>
        <para><emphasis role="bold">Por defecto las aplicaciones de Spring Roo
        se configuran para que la Base de datos se regenere cada vez que se
        arranca la aplicación (borrando y creando de nuevo las tablas), por lo
        que es conveniente que si se utiliza una Base de datos preexistente se
        configure correctamente el fichero
        <filename>src/main/resources/META-INF/persistence.xml</filename> para
        evitar sorpresas desagradables.</emphasis></para>
      </warning>
    </section>

    <section xml:id="guia-desarrollo_aplicacion-base_crear-entidades">
      <title xml:lang="es">Crear las Entidades y los atributos</title>

      <para xml:lang="es">Ahora hay que crear las entidades, con sus atributos
      y las relaciones corespondientes a cada una que se han definido en el
      modelo. Volvemos a teclear <command>hint</command> para que nos muestre
      el siguiente paso y las opciones existentes:</para>

      <programlisting>roo&gt; <command>hint</command>
<computeroutput>You can create entities either via Roo or your IDE.
Using the Roo shell is fast and easy, especially thanks to the TAB completion.

Start by typing 'ent' and then hitting TAB twice.
Enter the --class in the form '~.domain.MyEntityClassName'
In Roo, '~' means the --topLevelPackage you specified via 'create project'.

After specify a --class argument, press SPACE then TAB. Note nothing appears.
Because nothing appears, it means you've entered all mandatory arguments.
However, optional arguments do exist for this command (and most others in Roo).
To see the optional arguments, type '--' and then hit TAB. Mostly you won't
need any optional arguments, but let's select the --testAutomatically option
and hit ENTER. You can always use this approach to view optional arguments.

After creating an entity, use 'hint' for the next suggestion.</computeroutput>
roo&gt;</programlisting>

      <para xml:lang="es">El comando <command>entity</command> tiene un número
      de atributos opcionales mientras que el atributo requerido es
      <parameter>--class</parameter>, además también se debe utilizar
      <parameter>--testAutomatically</parameter> para crear automáticamente
      los test de integración para el <emphasis>Domain Object</emphasis>. Para
      empezar crearemos la entidad <classname>Topping:</classname></para>

      <programlisting>roo&gt; <command>entity --class ~.domain.Topping --testAutomatically</command>
<computeroutput>Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingDataOnDemand.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingIntegrationTest.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping_Roo_Entity.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping_Roo_ToString.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingIntegrationTest_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingDataOnDemand_Roo_DataOnDemand.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingIntegrationTest_Roo_IntegrationTest.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingDataOnDemand_Roo_Configurable.aj</computeroutput>
~.domain.Topping roo&gt;</programlisting>

      <para xml:lang="es">Se ha utilizado para la creación de la entidad el
      carácter <literal>~</literal> para situarlo en el paquete base del
      proyecto. Ahora la consola Roo nos lleva dentro de la entidad Topping y
      así poder definir los campos y las relaciones que tenga. En este caso
      añadir el atributo <parameter>name</parameter> utilizando el comando
      <command>entity</command>. Volvemos a teclear <command>hint</command>
      para que Roo nos muestre el siguiente paso a seguir:</para>

      <programlisting>~.domain.Topping roo&gt; <command>hint</command>
<computeroutput>You can add fields to your entities using either Roo or your IDE.

To add a new field, type 'field' and then hit TAB. Be sure to select
your entity and provide a legal Java field name. Use TAB to find an entity
name, and '~' to refer to the top level package. Also remember to use TAB
to access each mandatory argument for the command.

After completing the mandatory arguments, press SPACE, type '--' and then TAB.
The optional arguments shown reflect official JSR 303 Validation constraints.
Feel free to use an optional argument, or delete '--' and hit ENTER.

If creating multiple fields, use the UP arrow to access command history.

After adding your fields, type 'hint' for the next suggestion.
To learn about setting up many-to-one fields, type 'hint relationships'.</computeroutput>
~.domain.Topping roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/ToppingDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Topping_Roo_ToString.aj</computeroutput>
~.domain.Topping roo&gt; </programlisting>

      <para xml:lang="es">Utilizando el comando <command>field
      {tipo}</command> se pueden añadir restricciones (constraints) a los
      campos usando los atributos opcionales como
      <parameter>--notNull</parameter> and <parameter>--sizeMin 2</parameter>.
      Estando en el contexto de la entidad, en este caso
      <classname>Topping</classname>, Roo añade los atributos a la clase
      utilizando el comando <command>entity</command>. Si se quiere añadir el
      campo a cualquier otra entidad se ha de especificar el atributo
      <parameter>--class</parameter> y la entidad a crear/modificar indicando
      también el paquete al que pertenece.</para>

      <para xml:lang="es">Ahora se han de crear las demás entidades y sus
      respectivos atributos correspondientes al modelo definido:</para>

      <programlisting>~.domain.Topping roo&gt; <command>entity --class ~.domain.Base --testAutomatically</command> 
<computeroutput>Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseDataOnDemand.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseIntegrationTest.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base_Roo_Entity.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base_Roo_ToString.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseIntegrationTest_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseDataOnDemand_Roo_DataOnDemand.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseIntegrationTest_Roo_IntegrationTest.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseDataOnDemand_Roo_Configurable.aj</computeroutput>
~.domain.Base roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/BaseDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Base_Roo_ToString.aj</computeroutput>
~.domain.Base roo&gt; <command>entity --class ~.domain.Pizza --testAutomatically</command>
<computeroutput>Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaIntegrationTest.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_Entity.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_ToString.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand_Roo_DataOnDemand.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaIntegrationTest_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaIntegrationTest_Roo_IntegrationTest.aj</computeroutput>
~.domain.Pizza roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_ToString.aj</computeroutput>
~.domain.Pizza roo&gt; <command>field number --fieldName price --type java.lang.Float</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_ToString.aj</computeroutput>
~.domain.Pizza roo&gt; </programlisting>

      <para xml:lang="es">Después de añadir el <varname>nombre</varname> y el
      <varname>precio</varname> a la entidad <classname>Pizza</classname> hay
      que definir las relaciones con <classname>Base</classname> y
      <classname>Topping</classname>. Primero la relación
      <emphasis>m:n</emphasis> (Una <classname>Pizza</classname> puede tener
      varios <classname>Topping</classname> y un
      <classname>Topping</classname> puede ser utilizado en varias
      <classname>Pizzas</classname>) entre <classname>Pizza</classname> y
      <classname>Topping</classname>. Para crear una relación
      <emphasis>many-to-many</emphasis> Roo proporciona el siguiente
      comando:</para>

      <programlisting>~.domain.Pizza roo&gt; <command>field set --fieldName toppings --element ~.domain.Topping</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_JavaBean.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_ToString.aj</computeroutput>
~.domain.Pizza roo&gt;</programlisting>

      <para xml:lang="es">De una manera parecida se definen las relaciones
      <emphasis>1:1</emphasis> entre las entidades Pizza y Base usando el
      comando:</para>

      <programlisting>~.domain.Pizza roo&gt; <command>field reference --fieldName base --type ~.domain.Base</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/Pizza_Roo_ToString.aj</computeroutput>
~.domain.Pizza roo&gt;</programlisting>

      <para xml:lang="es">De la misma manera se han de crear las entidades y
      relaciones <classname>PizzaOrder</classname>:</para>

      <programlisting>~.domain.Pizza roo&gt; <command>entity --class ~.domain.PizzaOrder --testAutomatically</command> 
<computeroutput>Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand.java
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderIntegrationTest.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_Entity.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_DataOnDemand.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderIntegrationTest_Roo_Configurable.aj
Created SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderIntegrationTest_Roo_IntegrationTest.aj</computeroutput>
~.domain.PizzaOrder roo&gt; <command>field string --fieldName name --notNull --sizeMin 2</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj</computeroutput>
~.domain.PizzaOrder roo&gt; <command>field string --fieldName address --sizeMax 30</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj</computeroutput>
~.domain.PizzaOrder roo&gt; <command>field number --fieldName total --type java.lang.Float</command> 
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj</computeroutput>
~.domain.PizzaOrder roo&gt; <command>field date --fieldName deliveryDate --type java.util.Date</command>
<computeroutput>Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_JavaBean.aj
Managed SRC_TEST_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrderDataOnDemand_Roo_DataOnDemand.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj</computeroutput>
~.domain.PizzaOrder roo&gt; <command>field set --fieldName pizzas --element ~.domain.Pizza</command>
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder.java
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_JavaBean.aj
Managed SRC_MAIN_JAVA/com/springsource/roo/pizzashop/domain/PizzaOrder_Roo_ToString.aj
~.domain.PizzaOrder roo&gt; </programlisting>

      <para xml:lang="es">Con esto concluye el diseño del modelo de
      entidades.</para>
    </section>

    <section xml:id="guia-desarrollo_aplicacion-base_test-integracion">
      <title xml:lang="es">Test de Integración</title>

      <para xml:lang="es">Después de haber creado la primera iteración del
      modelo de objetos se ha de hacer una comprobación ejecutando los test de
      integración que se han ido creando a medida que añadíamos una entidad.
      Para ejecutar los test utilizaremos el comando <command>perform
      tests</command>:</para>

      <programlisting>~.domain.PizzaOrder roo&gt; <command>perform test</command>
<computeroutput>[Thread-4] Warning: JAVA_HOME environment variable is not set.
[Thread-4] [INFO] Scanning for projects...
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] Building pizzashop
[Thread-4] [INFO]    task-segment: [test]
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] [aspectj:compile {execution: default}]
[Thread-4] [WARNING] advice defined in org.springframework.mock.staticmock.AnnotationDrivenStaticEntityMockingControl has not been applied [Xlint:adviceDidNotMatch]
[Thread-4] [WARNING] advice defined in org.springframework.mock.staticmock.AbstractMethodMockingControl has not been applied [Xlint:adviceDidNotMatch]
[Thread-4] [INFO] [resources:resources {execution: default-resources}]
[Thread-4] [WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[Thread-4] [INFO] Copying 4 resources
[Thread-4] [INFO] [compiler:compile {execution: default-compile}]
[Thread-4] [INFO] Nothing to compile - all classes are up to date
[Thread-4] [INFO] [aspectj:test-compile {execution: default}]
[Thread-4] [WARNING] advice defined in org.springframework.orm.jpa.aspectj.JpaExceptionTranslatorAspect has not been applied [Xlint:adviceDidNotMatch]
[Thread-4] [WARNING] advice defined in org.springframework.mock.staticmock.AnnotationDrivenStaticEntityMockingControl has not been applied [Xlint:adviceDidNotMatch]
[Thread-4] [WARNING] advice defined in org.springframework.mock.staticmock.AbstractMethodMockingControl has not been applied [Xlint:adviceDidNotMatch]
[Thread-4] [INFO] [resources:testResources {execution: default-testResources}]
[Thread-4] [WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[Thread-4] [INFO] Copying 0 resource
[Thread-4] [INFO] [compiler:testCompile {execution: default-testCompile}]
[Thread-4] [INFO] Nothing to compile - all classes are up to date
[Thread-4] [INFO] [surefire:test {execution: default-test}]
[Thread-4] [INFO] Surefire report directory: /tmp/test-gvNIX/t3/target/surefire-reports
[Thread-4] zzaOrder roo&gt; 
[Thread-4] -------------------------------------------------------
[Thread-4]  T E S T Soo&gt; 
[Thread-4] -------------------------------------------------------
[Thread-4] Running com.springsource.roo.pizzashop.domain.PizzaOrderIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.389 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.ToppingIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.174 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.PizzaIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.145 sec
[Thread-4] Running com.springsource.roo.pizzashop.domain.BaseIntegrationTest
[Thread-4] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.137 sec
[Thread-4] zzaOrder roo&gt; 
[Thread-4] Results :roo&gt; 
[Thread-4] zzaOrder roo&gt; 
[Thread-4] Tests run: 36, Failures: 0, Errors: 0, Skipped: 0
[Thread-4] zzaOrder roo&gt; 
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] BUILD SUCCESSFUL
[Thread-4] [INFO] ------------------------------------------------------------------------
[Thread-4] [INFO] Total time: 17 seconds
[Thread-4] [INFO] Finished at: Wed Jun 16 21:10:22 CEST 2010
[Thread-4] [INFO] Final Memory: 45M/299M
[Thread-4] [INFO] ------------------------------------------------------------------------</computeroutput>
~.domain.PizzaOrder roo&gt;</programlisting>
    </section>

    <section xml:id="guia-desarrollo_aplicacion-base_usar-eclipse">
      <title xml:id="es">Utilizar Eclipse como IDE</title>

      <para xml:lang="es">Para crear una estructura de proyecto eclipse Roo
      hay que utilizar el comando <command>perform eclipse</command>:</para>

      <programlisting>~.domain.PizzaOrder roo&gt; <command>perform eclipse</command>
<computeroutput>[Thread-6] Warning: JAVA_HOME environment variable is not set.
[Thread-6] [INFO] Scanning for projects...
[Thread-6] [INFO] ------------------------------------------------------------------------
[Thread-6] [INFO] Building pizzashop
[Thread-6] [INFO]    task-segment: [eclipse:clean, eclipse:eclipse]
[Thread-6] [INFO] ------------------------------------------------------------------------
[Thread-6] [INFO] [eclipse:clean {execution: default-cli}]
[Thread-6] [INFO] Deleting file: .project
[Thread-6] [INFO] Deleting file: .classpath
[Thread-6] [INFO] Deleting file: .wtpmodules
[Thread-6] [INFO] Deleting file: .component
[Thread-6] [INFO] Deleting file: org.eclipse.wst.common.component
[Thread-6] [INFO] Deleting file: org.eclipse.wst.common.project.facet.core.xml
[Thread-6] [INFO] Deleting file: org.eclipse.jdt.core.prefs
[Thread-6] [INFO] Deleting file: org.eclipse.ajdt.ui.prefs
[Thread-6] [INFO] Preparing eclipse:eclipse
[Thread-6] [INFO] [aspectj:compile {execution: default}]
[Thread-6] [INFO] [eclipse:eclipse {execution: default-cli}]
[Thread-6] [INFO] Adding support for WTP version 2.0.
[Thread-6] [INFO] Using Eclipse Workspace: null
[Thread-6] [INFO] Adding default classpath container: org.eclipse.jdt.launching.JRE_CONTAINER
[Thread-6] [INFO] Wrote settings to /tmp/test-gvNIX/t3/.settings/org.eclipse.jdt.core.prefs
[Thread-6] [INFO] Wrote Eclipse project for "pizzashop" to /tmp/test-gvNIX/t3.
[Thread-6] [INFO] r roo&gt; 
[Thread-6]        Javadoc for some artifacts is not available.
[Thread-6]        Please run the same goal with the -DdownloadJavadocs=true parameter in order to check remote repositories for javadoc.
[Thread-6]        List of artifacts without a javadoc archive:
[Thread-6]          o cglib:cglib-nodep:2.2
[Thread-6]          o com.sun.xml.bind:jaxb-impl:2.1.3
[Thread-6]          o javax.xml.bind:jaxb-api:2.1
[Thread-6]          o javax.xml.stream:stax-api:1.0-2
[Thread-6]          o javax.activation:activation:1.1
[Thread-6]          o commons-dbcp:commons-dbcp:1.3
[Thread-6]          o commons-pool:commons-pool:1.5.4
[Thread-6]          o javax.annotation:jsr250-api:1.0
[Thread-6]          o javax.servlet:servlet-api:2.5
[Thread-6]          o javax.transaction:jta:1.1
[Thread-6]          o javax.validation:validation-api:1.0.0.GA
[Thread-6]          o junit:junit:4.8.1
[Thread-6]          o log4j:log4j:1.2.15
[Thread-6]          o org.aspectj:aspectjrt:1.6.9.M2
[Thread-6]          o org.hibernate:hibernate-core:3.5.0-Final
[Thread-6]          o antlr:antlr:2.7.6
[Thread-6]          o dom4j:dom4j:1.6.1
[Thread-6]          o xml-apis:xml-apis:1.0.b2
[Thread-6]          o org.slf4j:slf4j-api:1.6.0
[Thread-6]          o org.hibernate:hibernate-entitymanager:3.5.0-Final
[Thread-6]          o org.hibernate:hibernate-annotations:3.5.0-Final
[Thread-6]          o org.hibernate:hibernate-commons-annotations:3.2.0.Final
[Thread-6]          o org.hibernate.javax.persistence:hibernate-jpa-2.0-api:1.0.0.Final
[Thread-6]          o javassist:javassist:3.9.0.GA
[Thread-6]          o org.hibernate:hibernate-validator:4.0.2.GA
[Thread-6]          o org.hsqldb:hsqldb:1.8.0.10
[Thread-6]          o org.slf4j:jcl-over-slf4j:1.6.0
[Thread-6]          o org.slf4j:slf4j-log4j12:1.6.0
[Thread-6]          o org.springframework:spring-aop:3.0.2.RELEASE
[Thread-6]          o aopalliance:aopalliance:1.0
[Thread-6]          o org.springframework:spring-asm:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-beans:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-core:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-aspects:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-context:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-expression:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-context-support:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-test:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-jdbc:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-tx:3.0.2.RELEASE
[Thread-6]          o org.springframework:spring-orm:3.0.2.RELEASE
[Thread-6]          o org.springframework.roo:org.springframework.roo.annotations:1.1.0.M1
[Thread-6] zzaOrder roo&gt; 
[Thread-6] [INFO] ------------------------------------------------------------------------
[Thread-6] [INFO] BUILD SUCCESSFUL
[Thread-6] [INFO] ------------------------------------------------------------------------
[Thread-6] [INFO] Total time: 4 seconds
[Thread-6] [INFO] Finished at: Wed Jun 16 21:21:49 CEST 2010
[Thread-6] [INFO] Final Memory: 36M/330M
[Thread-6] [INFO] ------------------------------------------------------------------------</computeroutput>
~.domain.PizzaOrder roo&gt;</programlisting>

      <para>Ahora se ha de importar al entorno de trabajo mediante
      <command>File -&gt; Import -&gt; Existing Projects into
      workSpace</command>.</para>
    </section>

    <section>
      <title xml:lang="es">Crear la aplicación Web</title>

      <para xml:lang="es">Se han de crear los controllers y las vistas para
      poder visualizar la aplicación web mediante el comando de Roo
      <command>controller</command>:</para>

      <programlisting>~.domain.PizzaOrder roo&gt; <command>controller all --package ~.web</command>
<computeroutput>Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/web
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/web/ToppingController.java
Created SRC_MAIN_WEBAPP/WEB-INF/spring
Created SRC_MAIN_WEBAPP/WEB-INF/spring/webmvc-config.xml
Created SRC_MAIN_JAVA/com/springsource/roo/pizzashop/web/ToppingController_Roo_Controller.aj
Managed ROOT/pom.xml [Added dependency org.apache.tiles:tiles-core:2.2.1]
Managed ROOT/pom.xml [Added dependency org.apache.tiles:tiles-jsp:2.2.1]
Managed SRC_MAIN_WEBAPP/WEB-INF/spring/webmvc-config.xml
Created SRC_MAIN_WEBAPP/images
Created SRC_MAIN_WEBAPP/images/de.png
...
...
Managed SRC_MAIN_WEBAPP/WEB-INF/views/menu.jspx
Managed SRC_MAIN_WEBAPP/WEB-INF/views/bases/views.xml
Created SRC_MAIN_WEBAPP/WEB-INF/views/bases/update.jspx
Managed SRC_MAIN_WEBAPP/WEB-INF/views/bases/views.xml
Managed SRC_MAIN_WEBAPP/WEB-INF/i18n/application.properties
Managed SRC_MAIN_WEBAPP/WEB-INF/views/menu.jspx
~.web roo&gt; </computeroutput></programlisting>

      <para xml:lang="es">Este comando ha creado la estructura de
      visualización y los controllers asociados a partir de la definición de
      las entidades.</para>
    </section>

    <section xml:id="guia-desarrollo_aplicacion-base_arrancar-aplicacion">
      <title xml:lang="es">Arrancar la aplicación web</title>

      <para xml:lang="es">hora solamente queda poner en marcha la aplicación
      web para esto debemos salir de la consola de Roo mediante el comando
      <command>quit</command>. Al situarnos de nuevo en el shell, en la
      carpeta raíz del proyecto se ha de ejecutar la orden <command>mvn
      tomcat:run</command>.</para>

      <para>Para poder ver en funcionamiento la aplicación debemos acceder a
      la dirección: <uri>http://localhost:8080/pizzashop</uri></para>
    </section>
  </section>

  <section xml:id="guia-desarrollo_manejo-entidades">
    <title xml:lang="es">Manejo de Entidades</title>

    <para xml:lang="es">En Spring Roo el artefacto que define la unidad de
    dato es la <classname>Entidad</classname> o <classname>Entity</classname>.
    En este artefacto se definirán los atributos que la componen y los
    servicios (o reglas de negocio) que ofrece para manejarla al resto de las
    entidades o de la aplicación. Por ello es una pieza clave de la
    aplicación.</para>

    <section xml:id="guia-desarrollo_manejo-entidades_definicion">
      <title xml:lang="es">Definición de una entidad</title>

      <para xml:lang="es">Una entidad se define en una clase
      <filename>.java</filename> con una serie de anotaciones de Roo y de JPA.
      Estas anotaciones automatizan comportamiento (sobre todo las de Roo
      añadiendo accesores/mutadores automáticos por ejemplo) y su persistencia
      (las de JPA como las nombre de tabla).</para>

      <para xml:lang="es">Además de las anotaciones de clase, se definen
      propiedades (variables de instancia) que almacenarán la información de
      la entidad. Estas propiedades también pueden llevar anotaciones de JPA
      (para modificar el nombre o tamaño de campo, definir una relación con
      una entidad, etc) y/o otras como las de validación (<link
      xlink:href="http://jcp.org/en/jsr/detail?id=303">JSR 303</link>).</para>

      <para xml:lang="es">Luego, se completa con todos aquellos métodos
      específico de las reglas de negocio de la entidad.</para>

      <para xml:lang="es">En principio, gvNIX nos añadirá todos los métodos
      estándar necesarios para completar la definición de entidad, como los de
      persistencia (almacenamiento y recuperación). Esto se completa usando la
      librería AspectJ y sus ITD. Un ITD es un conjunto de definiciones de una
      clase java que se extraen del propio fichero de forma de que en el .java
      sólo vemos lo fundamental. Luengo, en tiempo de compilación estos
      elementos se incrustarán en la clase final de forma transparente.
      Podemos ver esto elemento en unos ficheros llamados
      <filename>*_Roo_*.aj</filename> que se generan junto al fichero
      <filename>.java</filename> al que hacen referencia.</para>

      <para xml:lang="es">Si por algún motivo necesitamos <emphasis
      role="bold">personalizar el comportamiento</emphasis> de alguno de los
      <emphasis role="bold">métodos estándar que genera Roo</emphasis>,
      simplemente tenemos que <emphasis role="bold">definirlos en el en la
      clase java</emphasis> y, cuando el framework detecte el cambio, en el
      fichero <filename>*_Roo_*.aj</filename> afectado dejara de aparecer esta
      definición.</para>

      <para xml:lang="es">Las características de una
      <classname>Entity</classname> son:</para>

      <itemizedlist>
        <listitem>
          <para xml:lang="es">Tiene un identificador único.</para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene (opcionalmente) un campo de gestión de concurrencia de
          forma optimista.<footnote>
              <para>Ver el <link
              linkend="addon-persistence_occchecksum">OCCCheckSum</link> en el
              <link linkend="addon-persistence">Add-on
              Persistence</link></para>
            </footnote></para>
        </listitem>

        <listitem xml:lang="es">
          <para>Tiene implementados los métodos para almacenarse y recuperarse
          de la fuente de datos.</para>
        </listitem>

        <listitem>
          <para>Genera de forma automática los <emphasis>Accesores</emphasis>
          y <emphasis>Mutadores</emphasis> (<emphasis>getters</emphasis> y
          <emphasis>setters</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <para xml:lang="es">Para generar una entidad podemos optar por dos
      mecanismos:</para>

      <orderedlist>
        <listitem>
          <para xml:lang="es">Usando los comandos de consola
          (<emphasis>recomendado</emphasis>).</para>
        </listitem>

        <listitem>
          <para xml:lang="es">Creando una clase a mano.</para>
        </listitem>
      </orderedlist>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando">
        <title xml:lang="es">Crear una Entidad usando comandos</title>

        <para xml:lang="es">Desde la consola de *Roo* podemos crear de forma
        sencilla. Para ello usaremos dos comandos:</para>

        <itemizedlist>
          <listitem>
            <para xml:lang="es">El comando <command>entity</command>.</para>
          </listitem>

          <listitem>
            <para xml:lang="es">El comando <command>field</command>.</para>
          </listitem>
        </itemizedlist>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_entity">
          <title xml:lang="es">El comando <command>entity</command></title>

          <para xml:lang="es">Este comando crea una nueva entidad en nuestro
          proyecto. Requiere como mínimo definir el parámetro
          <parameter>--class</parameter> para especificar el nombre y el
          paquete de na nueva entidad. En este parámetro podemos utilizar el
          carácter <literal>~</literal> como abreviatura de el paquete base
          del proyecto.</para>

          <para xml:lang="es">Entre los parámetros disponibles podemos
          destacar:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">--class</term>

              <listitem>
                <para xml:lang="es">Nombre de la clase java para la entidad
                entidad (incluido su paquete) (recordar que se puede usar el
                <literal>~</literal> para especificar el paquete base de la
                aplicación).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierType</term>

              <listitem>
                <para xml:lang="es">Permite definir el tipo (clase java) de
                identificador (clave primaria) que usará esta entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre del <emphasis>campo en la
                entidad</emphasis> (no en BBDD) que se usará para el
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>columna de la
                BBDD</emphasis> donde almacenar el valor de clave
                primaria.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">--table</term>

              <listitem>
                <para xml:lang="es">Nombre de la <emphasis>tabla de la
                BBDD</emphasis> donde almacenar los datos para esta
                entidad.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">El resto de las opciones podemos verlas usando
          el autocompletado de la consola de roo o usando el comando
          <command>help entity</command>.</para>

          <para xml:lang="es">Existen más opciones para configurar la entidad,
          aunque no todos se pueden especificar usando este comando. Ver el
          apartado <link
          linkend="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">Anotación
          RooEntity</link>.</para>
        </section>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field">
          <title xml:lang="es">El comando <command>field</command></title>

          <para xml:lang="es">No existe un comando <command>field</command>
          propiamente dicho, pero es el nombre de un grupo de comando para
          añadir campos a una entidad. Los comandos finales se forma con el
          <command>field {tipo}</command> donde <parameter>{tipo}</parameter>
          es el tipo de dato que va almacenar. Así tenemos los
          siguientes:</para>

          <variablelist>
            <varlistentry>
              <term xml:lang="es">field string</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo cadena.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field boolean</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo booleano.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field date</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo fecha.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field email template</term>

              <listitem xml:lang="es">
                <para>Crea un campo con una plantilla preparada para almacenar
                direcciones de correo electrónico.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field enum</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo enumerado.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field number</term>

              <listitem xml:lang="es">
                <para>Crea un campo de tipo numerico (es posible especificarle
                el tipo mediante el parámetro
                <parameter>--type</parameter>).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field reference</term>

              <listitem xml:lang="es">
                <para>Crea un campo que será una referencia a otra
                entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field set</term>

              <listitem xml:lang="es">
                <para>Crea un campo que devolverá una lista de elementos de
                una entidad relacionados con este elemento.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term xml:lang="es">field other</term>

              <listitem xml:lang="es">
                <para>Crea un campo de otro tipo no registrado.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Cada uno de estos comandos admiten algunos parámetros que son
          comunes entre ellos o muy específicos. Entre los comunes (para la
          mayoría) podemos encontrar los siguientes:</para>

          <variablelist>
            <varlistentry>
              <term>--fieldName</term>

              <listitem>
                <para xml:lang="es">Nombre del campo que vamos a
                generar.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--class</term>

              <listitem>
                <para xml:lang="es">Clase entidad donde vamos a crear el
                campo. Admite el uso de <literal>~</literal> y tiene
                autocompletado. No es necesario especificar si acabamos de
                crear una entidad.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--notNull y --nullRequired</term>

              <listitem>
                <para xml:lang="es">Especifica el comportamiento de campo
                antes los valores nulos.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--column</term>

              <listitem>
                <para xml:lang="es">Nombre de la columna en BBDD donde se
                almacenará el valor.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>--sizeMax y --sizeMin</term>

              <listitem>
                <para xml:lang="es">Limitaciones de tamaño.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Existe mas opciones dependiendo del tipo de
          dato, para mas información ver la ayuda de la consola.</para>

          <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field_ejemplos">
            <title xml:lang="es">Ejemplos</title>

            <para xml:lang="es">Estos son algunos ejemplos de ceración de
            campos:</para>

            <orderedlist>
              <listitem>
                <para xml:lang="es">Campo cadena con validaciones:</para>

                <programlisting>roo&gt; <command>field string --fieldName nombre --notNull --sizeMax 50 --sizeMin 1 --comment "Nombre del pais" --column pais_nombre --regexp [A-Z].*</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @NotNull
    @Column(name = "pais_nombre")
    @Size(min = 1, max = 50)
    @Pattern(regexp = "[A-Z].*")
    private String nombre;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con referencia a otra entidad
                (muchos a uno):</para>

                <programlisting>roo&gt; <command>field reference --fieldName pais --type ~.domain.Pais --notNull</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToOne(targetEntity = Pais.class)
    @JoinColumn
    private Pais pais;</programlisting>
              </listitem>

              <listitem>
                <para xml:lang="es">Campo con elementos de otra entidad (uno a
                muchos):</para>

                <programlisting>roo&gt; <command>field set --class ~.domain.Pais --element ~.domain.Provincia --fieldName provincias --mappedBy pais</command></programlisting>

                <para xml:lang="es">Genera dentro de la clase destino:</para>

                <programlisting>    @ManyToMany(cascade = CascadeType.ALL, mappedBy = "pais")
    private Set&lt;Provincia&gt; provincias = new HashSet&lt;Provincia&gt;();</programlisting>
              </listitem>
            </orderedlist>
          </section>
        </section>
      </section>

      <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano">
        <title xml:lang="es">Crear una Entidad a mano</title>

        <para xml:lang="es">Para que se identifique una clase *java* como
        entidad, debe de estar anotada como <classname>@RooEntity</classname>
        y como <classname>@Entity</classname> de JPA. El framework, cuando
        crea la entidad con el comando <command>entity</command> genera una
        clase como esta:</para>

        <programlisting>    @Entity
    @RooJavaBean
    @RooToString
    @RooEntity
    public class Entity1 {
        
            @Size(max = 20)
            @NotNull
            private String name;
                
            @Size(max = 20)
            private String appellidos;
    }</programlisting>

        <para xml:lang="es">Nosotros podemos crear manualmente una clase
        <emphasis>java</emphasis> con estas anotaciones y manejarla desde
        gvNIX sin problemas.</para>

        <para xml:lang="es">Entre las anteriores anotaciones podemos
        ver:</para>

        <variablelist>
          <varlistentry>
            <term>@Entity</term>

            <listitem>
              <para xml:lang="es">Anotación JPA que identifica esta clase como
              persistente.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooJavaBean</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe generar
              los getter/setter que falten para acceder modificar los valores
              de nuestros campos. Si alguno estuviese generado, el framework
              no lo generará.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooToString</term>

            <listitem>
              <para xml:lang="es">Anotación que informa a Roo que debe genera
              un método automático <methodname>toString()</methodname> para
              esta clase. Este método se genera a partir de las propiedades de
              la clase.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@RooEntity</term>

            <listitem>
              <para xml:lang="es">Anotación que informa Roo que esta clase es
              una entidad. Esta anotación genera todos lo métodos necesarios
              de persistencia y manejo básicos necesario para manejar la
              entidad.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <important>
          <para>gvNIX solo reconoce las <emphasis role="bold">anotaciones de
          las propiedades</emphasis> que estén <emphasis role="bold">en la
          declaración de la propiedad</emphasis> de la clase, <emphasis
          role="bold">no en los métodos accesores</emphasis></para>
        </important>

        <important>
          <para>gvNIX solo distinguirá las como <emphasis role="bold">entidad
          las clases correctamente anotadas</emphasis> y que estén <emphasis
          role="bold">dentro del paquete base de la aplicación (o
          subpaquetes)</emphasis>.</para>
        </important>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">
          <title xml:lang="es">La anotación
          <classname>@RooEntity</classname></title>

          <para xml:lang="es">Como ya hemos mencionado, informa a gvNIX que
          esta clase debe ser tratada como una entidad. Esto provoca que Roo
          genere un fichero <filename>{Entidad}_Roo_Entity.aj</filename> en el
          que añadirá todo aquellos métodos y atributos que sean
          necesarios.</para>

          <para xml:lang="es">Esta anotación admite parámetros de
          configuración. Entre ellos podemos ver:</para>

          <variablelist>
            <varlistentry>
              <term>identifierType</term>

              <listitem>
                <para xml:lang="es">Clase java para el campo usado como
                identificador.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierField</term>

              <listitem>
                <para xml:lang="es">Nombre de campo a usar como identificador
                (de la clase).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>identifierColumn</term>

              <listitem>
                <para xml:lang="es">Nombre de columna en la BBDD para
                almacenar el valor del identificador (clave primaria).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionField</term>

              <listitem>
                <para xml:lang="es">Nombre del campo para la gestión de
                concurrencia. Si se establece a <literal>""</literal> (cadena
                vacía) no se usará gestión de concurrencia.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>versionType</term>

              <listitem>
                <para xml:lang="es">Tipo a usar para el campo de gestión de
                concurrencia. (normalmente un numérico o TimeStamp)</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para xml:lang="es">Es posible usar un identificador personalizado.
          Para ello hay que declarar el campo en la clase Java y anotarlo con
          <classname>@Id</classname>. Luego hay que proporcionar sus
          <methodname>getter</methodname> y
          <methodname>setter</methodname>.</para>
        </section>

        <section xml:id="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-roojavabean">
          <title xml:lang="es">La anotación
          <classname>@RooJavaBean</classname></title>

          <para xml:lang="es">Genera los getter y setter para todos aquellos
          campos que no estén ya generados. Utiliza el fichero
          <filename>{Entidad}_Roo_JavaBean.aj</filename>. También es admitida
          en otras clases que no sean entidades, por lo que es muy útil para
          toda la aplicación.<important>
              <para>La <emphasis role="bold">restrición del paquete
              base</emphasis> que se menciona en la <link
              linkend="guia-desarrollo_manejo-entidades_definicion_crear-a-mano_anotacion-rooentity">anotación
              @RooEntity</link> se <emphasis role="bold">aplica a todas las
              anotaciones</emphasis> de gvNIX.</para>
            </important></para>
        </section>
      </section>

      <section>
        <title>Modificar el modelo</title>

        <para>Como podreís comprobar, no existe comando para <emphasis
        role="bold">eliminar una entidad</emphasis> del modelo. Para ello lo
        único que teneís que hacer es <emphasis role="bold">eliminar el
        fichero</emphasis> <filename>.java</filename> de la entidad y gvNIX,
        automáticamente, detectará el cambio y limpiara el sus elementos
        relacionados (ficheros {entidad}_Roo_*.aj, controladores asociados,
        elementos de menú).</para>

        <para>Para <emphasis role="bold">eliminar un campo</emphasis> solo hay
        que <emphasis role="bold">eliminarlo de la clase</emphasis>
        <filename>.java</filename> y todos los componentes relacionados serán
        actualizados automáticamente.</para>

        <para>Para <emphasis role="bold">añadir un campo</emphasis> una
        entidad existente se puede hacer <emphasis
        role="bold">manualmente</emphasis> (con las anotaciones adecuadas)
        <emphasis role="bold">o usando el comando</emphasis> <command><link
        linkend="guia-desarrollo_manejo-entidades_definicion_crear-con-comando_field">field</link></command>.</para>

        <para>En cualquier caso gvNIX <emphasis role="bold">monitoriza los
        cambios en el proyecto</emphasis> y <emphasis role="bold">actualiza
        los componentes</emphasis> relacionados cuando es necesario.</para>
      </section>
    </section>
  </section>
</chapter>
