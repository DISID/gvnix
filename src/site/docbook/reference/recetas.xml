<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="recetas" xml:lang="es"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Recetas</title>

  <para>En este capítulo veremos como hacer algunas modificaciones sobre el
  código que genera gvNIX para adaptarlo a nuestras necesidades.</para>

  <section xml:id="recetas-repositorio_maven">
    <title>Repositorios Maven</title>

    <para>En la mayoria de casos, cuando una funcionalidad ofrecida por gvNIX
    requiere de librerías externas, el Add-on en cuestión registra un nuevo
    repositorio de arterfactos Maven en el pom.xml que gestiona el proyecto.
    Sin embargo podemos vernos con la necesidad de tener que añadir alguno
    manualmente.</para>

    <section>
      <title>Editando pom.xml manualmente</title>

      <para>Para hacerlo tenemos que editar el fichero pom.xml y en la sección
      &lt;repositories/&gt; añadir la definición de repositorio que
      necesitemos. Por ejemplo, veamos como definir el repositorio Maven
      interno de la Conselleria de Infraestructuras, Transportes y Medio
      Ambiente <emphasis role="bold">(este repositorio es accesible únicamente
      desde las oficinas de la Conselleria)</emphasis>.</para>

      <programlisting>&lt;repositories&gt;
    ...
    &lt;repository&gt;
        &lt;id&gt;citma-maven&lt;/id&gt;
        &lt;name&gt;CITMA Maven Repository&lt;/name&gt;
        &lt;url&gt;http://benigno.coput.gva.es:8081/nexus/content/groups/public&lt;/url&gt;
    &lt;/repository&gt;
    ...
&lt;/repositories&gt;</programlisting>
    </section>

    <section>
      <title>Mediante plugin M2Eclipse en Eclipse IDE</title>

      <para><emphasis>TBD</emphasis></para>
    </section>
  </section>

  <section xml:id="recetas-finders">
    <title>Desarrollo de buscadores</title>

    <para>gvNIX/Roo ofrece la funcionalidad de generar buscadores por
    entidades del modelo de la aplicación mediante el comando <emphasis>finder
    add</emphasis>. El comando espera que especifiquemos el buscador a generar
    en un formato determinado. Para conocer el formato nos podemos ayudar del
    comando <emphasis>finder list</emphasis>. Veamos como generar un buscador
    sobre una de las entidades del proyecto de ejemplo PetClinic que viene con
    la distribución de gvNIX. Usaremos la entidad Owner.</para>

    <para>Ejecutamos el comando finder list sobre Owner</para>

    <programlisting>roo-gvNIX&gt; finder list --class ~.domain.Owner --depth 2 --filter LastName
...
findOwnersByLastNameLikeAndCityLike(String lastName, String city)
...</programlisting>

    <para>En el comando indicamos sobre que entidad queremos generar el
    buscador (<emphasis>--class</emphasis>). El resto de parámetros son
    opcionales, <emphasis>--depth</emphasis> indica que nivel de "profundidad"
    queremos que tenga en cuenta (debido a una limitación auque indiquemos una
    profundidad mayor que 3 siempre nos mostrará como máximo 3 niveles) y
    <emphasis>--filter</emphasis> indica un filtro para hacer que solo se
    muestren opciones de buscador que contengan la cadena indicada en su
    definición.</para>

    <para>Nos devuelve varias posibilidades, de ellas para este ejemplo
    escogemos findOwnersByLastNameLikeAndCityLike que genera un buscador de
    Owners cuyo <emphasis>lastName</emphasis> contenga la cadena que se le
    pase como parámetro y cuya <emphasis>city</emphasis> también contenga la
    cadena dada usando el operador <emphasis>LIKE</emphasis>.</para>

    <para>Si ejecutamos el comando finder add nos generará el buscador a nivel
    de la entidad y si tenemos definida la capa Web creará el controller y la
    JSPX necesaria para el formulario que invocará el buscador que hemos
    definido.</para>

    <programlisting>~.domain.Owner roo-gvNIX&gt; finder add --class ~.domain.Owner --finderName <emphasis
        role="bold">findOwnersByLastNameLikeAndCityLike</emphasis>
2840bdf Updated SRC_MAIN_JAVA/com/springsource/petclinic/domain/Owner.java
eb708be Updated SRC_MAIN_WEBAPP/WEB-INF/views/menu.jspx
9f5b38e Updated SRC_MAIN_WEBAPP/WEB-INF/views/owners/views.xml
105ec93 Updated SRC_MAIN_WEBAPP/WEB-INF/i18n/application.properties
7047c54 <emphasis role="bold">Created SRC_MAIN_JAVA/com/springsource/petclinic/web/OwnerController_Roo_Controller_Finder.aj</emphasis>
9b1f4dc <emphasis role="bold">Created SRC_MAIN_JAVA/com/springsource/petclinic/domain/Owner_Roo_Finder.aj</emphasis>
38002fb <emphasis role="bold">Created SRC_MAIN_WEBAPP/WEB-INF/views/owners/findOwnersByLastNameLikeAndCityLike.jspx</emphasis></programlisting>

    <para><emphasis role="bold">El Add-on Finder tiene una limitación que
    impone el SO Windows en el tamaño máximo del nombre de
    archivos</emphasis>. Como vemos en el ejemplo anterior se genera el
    archivo <emphasis>findOwnersByLastNameLikeAndCityLike.jspx</emphasis>. La
    limitación del tamaño máximo de nombre de archivo limita el comando finder
    add a nombres de buscadores que generen paths a archivo jspx de tamaño
    menor de 244 caracteres.</para>

    <para>Hay un truco para poder generar estos buscadores. Consiste en
    dividir el buscador que queremos en varios más pequeños, parciales de unos
    pocos campos cada uno, y al final unir el código que se genera para cada
    uno de ellos en un unico método. Esto implica tener que modificar el
    código que se ha generado para el buscador en la Entidad, el Controller y
    la jspx de la siguiente forma:</para>

    <itemizedlist>
      <listitem>
        <para>En el .java de la Entidad para la que estamos generando el
        buscador crear un método al que podemos llamar
        <emphasis>findByTodo</emphasis> y cuyos parámetros de entrada serán
        todos los parámetros que reciben los métodos de los buscadores
        parciales que hemos generado. Del mismo modo, el cuerpo de este nuevo
        método es la unión de la implementación de todos los buscadores
        parciales. Podemos aprovechar y modificar el código, según se explica
        en el siguiente apartado, de forma que los parámetros sean
        opcionales.</para>
      </listitem>

      <listitem>
        <para>De manera similar en el .java del Controller de la entidad
        crearemos dos métodos: uno <emphasis>findByTodoForm</emphasis> que nos
        devolverá a la vista del formulario de este buscador, y otro
        <emphasis>findByTodo</emphasis> que servirá las peticiones que lleguen
        desde el formulario del buscador. En este último caso, al igual que en
        caso del método que hemos creado en la Entidad, tendrá como parámetros
        la unión de todos los de los buscadores parciales. El cuerpo de este
        método deberá invocar al <emphasis>findByTodo</emphasis> que hemos
        creado en la Entidad. Para la anotación @RequestMapping de estos dos
        métodos nos podemos guiar como se define en los buscadores
        existentes.</para>
      </listitem>

      <listitem>
        <para>Finalmente debemos crear una jspx (la podemos llamar
        findByTodo.jspx) en el directorio WEB-INF/views/&lt;entidad&gt; que
        contendrá el formulario de nuestro buscador. Por tanto incluye todos
        los campos que hayan en el resto de buscadores parciales. Hay que
        recordar, que esta vista se ha de definir también el fichero views.xml
        que hay en la carpeta de vistas de la entidad y que esta vista es la
        que devuelve el método findByTodoForm que hemos creado antes en el
        Controller.</para>
      </listitem>
    </itemizedlist>

    <para>Hemos descrito un trabajo manual, y en parte tedioso, que puede
    ayudarnos a la hora de montar buscadores por tantos campos como
    queramos.</para>

    <section>
      <title>Modificar buscadores generados</title>

      <para>El comportamiento que se implementa automáticamente al generar un
      buscador es esperar que todos los campos de busqueda son obligatorios,
      es decir, en el ejemplo anterior, el buscador siempre intentará ejecutar
      la consulta "<emphasis>SELECT * FROM Owners WHERE lastName LIKE '%xxx%'
      AND city LIKE '%yyyy%'</emphasis>", pero si no indicaramos alguno de los
      parámetros devolverá una excepción indicando que falta un parámetro
      requerido. En ocasiones no queremos que esto suceda así, es decir,
      podríamos querer que los filtros del WHERE cuyos parámetros no se han
      informado no se incluyeran en la consulta. Para hacerlo debemos
      modificar el código del método <emphasis>finderByXxxx</emphasis> que se
      encuentra declarado en <emphasis>*_Roo_Finder.aj</emphasis>. Veamos como
      hacerlo.</para>

      <para>Hacemos <emphasis>Push In</emphasis> del método tal y como
      comentamos en la sección sobre <link
      linkend="guia-desarrollo_generacion-codigo">modificación del código
      generado</link> y lo llevamos al .java de la entidad. Una vez allí lo
      modificamos para que no requiera los campos y que construya la consulta
      dependiendo de que parámetros se han informado:</para>

      <programlisting>public static TypedQuery&lt;Owner&gt; findOwnersByLastNameLikeAndCityLike(String lastName, String city) {
    StringBuilder query = new StringBuilder("SELECT o FROM Owner AS o");
    StringBuilder whereClause = new StringBuilder();

    if (lastName != null &amp;&amp; lastName.length() &gt; 0) {
      lastName = lastName.replace('*', '%');
      if (lastName.charAt(0) != '%') {
          lastName = "%" + lastName;
      }
      if (lastName.charAt(lastName.length() - 1) != '%') {
          lastName = lastName + "%";
      }
      whereClause.append(" WHERE LOWER(o.lastName) LIKE LOWER(:lastName)");
    }

    if (city != null &amp;&amp; city.length() &gt; 0) {
      city = city.replace('*', '%');
      if (city.charAt(0) != '%') {
          city = "%" + city;
      }
      if (city.charAt(city.length() - 1) != '%') {
          city = city + "%";
      }
      if (whereClause.length() &gt; 0) {
        whereClause.append(" AND LOWER(o.city) LIKE LOWER(:city)");
      } else {
        whereClause.append(" WHERE LOWER(o.city) LIKE LOWER(:city)");
      }
    }
    query.append(whereClause);

    EntityManager em = Owner.entityManager();
    TypedQuery&lt;Owner&gt; q = em.createQuery(query.toString(), Owner.class);
    if (lastName != null &amp;&amp; lastName.length() &gt; 0) {
      q.setParameter("lastName", lastName);
    }
    if (city != null &amp;&amp; city.length() &gt; 0) {
      q.setParameter("city", city);
    }
    return q;
}</programlisting>

      <para>En este ejemplo se ha construido la consulta usando un
      StringBuilder en el que generamos la consulta deseada, pero se podría
      haber usado cualquier otro como por ejemplo usar Hibernate Criteria
      Builder.</para>

      <para>Las condiciones</para>

      <programlisting>if (city != null &amp;&amp; city.length() &gt; 0)</programlisting>

      <para>podrían simplificarse a</para>

      <programlisting>if (city != null)</programlisting>

      <para>si usáramos la funcionalidad que ofrece el <link
      linkend="addon-web-mvc-binding">Add-on Web MVC Binding</link>, que
      establece el StringTrimmerEditor y que en caso de llegar un parámetro
      con una cadena vacía la convierte a null.</para>

      <para>Como ya hemos dicho, el código generado indica que todos los
      parámetros de búsqueda son obligatorios, esto implica también al
      formulario en la jspx. Tal como se genera, si alguno de los campos no se
      rellena, no nos deja enviar la petición. Debemos editar la jspx y
      modificar el atributo <emphasis>required</emphasis> de los campos
      <emphasis>field</emphasis> y establecer su valor a
      <emphasis>false</emphasis>, no debemos olvidarnos de cambiar el valor
      del atributo <emphasis>z</emphasis> a
      "<emphasis>user-managed</emphasis>" para indicar que lo hemos
      modificado.</para>

      <programlisting>&lt;field:input disableFormBinding="true" field="city" id="f_com_springsource_petclinic_domain_Owner_city" max="30" <emphasis
          role="bold">required="false" z="user-managed"</emphasis>/&gt;</programlisting>

      <para>Bueno ya tenemos modificado el buscador para que los parámetros no
      sean obligatorios.</para>

      <para>En algunos buscadores necesitaremos que uno de los parámetros sea
      una entidad del modelo, una entidad relacionada con la entidad sobre la
      que estamos buscando. En estos casos es útil el uso de un selector
      desplegable en el que indicaremos cual es el registro de la relación que
      indicará el filtro sobre la entidad que estamos buscando. Pero, el
      componente <emphasis>select.tagx</emphasis> que se usa en los
      formularios tiene el inconveniente de que no añade una opción vacía
      entre las disponibles, con lo que nos vemos obligados a elegir siempre
      una. Un ejemplo de este caso lo tenemos en el buscador por Owner que se
      genera para la entidad Pet en el ejemplo de PetClinic.</para>

      <para>La forma de tratar estas peticiones de Spring MVC es intentar
      cargar el registro de la entidad que llega como parámetro. Por tanto si
      le llega como parámetro un dato que no concuerda con ningún registro de
      la entidad parámetro, usará null como parámetro. Pero como hemos dicho
      el componente <emphasis>select.tagx</emphasis> no ofrece una opción
      vacía. gvNIX en su <link linkend="addon-web-screen-patterns">Add-on Web
      MVC Pattern</link> tiene un componente
      <emphasis>select-withempty.tagx</emphasis> que si lo ofrece. Mediante el
      comando <emphasis>web mvc pattern install</emphasis> instalamos los
      componentes de MVC Pattern entre los que se incluye el selector con
      opción vacía. Podemos modificar la jspx del buscador de Pet por Owner
      para que use <emphasis>select-withempty</emphasis> en lugar del original
      de la siguiente forma:</para>

      <programlisting>&lt;div xmlns:field="urn:jsptagdir:/WEB-INF/tags/form/fields" ... <emphasis
          role="bold">xmlns:pattern-field="urn:jsptagdir:/WEB-INF/tags/pattern/form/fields"</emphasis> version="2.0"&gt;
    &lt;jsp:directive.page contentType="text/html;charset=UTF-8"/&gt;
    &lt;jsp:output omit-xml-declaration="yes"/&gt;
    &lt;form:find finderName="ByOwner" id="ff_com_springsource_petclinic_domain_Pet" path="/pets" z="ThIGSmua6R7WM6q2P1BpNC3zMi4="&gt;
        <emphasis role="bold">&lt;pattern-field:select-withempty disableFormBinding="true" field="owner" emptyValueEnable="true" emptyValue="0" id="f_com_springsource_petclinic_domain_Pet_owner" itemValue="id" items="${owners}" path="/owners" required="false" z="user-managed"/&gt;</emphasis>
    &lt;/form:find&gt;
&lt;/div&gt;</programlisting>

      <para>El componente select-withempty tiene los mismos atributos que el
      select.tagx y otro tres más:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>emptyValueEnable</emphasis> true|false habilita la
          opción vacía en el selector.</para>
        </listitem>

        <listitem>
          <para><emphasis>emtpyValue</emphasis> indica que valor se quiere dar
          a la opción vacía del selector. Si se corresponde con una entidad,
          este valor no debería corresponder a ningún identificador existente
          para esa entidad, de esta forma el valor que llega al buscador es
          null.</para>
        </listitem>

        <listitem>
          <para><emphasis>emptyLabel</emphasis> cadena a mostrar para la
          opción vacía del selector.</para>
        </listitem>
      </itemizedlist>

      <para>Con este cambio y si tenemos modificado el método finder de Pet
      para que no sea necesario que llegue el parámetro Owner, de manera
      similar a lcomo lo hemos explicado antes, nos aseguramos de que podemos
      hacer búsquedas por parámetros opcionales.</para>
    </section>
  </section>

  <section xml:id="recetas-reports">
    <title>Diseño de Informes que contienen sub-informes</title>

    <para>gvNIX ofrece un add-on (<link linkend="addon-web-report">Add-on Web
    Report</link>) que facilita la definición de informes sobre una entidad.
    El add-on genera el diseño básico de un informe JasperReports el cual
    podemos modificar usando un diseñador como iReport.</para>

    <para>Podemos necesitar que el informe definido muestre los elementos de
    una entidad relacionada con la entidad sobre la que se ha declarado el
    informe. Por ejemplo, en la aplicación PetClinic, podríamos definir un
    informe sobre la entidad Owner y queremos que, para cada Owner, se muestre
    en el reporte, se muestre también la lista de mascotas que le pertenecen,
    es decir, listar la relación definida por el campo
    <emphasis>pets</emphasis> de la entidad Owner.</para>

    <note>
      <para>Para esta receta usaremos la versión 4.0.1 de iReport.</para>
    </note>

    <para>Partamos del informe definido por el comando gvNIX:</para>

    <programlisting>roo-gvNIX&gt; web report add --controller ~.web.OwnerController --reportName ownerpets</programlisting>

    <para>En src/main/webapp/WEB-INF/reports se ha creado el archivo de diseño
    de informe <emphasis>owner_ownerpets.jrxml</emphasis>. Abrimos este
    archivo usando iReport (<emphasis>Archivo &gt; Open</emphasis>).</para>

    <figure>
      <title>iReport - Diseñador</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-1.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>En la parte izquierda, en la ventana de Report Inspector podemos ver
    los elementos principales de diseño del informe JasperReports. </para>

    <figure>
      <title>iReport - Report Inspector</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-2.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Lo primero que tenemos que hacer es declarar un nuevo Parámetro con
    el nombre <emphasis>SubReportPetsLocation</emphasis>. Para ello hacemos
    click con el botón derecho sobre el elemento
    <emphasis>Parameters</emphasis> y seleccionamos la opción
    <emphasis>Agregar Parameter</emphasis>. Justo debajo del último parámetro
    aparecerá el que estoms añadiendo (<emphasis>parameter1</emphasis>), si lo
    seleccionamos, en la parte derecha de la ventana de iReport podremos ver
    sus propiedades. En <emphasis role="bold">Name</emphasis> indicamos
    <emphasis>SubReportPetsLocation</emphasis> y <emphasis
    role="bold">Parameter Class</emphasis> establecemos
    <emphasis>net.sf.jasperreports.engine.JasperReport</emphasis>.</para>

    <para>Ahora debemos añadir un elemento Subreport a nuestro diseño, y como
    queremos que aparezca para cada elemento de la lista de Owners, debemos
    hacerlo en la banda de detalle (<emphasis>Detail1</emphasis>) del informe.
    Necesitaremos aumentar la altura de la banda <emphasis>Detail1</emphasis>.
    La seleccionamos y en sus propiedades indicamos <emphasis role="bold">Band
    height</emphasis> <emphasis>55</emphasis>. De la paleta de elementos
    seleccionamos <emphasis role="bold">Subreport</emphasis> y lo arrastramos
    a la banda de detalle. Se nos abrirá un asistente, seleccionamos la opción
    <emphasis>"Just create the subreport element"</emphasis> y cerramos con
    Terminar. Podemos modificar las dimensiones del elemento Subreport
    arrastrando las esquinas de la caja del elemento.</para>

    <figure>
      <title>iReport - Subreport</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-3.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Antes de seguir con el establecimiento de las propiedades del
    Subreport, necesitamos declarar un campo del informe que nos permitirá
    acceder al campo <emphasis>pets</emphasis> de la Entidad
    <emphasis>Owner</emphasis>. En "<emphasis>Report Inspector</emphasis>",
    seleccionamos <emphasis>Fields</emphasis> y con el botón derecho
    <emphasis>Agregar Field</emphasis>. Al igual que con el parámetro
    SubReportPetsLocation indicamos <emphasis role="bold">Name</emphasis>
    <emphasis>pets</emphasis> y <emphasis role="bold">Field Class</emphasis>
    <emphasis>java.util.Collection</emphasis>.</para>

    <para>Debemos indicar cuales son las propiedades del Subreport. En la
    ventana de propiedades de la derecha buscamos las siguientes propiedades y
    establecemos los valores correspondientes:</para>

    <orderedlist>
      <listitem>
        <para><emphasis role="bold">Subreport Expression</emphasis> =
        <emphasis>$P{SubReportPetsLocation}</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Expression Class</emphasis> =
        <emphasis>net.sf.jasperreports.engine.JasperReport</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Connection type</emphasis> = <emphasis>Use
        a datasource expression</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Data Source Expression</emphasis> =
        <emphasis>new
        net.sf.jasperreports.engine.data.JRBeanCollectionDataSource($F{pets})</emphasis></para>
      </listitem>
    </orderedlist>

    <para>En el flujo de ejecución de un informe JasperReports, los parámetros
    del mismo han de ser informados antes de la operación
    <emphasis>print</emphasis> o, de lo contrario, cojerán valores por defecto
    que se hayan definido o <emphasis>null</emphasis> en su defecto. Hemos de
    fijarnos que hemos definido el parámetro
    <emphasis>SubReportPetsLocation</emphasis>, el valor que toma este
    parámetro en tiempo de ejecución ha de ser un path absoluto en el sistema
    de archivos o en el classpath de la aplicación. En <link
    linkend="addon-web-report">Add-on Web Report</link> se indicaba que al
    añadir un informe a la aplicación, usando el comando <emphasis>web report
    add</emphasis>, en el archivo
    <emphasis>src/main/webapp/WEB-INF/spring/jasper-views.xml</emphasis> se
    declaraba un bean que indicaba la ruta hasta el fichero jrxml del informe
    añadido. Este bean tiene un atributo que indica donde se declaran la
    localización de los subreports que se usan en los distintos informes
    (atributo p:subReportsUrls-ref).</para>

    <programlisting>&lt;bean id="owner_ownerpets"
      class="com.springsource.petclinic.web.servlet.view.jasperreports.CustomJasperReportsMultiFormatView" 
      p:reportDataKey="ownerpetsList" p:url="/WEB-INF/reports/owner_ownerpets.jrxml"
      p:subReportDataKeys-ref="subReportDataKeys" <emphasis role="bold">p:subReportUrls-ref="subReportUrls"</emphasis> /&gt;</programlisting>

    <para>Es en el &lt;util:map/&gt;, declarado en el mismo jasper-views.xml,
    al que apunta el valor del atributo
    <emphasis>p:subReportsUrls-ref</emphasis> donde estbleceremos el valor que
    ha de tomar el parámetro <emphasis>SubReportPetsLocation.</emphasis>
    Modificamos este elemento añadiendo una entrada, quedando como se muestra
    a continuación:</para>

    <programlisting>&lt;util:map id="<emphasis role="bold">subReportUrls</emphasis>"&gt;
  &lt;!-- This entry key must be declared exactly as you declared it in the master JRXML file --&gt;
  &lt;!-- Add one &lt;entry /&gt; node for each sub-report you need to define --&gt;
  &lt;!-- &lt;entry key="mySubReportLocation" value="/WEB-INF/reports/my-sub-report-file.jasper"/&gt; --&gt;
  <emphasis role="bold">&lt;entry key="SubReportPetsLocation" value="/WEB-INF/reports/owner_ownerpets_sub_pets.jrxml"/&gt;</emphasis>
&lt;/util:map&gt;</programlisting>

    <para>En este elemento &lt;util:map/&gt; podemos añadir tantos
    &lt;entry/&gt; como necesitemos para definir los valores de los parámetros
    que indican donde se localizan los archivos jrxml de los distintos
    subreports que precisemos en nuestra aplicación.</para>

    <para>Ahora nos queda diseñar el informe que mostrará el listado de
    mascotas (pets) y que conformará nuestro subreport.</para>

    <para>Creamos un nuevo diseño de informe (<emphasis>Archivo &gt;
    Nuevo</emphasis>), y en el asistente que se nos muestra seleccionamos
    <emphasis>Blank A4</emphasis> y <emphasis>Open This Template</emphasis>.
    Nos pedirá que demos un nombre al diseño y donde queremos guardarlo.
    Indicamos <emphasis>owner_ownerpets_sub_pets.jrxml</emphasis> y lo
    guardamos en el mismo directorio donde tenemos el report padre
    (<emphasis>owner_ownerpets.jrxml</emphasis>).</para>

    <figure>
      <title>iReport - Nuevo diseño</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-4.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <important>
      <para>Debemos asegurarnos que el nuevo informe se crea para usar Java
      como lenguaje para las expresiones. En <emphasis>Report
      Inspector</emphasis>, si seleccionamos el primer elemento (el nombre del
      informe) y miramos en sus propiedades (parte derecha de la pantalla de
      iReport) debemos buscar la propiedad <emphasis>Language</emphasis>, si
      no tiene el valor Java, debemos cambiarlo usando el desplegable.</para>
    </important>

    <para>Este nuevo informe, que constituirá nuestro subreport, es un informe
    a todos los efectos, por tanto debemos definir aquellos campos (elemento
    Fields del diseño), parámetros (elemento Parameters) y todo aquello que
    necesitemos.</para>

    <para>Al igual que hemos hecho antes con el campo pets del informe padre,
    definamos los campos que nos permitirán acceder a los campos de la entidad
    Pet que mostraremos en el subreport. Click con el botón derecho sobre
    Fields y Agregar Field:</para>

    <orderedlist>
      <listitem>
        <para>Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>name</emphasis> - <emphasis role="bold">Field
        Class</emphasis> <emphasis>java.lang.String</emphasis> </para>
      </listitem>

      <listitem>
        <para>Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>weight</emphasis> - <emphasis role="bold">Field
        Class</emphasis> <emphasis>java.lang.Float</emphasis></para>
      </listitem>

      <listitem>
        <para>Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>type</emphasis> - <emphasis role="bold">Field
        Class</emphasis>
        <emphasis>com.springsource.petclinic.reference.PetType</emphasis>
        (enumerado declarado en nuestro proyecto PetClinic)</para>
      </listitem>
    </orderedlist>

    <para>El diseño del informe se compone de distitnas bandas, donde se
    colocan los elementos que queremos mostrar (<emphasis>Title, Page Header,
    Collumn Header, Detail1, Collumn Footer, ...</emphasis>). Para un
    subreport como el que necesitamos para este ejemplo, algunas bandas son
    innecesarias y podemos eliminarlas. Esto nos permitirá ajustar mejor el
    diseño completo de nuestro informe (informe padre ownerpets + subreport
    pets). Si hacemos click con el botón derecho sobre
    <emphasis>Title</emphasis> y seleccionamos <emphasis>Delete
    Band</emphasis>, la eliminamos. Hagámoslo con todas excepto
    <emphasis>Collumn Header, Detail1 y Summary</emphasis>.</para>

    <figure>
      <title>iReport - Bandas subreport</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-6.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para><emphasis>Collumn Header</emphasis> es una banda que se dibujará
    solo al inicio de la columna del informe (en nuestro caso solo tenemos
    una). Aquí añadiremos textos estáticos que harán las veces de cabecera de
    tabla. Para ello de la paleta de componentes, seleccionamos
    <emphasis>Static Text</emphasis> y lo arrastramos hasta la banda
    <emphasis>Collumn Header</emphasis>.</para>

    <figure>
      <title>iReport - Paleta</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-5.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>En el primer <emphasis>Static Text</emphasis> establecemo el valor
    <emphasis>Nombre</emphasis> y repetimos la misma operación para definir un
    texto para el campo <emphasis>Peso</emphasis> y para el
    <emphasis>Tipo</emphasis>. Podemos distribuir las etiquetas para que quede
    como en la captura anterior.</para>

    <para>A continuación, haremos lo mismo pero usando el elemento
    <emphasis>Text Field</emphasis>. Este elemento sirve para mostrar el valor
    de un campo de la entidad <emphasis>Pet</emphasis> y se ha de corresponder
    con los field definidos anteriormente (<emphasis>name, weight,
    type</emphasis>). Estos elementos <emphasis>Text Field</emphasis> los
    definiremos en la banda <emphasis>Detail1</emphasis>, puesto que se
    repetirán para cada uno de los elementos de la fuente de datos del
    subreport. Recordemos que la fuente de datos de este subreport la habíamos
    definido anteriormente como <emphasis
    role="bold">JRBeanCollectionDataSource</emphasis> usando la colección de
    <emphasis>Pets</emphasis> que pertenecen a un
    <emphasis>Owner</emphasis>.</para>

    <para>En los Text Field, es importante establecer correctamente la
    propiedad Expression Class, esta se ha de corresponder con el tipo Java
    del field definido y que se va a usar para mostrarlo. Por ejemplo, el Text
    Field que mostará el peso de la mascota tendría las propiedades como
    sigue:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Text Field Expression</emphasis>
        <emphasis>$F{weight}</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Expression Class</emphasis>
        <emphasis>java.lang.Float</emphasis></para>
      </listitem>
    </itemizedlist>

    <para>Para establecer el Text Field Expression podemos usar el diálogo
    pertinente que nos permite seleccionar de entre los campos definidos en el
    informe, o entre los parámetros, e incluso acceder a alguna de las
    operaciones típicas sobre objetos Java.</para>

    <figure>
      <title>iReport - Diálogo Text Field Expression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-7.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Obviamente en un <emphasis>Text Field</emphasis> podemos establecer
    expresiones más elaboradas, como añadirle la cadena de las unidades de
    peso. Pero debemos tener en cuenta que la propiedad <emphasis>Expression
    Class</emphasis> deberá establecerse al tipo Java resultante de la
    expresión. (<emphasis>Ej.: $F{weight} + "kg" resulta en un
    java.lang.String</emphasis>). Por ejemplo, en el <emphasis>Text
    Field</emphasis> que mostará el tipo de mascota, definiremos como
    expresión: <emphasis>$F{type}.toString()</emphasis> y clase
    <emphasis>java.lang.String</emphasis>.</para>

    <para>Ya tenemos diseñado nuestra banda de detalle y para terminar el
    subreport, opcionalmente, podemos definir un <emphasis>Text
    Field</emphasis> que nos indique cuantos registros de
    <emphasis>Pet</emphasis> se han impreso cada vez que se ejecuta el
    subreport. Esto lo tenemos incluido en el informe padre (el de los
    propietarios) y se trata de usar la variable del report <emphasis
    role="bold">REPORT_COUNT</emphasis>, ya difinida por defecto. La
    incluimos, en la banda <emphasis role="bold">Summary</emphasis>, con un
    <emphasis>Text Field</emphasis> en la que <emphasis>Expression</emphasis>
    toma el valor <emphasis>$V{REPORT_COUNT}</emphasis> y <emphasis
    role="bold">Class</emphasis>
    <emphasis>java.lang.Integer</emphasis>.</para>

    <para>Solo nos queda arrancar de nuevo la aplicación, desde el plugin
    Tomcat de Eclipse o desde la línea de comandos con <emphasis>mvn
    tomcat:run</emphasis> y probar la generación del informe de Owners.</para>

    <figure>
      <title>Informe Owners con subreport Pets</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-8.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>JasperReports permite hacer muchas cosas al trabajar con subreports
    (paso de parámetros desde el informe padre a los subinformes, devolución
    de parámetros desde los subinformes al informe padre, actualización de
    variables, ...). Lo mejor que podemos hacer para profundizar es mirar la
    documentación de referencia de JasperReports e iReport.</para>
  </section>
</chapter>
