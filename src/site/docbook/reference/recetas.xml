<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="recetas" xml:lang="es"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title xml:lang="es">Recetas</title>

  <para xml:lang="es">En este capítulo se verá como realizar algunas modificaciones 
  sobre el código generado para adaptar la aplicación a distintos
  requerimientos habituales dada la experiencia de uso del framework.</para>

  <section xml:id="recetas-repositorio_maven">
    <title xml:lang="es">Repositorios Maven</title>

    <para xml:lang="es">Cuando una funcionalidad generada por el framework
    requiere de librerías externas, el add-on correspondiente registrará
    el repositorio de artefactos Maven necesario en el fichero
    <emphasis>pom.xml</emphasis>, si todavía no lo estaba.</para>
    
    <para xml:lang="es">No es habitual, pero en el caso de ser necesario añadir algún
    repositorio adicional al proyecto puede realizarse mediante el comando de la consola <link
    xlink:href="http://static.springsource.org/spring-roo/reference/html-single/index.html#command-index-maven-repository-add">
    maven repository add </link>. El siguiente ejemplo define el repositorio Maven
    interno de la Consejería de Infraestructuras, Transporte y Medio
    Ambiente. Este repositorio es accesible únicamente desde la red interna
    de la Consejería.</para>

<programlisting>roo-gvNIX> maven repository add --id citma-maven --name "CITMA Maven Repository" 
		--url http://benigno.coput.gva.es:8081/nexus/content/groups/public
Updated ROOT/pom.xml [
		added repository http://benigno.coput.gva.es:8081/nexus/content/groups/public]</programlisting>

    <para xml:lang="es">El comando modificará el fichero pom.xml y en la sección
    <emphasis>&lt;repositories&gt;</emphasis> añadirá la definición del repositorio
    indicado.</para>

    <programlisting>&lt;repositories&gt;
    ...
    &lt;repository&gt;
        &lt;id&gt;citma-maven&lt;/id&gt;
        &lt;url&gt;http://benigno.coput.gva.es:8081/nexus/content/groups/public&lt;/url&gt;
        &lt;name&gt;CITMA Maven Repository&lt;/name&gt;
    &lt;/repository&gt;
    ...
&lt;/repositories&gt;</programlisting>

    <para xml:lang="es">En el lado opuesto, también es posible eliminar repositorios
    Maven del proyecto mediante el comando <link
    xlink:href="http://static.springsource.org/spring-roo/reference/html-single/index.html#command-index-maven-repository-remove">
    maven repository remove </link>. </para>

  </section>

  <section xml:id="recetas-finders-multitud-campos">
    <title xml:lang="es">Desarrollo de buscadores con gran cantidad de campos</title>

    <para xml:lang="es">El add-on de los buscadores (finder) tiene una limitación
    impuesta por el sistema operativo Windows en el tamaño máximo del nombre de
    archivos. La limitación del tamaño máximo del nombre de
    archivo limita al comando <emphasis>finder add</emphasis> a generar
    nombres de buscadores que generen paths a archivos jspx de tamaño
    menor de 244 caracteres.</para>

    <para xml:lang="es">Existe una forma para generar buscadores con un tamaño
    superior al de la limitación impuesta. Consiste en
    dividir el buscador necesario en varios más pequeños, parciales de unos
    pocos campos cada uno, y al final unir el código que se genera para cada
    uno de ellos en un unico método. Esto implica tener que modificar el
    código que se ha generado para el buscador en la entidad, el controlador y
    la jspx de la siguiente forma:</para>

    <itemizedlist>
      <listitem>
        <para xml:lang="es">En el archivo Java de la entidad para la que se está
        generando el buscador crear un método con el nombre, por ejemplo, 
        <emphasis>findByTodo</emphasis> y cuyos parámetros de entrada serán
        todos los parámetros que reciben los métodos de los buscadores
        parciales que se hayan generado. Del mismo modo, el cuerpo de este nuevo
        método es la unión de la implementación de todos los buscadores
        parciales. Es posible modificar el código, según se explica
        en el siguiente apartado, de forma que los parámetros sean
        opcionales.</para>
      </listitem>

      <listitem>
        <para xml:lang="es">De manera similar, en el fichero Java del controlador de la
        entidad crear dos métodos: uno <emphasis>findByTodoForm</emphasis> que
        devolverá la vista del formulario del buscador y otro
        <emphasis>findByTodo</emphasis> que responderá a las peticiones que lleguen
        desde el formulario del buscador. Este segundo método, al igual que
        en el método creado en la entidad, deberá tener como parámetros la unión de
        todos parámetros de los métodos de los buscadores parciales en el controlador.
        El cuerpo de este método deberá invocar al método <emphasis>findByTodo</emphasis>
        creado en la entidad. Para definir la anotación @RequestMapping de estos dos
        métodos se recomienda utilizar como guía los buscadores parciales ya existentes.</para>
      </listitem>

      <listitem>
        <para xml:lang="es">Finalmente, crear una página jspx (por ejemplo, con nombre
        findByTodo.jspx) en el directorio WEB-INF/views/&lt;entidad&gt; que
        contendrá el formulario del buscador. Esta página debe incluir todos
        los campos que hayan en el resto de páginas jspx de los buscadores parciales.
        Recordar, que esta vista se ha de definir también en el fichero views.xml
        que hay en la misma carpeta y que esta vista es la que devuelve
        el método findByTodoForm creada anteriormente en el controlador.</para>
      </listitem>
    </itemizedlist>

    <para xml:lang="es">Con todo lo anterior se ha descrito un proceso manual
    que permite montar buscadores con cualquier cantidad de campos.</para>
	
  </section>
	
  <section xml:id="recetas-finders-modificar">
    <title xml:lang="es">Campos opcionales en los buscadores</title>

    <para xml:lang="es">El comportamiento que implementa automáticamente la generación
    de buscadores es hacer todos los campos de busqueda obligatorios.
    Por lo tanto, si no se proporciona alguno de los parámetros
    se generará una excepción indicando la falta de un parámetro
    obligatorio. En ocasiones no es lo deseado, es decir,
    puede necesario que los parámetros no informados simplemente
    no se incluyan en la consulta si no se especifican. Para ello se debe
    modificar el código del método <emphasis>finderByXxxx</emphasis>
    declarado en el aspecto Java <emphasis>*_Roo_Finder.aj</emphasis>.
    A continuación se ejemplifica como hacer este cambio.</para>

    <para xml:lang="es">Hacer <emphasis>push-in</emphasis> del método tal y como
    se comenta en la sección sobre <link
    linkend="guia-desarrollo_generacion-codigo">modificación del código
    generado</link> y llevarlo al fichero Java de la entidad. Una vez allí
    modificarlo para que no requiera los campos y así construir la consulta
    considerando tan solo los parámetros que lleguen informados:</para>

    <programlisting>public static TypedQuery&lt;Owner&gt; findOwnersByLastNameLikeAndCityLike(
    		String lastName, String city) {
  <command>StringBuilder query = new StringBuilder("SELECT o FROM Owner AS o");</command>
  <command>StringBuilder whereClause = new StringBuilder();</command>

  <command>// if (lastName == null || lastName.length() == 0)
  // throw new IllegalArgumentException(&quot;The lastName argument is required&quot;);
  if (lastName != null &amp;&amp; lastName.length() &gt; 0) {</command>
    lastName = lastName.replace('*', '%');
    if (lastName.charAt(0) != '%') {
        lastName = "%" + lastName;
    }
    if (lastName.charAt(lastName.length() - 1) != '%') {
        lastName = lastName + "%";
    }
    <command>whereClause.append(" WHERE LOWER(o.lastName) LIKE LOWER(:lastName)");</command>
  }

  <command>// if (city == null || city.length() == 0)
  // throw new IllegalArgumentException(&quot;The city argument is required&quot;);
  if (city != null &amp;&amp; city.length() &gt; 0) {</command>
    city = city.replace('*', '%');
    if (city.charAt(0) != '%') {
        city = "%" + city;
    }
    if (city.charAt(city.length() - 1) != '%') {
        city = city + "%";
    }
    <command>if (whereClause.length() &gt; 0) {
      whereClause.append(" AND LOWER(o.city) LIKE LOWER(:city)");
    } else {
      whereClause.append(" WHERE LOWER(o.city) LIKE LOWER(:city)");
    }</command>
  }
  <command>query.append(whereClause);</command>

  EntityManager em = Owner.entityManager();
  TypedQuery&lt;Owner&gt; q = em.createQuery(<command>query.toString()</command>, Owner.class);
  <command>if (lastName != null &amp;&amp; lastName.length() &gt; 0) {</command>
    q.setParameter("lastName", lastName);
  }
  <command>if (city != null &amp;&amp; city.length() &gt; 0) {</command>
    q.setParameter("city", city);
  }
  return q;
}</programlisting>

    <para xml:lang="es">Se han marcado en negrita las líneas de código modificadas.
    Como puede observarse, se construye la consulta de forma dinámica de forma
    que se añaden los distintos filtros al <emphasis>where</emphasis> de la consulta
    solo si el campo asociado al filtro tiene algún valor y se elimina la generación
    de excepciones al detectar alguno de dichos campos como vacío.</para>

    <para xml:lang="es">En este ejemplo se ha construido la consulta usando un
    StringBuilder en el que se genera la consulta deseada, pero se podría
    utilizar cualquier otra tecnología como por ejemplo Hibernate
    Criteria Builder.</para>

    <para xml:lang="es">Como ya se ha comentado, el código generado fuerza que todos los
    parámetros de búsqueda sean obligatorios, esto implica también al
    formulario situadao en la página jspx. Tal como se genera, si alguno de los campos no se
    rellena, no dejará enviar la petición. Se debe editar la jspx y
    modificar el atributo <emphasis>required</emphasis> de los campos
    <emphasis>field</emphasis> y establecer su valor a
    <emphasis>false</emphasis>, no olvidar cambiar el valor
    del atributo <emphasis>z</emphasis> a
    "<emphasis>user-managed</emphasis>" para indicar que este campo ha sido
    personalizado.</para>

    <programlisting>&lt;field:input disableFormBinding="true" field="city"
    		id="f_com_springsource_petclinic_domain_Owner_city" max="30" <emphasis
        role="bold">
        		required="false" z="user-managed"</emphasis>/&gt;</programlisting>

    <para xml:lang="es">En los buscadores en los que uno de los parámetros sea
    una entidad del modelo, es decir una relación con otra entidad del modelo,
    será necesario realizar un cambio adicional.
    En estos casos se visualiza un selector desplegable, mediante el
    componente <emphasis>select.tagx</emphasis>. Sin embargo, este selector
    tiene el inconveniente de que no incluye una opción vacía
    entre las disponibles, con lo que obliga a elegir siempre algún valor.
    Un ejemplo de este caso se encuentra en el buscador findPetsByOwner generado
    para la entidad Pet en el ejemplo de <emphasis>clinic.roo</emphasis>
    .</para>

    <para xml:lang="es">La forma de tratar estas peticiones en Spring MVC es intentar
    cargar el registro asociado con el valor del selector que llega como parámetro.
    Por tanto si llega como parámetro un dato que no concuerda con ningún registro de
    la entidad parámetro, usará null como valor. Como se ha comentado,
    el componente <emphasis>select.tagx</emphasis> no ofrece una opción
    vacía. gvNIX en su <link linkend="addon-web-screen-patterns">Add-on Web
    MVC Pattern</link> incluye un componente
    <emphasis>select-withempty.tagx</emphasis> que sí lo ofrece. Mediante el
    comando <emphasis>web mvc pattern install</emphasis> se instalan los
    componentes de MVC Pattern entre los que se incluye el selector con
    opción vacía. Entonces es posible modificar la jspx del buscador findPetsByOwner
    para que utilice <emphasis>select-withempty</emphasis> en lugar del original
    de la siguiente forma:</para>

    <programlisting>&lt;div xmlns:field="urn:jsptagdir:/WEB-INF/tags/form/fields" ... 
    		<emphasis role="bold">xmlns:pattern-field="urn:jsptagdir:/WEB-INF/tags/pattern/form/fields"</emphasis>
    		version="2.0"&gt;
  &lt;jsp:directive.page contentType="text/html;charset=UTF-8"/&gt;
  &lt;jsp:output omit-xml-declaration="yes"/&gt;
  &lt;form:find finderName="ByOwner" id="ff_com_springsource_petclinic_domain_Pet"
  		path="/pets" z="ThIGSmua6R7WM6q2P1BpNC3zMi4="&gt;
      <emphasis role="bold">&lt;pattern-field:select-withempty disableFormBinding="true" field="owner"
      		emptyValueEnable="true" emptyValue="0"
      		id="f_com_springsource_petclinic_domain_Pet_owner" itemValue="id"
      		items="${owners}" path="/owners" required="false" z="user-managed"/&gt;</emphasis>
  &lt;/form:find&gt;
&lt;/div&gt;</programlisting>

    <para xml:lang="es">El componente select-withempty.tagx tiene los mismos atributos que el
    select.tagx y otros tres adicionales:</para>

    <itemizedlist>
      <listitem>
        <para xml:lang="es"><emphasis>emptyValueEnable</emphasis>: Valor booleano que habilita la
        opción vacía en el selector.</para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis>emtpyValue</emphasis>: Valor a dar
        para la opción vacía del selector. Si se corresponde con una entidad,
        este valor no debería corresponder con ningún identificador existente
        para esa entidad, de esta forma el valor que llega al buscador es
        nulo.</para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis>emptyLabel</emphasis>: Descripción a mostrar para la
        opción vacía del selector.</para>
      </listitem>
    </itemizedlist>

    <para xml:lang="es">Con este cambio y con el método findPetsByOwner modificado
    para que no sea requerido el parámetro Owner, de la misma forma
    que se explicado antes, se consigue realizar búsquedas por parámetros opcionales
    sea cual sea el tipo del parámetro.</para>
  </section>

  <section xml:id="recetas-reports">
    <title xml:lang="es">Diseño de Informes que contienen sub-informes</title>

    <para xml:lang="es">gvNIX ofrece un add-on (<link linkend="addon-web-report">Add-on Web
    Report</link>) que facilita la definición de informes sobre una entidad.
    El add-on genera el diseño básico de un informe JasperReports el cual
    podemos modificar usando un diseñador como iReport.</para>

    <para xml:lang="es">Podemos necesitar que el informe definido muestre los elementos de
    una entidad relacionada con la entidad sobre la que se ha declarado el
    informe. Por ejemplo, en la aplicación PetClinic, podríamos definir un
    informe sobre la entidad Owner y queremos que, para cada Owner, se muestre
    en el reporte, se muestre también la lista de mascotas que le pertenecen,
    es decir, listar la relación definida por el campo
    <emphasis>pets</emphasis> de la entidad Owner.</para>

    <note>
      <para xml:lang="es">Para esta receta usaremos la versión 4.0.1 de iReport.</para>
    </note>

    <para xml:lang="es">Partamos del informe definido por el comando gvNIX:</para>

    <programlisting>roo-gvNIX&gt; web report add --controller ~.web.OwnerController --reportName ownerpets</programlisting>

    <para xml:lang="es">En src/main/webapp/WEB-INF/reports se ha creado el archivo de diseño
    de informe <emphasis>owner_ownerpets.jrxml</emphasis>. Abrimos este
    archivo usando iReport (<emphasis>Archivo &gt; Open</emphasis>).</para>

    <figure>
      <title xml:lang="es">iReport - Diseñador</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-1.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">En la parte izquierda, en la ventana de Report Inspector podemos ver
    los elementos principales de diseño del informe JasperReports. </para>

    <figure>
      <title xml:lang="es">iReport - Report Inspector</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-2.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">Lo primero que tenemos que hacer es declarar un nuevo Parámetro con
    el nombre <emphasis>SubReportPetsLocation</emphasis>. Para ello hacer
    click con el botón derecho sobre el elemento
    <emphasis>Parameters</emphasis> y seleccionamos la opción
    <emphasis>Agregar Parameter</emphasis>. Justo debajo del último parámetro
    aparecerá el que estoms añadiendo (<emphasis>parameter1</emphasis>), si lo
    seleccionamos, en la parte derecha de la ventana de iReport podremos ver
    sus propiedades. En <emphasis role="bold">Name</emphasis> indicamos
    <emphasis>SubReportPetsLocation</emphasis> y <emphasis
    role="bold">Parameter Class</emphasis> establecemos
    <emphasis>net.sf.jasperreports.engine.JasperReport</emphasis>.</para>

    <para xml:lang="es">Ahora debemos añadir un elemento Subreport a nuestro diseño, y como
    queremos que aparezca para cada elemento de la lista de Owners, debemos
    hacerlo en la banda de detalle (<emphasis>Detail1</emphasis>) del informe.
    Necesitaremos aumentar la altura de la banda <emphasis>Detail1</emphasis>.
    La seleccionamos y en sus propiedades indicamos <emphasis role="bold">Band
    height</emphasis> <emphasis>55</emphasis>. De la paleta de elementos
    seleccionamos <emphasis role="bold">Subreport</emphasis> y lo arrastramos
    a la banda de detalle. Se nos abrirá un asistente, seleccionamos la opción
    <emphasis>"Just create the subreport element"</emphasis> y cerramos con
    Terminar. Podemos modificar las dimensiones del elemento Subreport
    arrastrando las esquinas de la caja del elemento.</para>

    <figure>
      <title xml:lang="es">iReport - Subreport</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-3.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">Antes de seguir con el establecimiento de las propiedades del
    Subreport, necesitamos declarar un campo del informe que nos permitirá
    acceder al campo <emphasis>pets</emphasis> de la Entidad
    <emphasis>Owner</emphasis>. En "<emphasis>Report Inspector</emphasis>",
    seleccionamos <emphasis>Fields</emphasis> y con el botón derecho
    <emphasis>Agregar Field</emphasis>. Al igual que con el parámetro
    SubReportPetsLocation indicamos <emphasis role="bold">Name</emphasis>
    <emphasis>pets</emphasis> y <emphasis role="bold">Field Class</emphasis>
    <emphasis>java.util.Collection</emphasis>.</para>

    <para xml:lang="es">Debemos indicar cuales son las propiedades del Subreport. En la
    ventana de propiedades de la derecha buscamos las siguientes propiedades y
    establecemos los valores correspondientes:</para>

    <orderedlist>
      <listitem>
        <para xml:lang="es"><emphasis role="bold">Subreport Expression</emphasis> =
        <emphasis>$P{SubReportPetsLocation}</emphasis></para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis role="bold">Expression Class</emphasis> =
        <emphasis>net.sf.jasperreports.engine.JasperReport</emphasis></para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis role="bold">Connection type</emphasis> = <emphasis>Use
        a datasource expression</emphasis></para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis role="bold">Data Source Expression</emphasis> =
        <emphasis>new
        net.sf.jasperreports.engine.data.JRBeanCollectionDataSource($F{pets})</emphasis></para>
      </listitem>
    </orderedlist>

    <para xml:lang="es">En el flujo de ejecución de un informe JasperReports, los parámetros
    del mismo han de ser informados antes de la operación
    <emphasis>print</emphasis> o, de lo contrario, cojerán valores por defecto
    que se hayan definido o <emphasis>null</emphasis> en su defecto. Hemos de
    fijarnos que hemos definido el parámetro
    <emphasis>SubReportPetsLocation</emphasis>, el valor que toma este
    parámetro en tiempo de ejecución ha de ser un path absoluto en el sistema
    de archivos o en el classpath de la aplicación. En <link
    linkend="addon-web-report">Add-on Web Report</link> se indicaba que al
    añadir un informe a la aplicación, usando el comando <emphasis>web report
    add</emphasis>, en el archivo
    <emphasis>src/main/webapp/WEB-INF/spring/jasper-views.xml</emphasis> se
    declaraba un bean que indicaba la ruta hasta el fichero jrxml del informe
    añadido. Este bean tiene un atributo que indica donde se declaran la
    localización de los subreports que se usan en los distintos informes
    (atributo p:subReportsUrls-ref).</para>

    <programlisting>&lt;bean id="owner_ownerpets"
      class="com.springsource.petclinic.web.servlet.view.jasperreports.CustomJasperReportsMultiFormatView" 
      p:reportDataKey="ownerpetsList" p:url="/WEB-INF/reports/owner_ownerpets.jrxml"
      p:subReportDataKeys-ref="subReportDataKeys" <emphasis role="bold">p:subReportUrls-ref="subReportUrls"</emphasis> /&gt;</programlisting>

    <para xml:lang="es">Es en el &lt;util:map/&gt;, declarado en el mismo jasper-views.xml,
    al que apunta el valor del atributo
    <emphasis>p:subReportsUrls-ref</emphasis> donde estbleceremos el valor que
    ha de tomar el parámetro <emphasis>SubReportPetsLocation.</emphasis>
    Modificamos este elemento añadiendo una entrada, quedando como se muestra
    a continuación:</para>

    <programlisting>&lt;util:map id="<emphasis role="bold">subReportUrls</emphasis>"&gt;
  &lt;!-- This entry key must be declared exactly as you declared it in the master JRXML file --&gt;
  &lt;!-- Add one &lt;entry /&gt; node for each sub-report you need to define --&gt;
  &lt;!-- &lt;entry key="mySubReportLocation" value="/WEB-INF/reports/my-sub-report-file.jasper"/&gt; --&gt;
  <emphasis role="bold">&lt;entry key="SubReportPetsLocation" value="/WEB-INF/reports/owner_ownerpets_sub_pets.jrxml"/&gt;</emphasis>
&lt;/util:map&gt;</programlisting>

    <para xml:lang="es">En este elemento &lt;util:map/&gt; podemos añadir tantos
    &lt;entry/&gt; como necesitemos para definir los valores de los parámetros
    que indican donde se localizan los archivos jrxml de los distintos
    subreports que precisemos en nuestra aplicación.</para>

    <para xml:lang="es">Ahora nos queda diseñar el informe que mostrará el listado de
    mascotas (pets) y que conformará nuestro subreport.</para>

    <para xml:lang="es">Creamos un nuevo diseño de informe (<emphasis>Archivo &gt;
    Nuevo</emphasis>), y en el asistente que se nos muestra seleccionamos
    <emphasis>Blank A4</emphasis> y <emphasis>Open This Template</emphasis>.
    Nos pedirá que demos un nombre al diseño y donde queremos guardarlo.
    Indicamos <emphasis>owner_ownerpets_sub_pets.jrxml</emphasis> y lo
    guardamos en el mismo directorio donde tenemos el report padre
    (<emphasis>owner_ownerpets.jrxml</emphasis>).</para>

    <figure>
      <title xml:lang="es">iReport - Nuevo diseño</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-4.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <important>
      <para xml:lang="es">Debemos asegurarnos que el nuevo informe se crea para usar Java
      como lenguaje para las expresiones. En <emphasis>Report
      Inspector</emphasis>, si seleccionamos el primer elemento (el nombre del
      informe) y miramos en sus propiedades (parte derecha de la pantalla de
      iReport) debemos buscar la propiedad <emphasis>Language</emphasis>, si
      no tiene el valor Java, debemos cambiarlo usando el desplegable.</para>
    </important>

    <para xml:lang="es">Este nuevo informe, que constituirá nuestro subreport, es un informe
    a todos los efectos, por tanto debemos definir aquellos campos (elemento
    Fields del diseño), parámetros (elemento Parameters) y todo aquello que
    necesitemos.</para>

    <para xml:lang="es">Al igual que hemos hecho antes con el campo pets del informe padre,
    definamos los campos que nos permitirán acceder a los campos de la entidad
    Pet que mostraremos en el subreport. Click con el botón derecho sobre
    Fields y Agregar Field:</para>

    <orderedlist>
      <listitem>
        <para xml:lang="es">Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>name</emphasis> - <emphasis role="bold">Field
        Class</emphasis> <emphasis>java.lang.String</emphasis> </para>
      </listitem>

      <listitem>
        <para xml:lang="es">Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>weight</emphasis> - <emphasis role="bold">Field
        Class</emphasis> <emphasis>java.lang.Float</emphasis></para>
      </listitem>

      <listitem>
        <para xml:lang="es">Creamos field <emphasis role="bold">Name</emphasis>
        <emphasis>type</emphasis> - <emphasis role="bold">Field
        Class</emphasis>
        <emphasis>com.springsource.petclinic.reference.PetType</emphasis>
        (enumerado declarado en nuestro proyecto PetClinic)</para>
      </listitem>
    </orderedlist>

    <para xml:lang="es">El diseño del informe se compone de distitnas bandas, donde se
    colocan los elementos que queremos mostrar (<emphasis>Title, Page Header,
    Collumn Header, Detail1, Collumn Footer, ...</emphasis>). Para un
    subreport como el que necesitamos para este ejemplo, algunas bandas son
    innecesarias y podemos eliminarlas. Esto nos permitirá ajustar mejor el
    diseño completo de nuestro informe (informe padre ownerpets + subreport
    pets). Si se hace click con el botón derecho sobre
    <emphasis>Title</emphasis> y se selecciona <emphasis>Delete
    Band</emphasis>, es eliminada. Haciéndolo con todas excepto
    <emphasis>Collumn Header, Detail1 y Summary</emphasis>.</para>

    <figure>
      <title xml:lang="es">iReport - Bandas subreport</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-6.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es"><emphasis>Collumn Header</emphasis> es una banda que se dibujará
    solo al inicio de la columna del informe (en nuestro caso solo tenemos
    una). Aquí añadiremos textos estáticos que harán las veces de cabecera de
    tabla. Para ello de la paleta de componentes, seleccionamos
    <emphasis>Static Text</emphasis> y lo arrastramos hasta la banda
    <emphasis>Collumn Header</emphasis>.</para>

    <figure>
      <title xml:lang="es">iReport - Paleta</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-5.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">En el primer <emphasis>Static Text</emphasis> establecemo el valor
    <emphasis>Nombre</emphasis> y repetimos la misma operación para definir un
    texto para el campo <emphasis>Peso</emphasis> y para el
    <emphasis>Tipo</emphasis>. Podemos distribuir las etiquetas para que quede
    como en la captura anterior.</para>

    <para xml:lang="es">A continuación, haremos lo mismo pero usando el elemento
    <emphasis>Text Field</emphasis>. Este elemento sirve para mostrar el valor
    de un campo de la entidad <emphasis>Pet</emphasis> y se ha de corresponder
    con los field definidos anteriormente (<emphasis>name, weight,
    type</emphasis>). Estos elementos <emphasis>Text Field</emphasis> los
    definiremos en la banda <emphasis>Detail1</emphasis>, puesto que se
    repetirán para cada uno de los elementos de la fuente de datos del
    subreport. Recordemos que la fuente de datos de este subreport la habíamos
    definido anteriormente como <emphasis
    role="bold">JRBeanCollectionDataSource</emphasis> usando la colección de
    <emphasis>Pets</emphasis> que pertenecen a un
    <emphasis>Owner</emphasis>.</para>

    <para xml:lang="es">En los Text Field, es importante establecer correctamente la
    propiedad Expression Class, esta se ha de corresponder con el tipo Java
    del field definido y que se va a usar para mostrarlo. Por ejemplo, el Text
    Field que mostará el peso de la mascota tendría las propiedades como
    sigue:</para>

    <itemizedlist>
      <listitem>
        <para xml:lang="es"><emphasis role="bold">Text Field Expression</emphasis>
        <emphasis>$F{weight}</emphasis></para>
      </listitem>

      <listitem>
        <para xml:lang="es"><emphasis role="bold">Expression Class</emphasis>
        <emphasis>java.lang.Float</emphasis></para>
      </listitem>
    </itemizedlist>

    <para>Para establecer el Text Field Expression podemos usar el diálogo
    pertinente que nos permite seleccionar de entre los campos definidos en el
    informe, o entre los parámetros, e incluso acceder a alguna de las
    operaciones típicas sobre objetos Java.</para>

    <figure>
      <title xml:lang="es">iReport - Diálogo Text Field Expression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-7.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">Obviamente en un <emphasis>Text Field</emphasis> podemos establecer
    expresiones más elaboradas, como añadirle la cadena de las unidades de
    peso. Pero debemos tener en cuenta que la propiedad <emphasis>Expression
    Class</emphasis> deberá establecerse al tipo Java resultante de la
    expresión. (<emphasis>Ej.: $F{weight} + "kg" resulta en un
    java.lang.String</emphasis>). Por ejemplo, en el <emphasis>Text
    Field</emphasis> que mostará el tipo de mascota, definiremos como
    expresión: <emphasis>$F{type}.toString()</emphasis> y clase
    <emphasis>java.lang.String</emphasis>.</para>

    <para xml:lang="es">Ya tenemos diseñado nuestra banda de detalle y para terminar el
    subreport, opcionalmente, podemos definir un <emphasis>Text
    Field</emphasis> que nos indique cuantos registros de
    <emphasis>Pet</emphasis> se han impreso cada vez que se ejecuta el
    subreport. Esto lo tenemos incluido en el informe padre (el de los
    propietarios) y se trata de usar la variable del report <emphasis
    role="bold">REPORT_COUNT</emphasis>, ya difinida por defecto. La
    incluimos, en la banda <emphasis role="bold">Summary</emphasis>, con un
    <emphasis>Text Field</emphasis> en la que <emphasis>Expression</emphasis>
    toma el valor <emphasis>$V{REPORT_COUNT}</emphasis> y <emphasis
    role="bold">Class</emphasis>
    <emphasis>java.lang.Integer</emphasis>.</para>

    <para xml:lang="es">Solo nos queda arrancar de nuevo la aplicación, desde el plugin
    Tomcat de Eclipse o desde la línea de comandos con <emphasis>mvn
    tomcat:run</emphasis> y probar la generación del informe de Owners.</para>

    <figure>
      <title xml:lang="es">Informe Owners con subreport Pets</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/recetas-subreport-ireport-8.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para xml:lang="es">JasperReports permite hacer muchas cosas al trabajar con subreports
    (paso de parámetros desde el informe padre a los subinformes, devolución
    de parámetros desde los subinformes al informe padre, actualización de
    variables, ...). Lo mejor que podemos hacer para profundizar es mirar la
    documentación de referencia de JasperReports e iReport.</para>
  </section>
</chapter>
